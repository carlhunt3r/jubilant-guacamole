CREATE PROCEDURE [dwh].[BuildBridgingTradesperson]
AS
    SET NOCOUNT ON

    TRUNCATE TABLE dwh.Bridging_Tradesperson;

    WITH Teams
    AS
    (
        SELECT 
            PARENTID AS JobVisitId,
            STRING_AGG(ASSIGNEDWORKERID, '-') WITHIN GROUP (ORDER BY ASSIGNEDWORKERID) AS JobVisitTeam

        FROM 
            staging.drs_c_scheduleitem

        WHERE 
            ASSIGNEDWORKERID IS NOT NULL

        GROUP BY 
            PARENTID
    )


    INSERT INTO dwh.Bridging_Tradesperson
    (
        DRSUserId,
        JobVisitTeam
    )

    SELECT DISTINCT
        ASSIGNEDWORKERID, 
        JobVisitTeam

    FROM 
        Teams 
        
        JOIN staging.drs_c_scheduleitem
        ON JobVisitId  = PARENTID
dwh	BuildCalendarDimension	CREATE PROCEDURE [dwh].[BuildCalendarDimension]

AS

DROP TABLE IF EXISTS [dwh].[Dim_Calendar]

DECLARE @StartDate  date = '20100101'

DECLARE @CutoffDate date = DATEADD(DAY, -1, DATEADD(YEAR, 30, @StartDate))

DECLARE @CurrentFinancialYearStart CHAR(8) = CONCAT(CASE WHEN DATEPART(MONTH, GETDATE()) < 4 THEN DATEPART(YEAR, GETDATE()) - 1 ELSE DATEPART(YEAR, GETDATE()) END, '0401')

DECLARE @CurrentFinancialYearEnd CHAR(8) = CONCAT(CASE WHEN DATEPART(MONTH, GETDATE()) < 4 THEN DATEPART(YEAR, GETDATE()) ELSE DATEPART(YEAR, GETDATE()) + 1 END, '0331')

;WITH seq(n) AS 
(
  SELECT 0 UNION ALL SELECT n + 1 FROM seq
  WHERE n < DATEDIFF(DAY, @StartDate, @CutoffDate)
),
d(d) AS 
(
  SELECT DATEADD(DAY, n, @StartDate) FROM seq
),
src AS
(
  SELECT
    TheDate         = CONVERT(date, d),
    TheDay          = DATEPART(DAY,       d),
    TheDayName      = DATENAME(WEEKDAY,   d),
    TheWeek         = DATEPART(WEEK,      d),
    TheISOWeek      = DATEPART(ISO_WEEK,  d),
    TheDayOfWeek    = DATEPART(WEEKDAY,   d),
    IsWeekend           = CASE WHEN DATEPART(WEEKDAY,d) IN (CASE @@DATEFIRST WHEN 1 THEN 6 WHEN 7 THEN 1 END,7) 
                            THEN 1 ELSE 0 END,
    TheMonth        = DATEPART(MONTH,     d),
    TheMonthName    = DATENAME(MONTH,     d),
    TheQuarter      = DATEPART(Quarter,   d),
    TheYear         = DATEPART(YEAR,      d),
    TheFirstOfMonth = DATEFROMPARTS(YEAR(d), MONTH(d), 1),
    TheLastOfYear   = DATEFROMPARTS(YEAR(d), 12, 31),
    TheDayOfYear    = DATEPART(DAYOFYEAR, d),
    TheFinancialPeriod = CASE WHEN DATEPART(MONTH, d) >=4 THEN DATEPART(MONTH, d) - 3 ELSE DATEPART(MONTH,     d) + 9 END,
    TheFinancialQuarter = CASE WHEN DATEPART(MONTH, d) >=4 THEN DATEPART(QUARTER, d) - 1 ELSE 4 END,
    TheFinancialYear = CASE WHEN DATEPART(MONTH, d) < 4 THEN CONCAT(DATEPART(YEAR, d) - 1, '-', DATEPART(YEAR, d)) ELSE CONCAT(DATEPART(YEAR, d), '-', DATEPART(YEAR, d) +1) END,
    InTheFinancialYTD = CASE WHEN CONVERT(date, d) BETWEEN @CurrentFinancialYearStart AND @CurrentFinancialYearEnd THEN 1 ELSE 0 END

  FROM d
),
dim AS
(
  SELECT
    CAST(CAST([TheDate] AS DATETIME) AS FLOAT) + 2 AS DateKey, --The +2 ensures the returned value matches Qlik which uses 30/12/1899 as its calendar start. SQL Server uses 01/01/1900.
    TheDate, 
    TheDay,
    TheDaySuffix        = CONVERT(char(2), CASE WHEN TheDay / 10 = 1 THEN 'th' ELSE 
                            CASE RIGHT(TheDay, 1) WHEN '1' THEN 'st' WHEN '2' THEN 'nd' 
                            WHEN '3' THEN 'rd' ELSE 'th' END END),
    TheDayName,
    TheDayOfWeek,
    TheDayOfWeekInMonth = CONVERT(tinyint, ROW_NUMBER() OVER 
                            (PARTITION BY TheFirstOfMonth, TheDayOfWeek ORDER BY TheDate)),
    TheDayOfYear,
    IsWeekend,           /*= CASE WHEN TheDayOfWeek IN (CASE @@DATEFIRST WHEN 1 THEN 6 WHEN 7 THEN 1 END,7) 
                            THEN 1 ELSE 0 END,*/
    TheWorkingDayOfMonth = CASE WHEN IsWeekend = 0 THEN ROW_NUMBER() OVER (PARTITION BY TheYear, TheMonth ORDER BY IsWeekend ASC, TheDate ASC) END,
    TheWeek,
    TheISOweek,
    TheFirstOfWeek      = DATEADD(DAY, 1 - TheDayOfWeek, TheDate),
    TheLastOfWeek       = DATEADD(DAY, 6, DATEADD(DAY, 1 - TheDayOfWeek, TheDate)),
    TheWeekOfMonth      = CONVERT(tinyint, DENSE_RANK() OVER 
                            (PARTITION BY TheYear, TheMonth ORDER BY TheWeek)),
    TheMonth,
    TheMonthName,
    LEFT(TheMonthName, 3) AS TheMonthNameShort,
    TheFirstOfMonth,
    TheLastOfMonth      = MAX(TheDate) OVER (PARTITION BY TheYear, TheMonth),
    TheFirstOfNextMonth = DATEADD(MONTH, 1, TheFirstOfMonth),
    TheLastOfNextMonth  = DATEADD(DAY, -1, DATEADD(MONTH, 2, TheFirstOfMonth)),
    TheQuarter,
    TheFirstOfQuarter   = MIN(TheDate) OVER (PARTITION BY TheYear, TheQuarter),
    TheLastOfQuarter    = MAX(TheDate) OVER (PARTITION BY TheYear, TheQuarter),
    TheYear,
    TheISOYear          = TheYear - CASE WHEN TheMonth = 1 AND TheISOWeek > 51 THEN 1 
                            WHEN TheMonth = 12 AND TheISOWeek = 1  THEN -1 ELSE 0 END,      
    TheFirstOfYear      = DATEFROMPARTS(TheYear, 1,  1),
    TheLastOfYear,
    TheFinancialPeriod,
    TheFinancialQuarter,
    TheFinancialYear,
    InTheFinancialYTD,
    DATEDIFF(mm, TheDate, GETDATE()) AS TheMonthsAgo,
    CAST(LEFT(@CurrentFinancialYearStart, 4) AS INT) -  CAST(LEFT(TheFinancialYear, 4) AS INT) AS TheFinancialYearsAgo,
    IsLeapYear          = CONVERT(bit, CASE WHEN (TheYear % 400 = 0) 
                            OR (TheYear % 4 = 0 AND TheYear % 100 <> 0) 
                            THEN 1 ELSE 0 END),
    Has53Weeks          = CASE WHEN DATEPART(WEEK,     TheLastOfYear) = 53 THEN 1 ELSE 0 END,
    Has53ISOWeeks       = CASE WHEN DATEPART(ISO_WEEK, TheLastOfYear) = 53 THEN 1 ELSE 0 END,
    MMYYYY              = CONVERT(char(2), CONVERT(char(8), TheDate, 101))
                          + CONVERT(char(4), TheYear),
    Style101            = CONVERT(char(10), TheDate, 101),
    Style103            = CONVERT(char(10), TheDate, 103),
    Style112            = CONVERT(char(8),  TheDate, 112),
    Style120            = CONVERT(char(10), TheDate, 120)
  FROM src
)
SELECT * 
INTO [dwh].[Dim_Calendar] 
FROM dim
  ORDER BY TheDate
  OPTION (MAXRECURSION 0);
dwh	BuildDimAbsence	





-- =============================================
-- Author:      Amit Kakkad
-- Create Date: 17th May 2024
-- Description: Initial Version: Transforms DimAbsence Data

-- Author:      Amit Kakkad
-- Create Date: 09th Sept 2024
-- Description: Fix null AbsenceEndDate issue

-- =============================================

CREATE PROCEDURE [dwh].[BuildDimAbsence] 
AS
BEGIN
    -- SET NOCOUNT ON added to prevent extra result sets from
    -- interfering with SELECT statements.
    SET NOCOUNT ON

-- Check if the DimAbsence table exists
IF OBJECT_ID('dwh.Dim_Absence') IS NOT NULL
BEGIN
    DROP TABLE dwh.Dim_Absence;
END;

--AbsenceTypeMap:
SELECT
	AbsenceKey,
	AbsenceType
INTO #TempAbsenceTypeMap
FROM [staging].[mhr_dimabsence];

--AbsenceReasonMap:
SELECT
	AbsenceKey,
	AbsenceReason
INTO #TempAbsenceReasonMap
FROM [staging].[mhr_dimabsence];

WITH DimAbsencePeekLoad AS (
    SELECT 
        a.AbsenceKey, 
        a.AbsenceID,
        CAST(a.AbsenceStartDate AS DATE) AS AbsenceStartDate,
        CAST(a.AbsenceEndDate AS DATE) AS AbsenceEndDate,
        fad.PersonKey,
        LAG(fad.PersonKey) OVER (PARTITION BY fad.PersonKey ORDER BY CAST(a.AbsenceStartDate AS DATE)) AS PrevPersonKey,
        LAG(CAST(a.AbsenceEndDate AS DATE)) OVER (PARTITION BY fad.PersonKey ORDER BY CAST(a.AbsenceStartDate AS DATE)) AS PrevAbsenceEndDate
    FROM 
        [staging].[mhr_dimabsence] a
    LEFT JOIN 
        (SELECT DISTINCT PersonKey, AbsenceKey FROM [staging].[mhr_FactAbsenceDaily]) fad
        ON a.AbsenceKey = fad.AbsenceKey
    WHERE 
        a.AbsenceType = 'Company Sick Pay'
)
SELECT 
    AbsenceKey, 
    AbsenceID,
    AbsenceStartDate,
    AbsenceEndDate,
    PersonKey,
    CASE 
        WHEN PersonKey = PrevPersonKey AND AbsenceStartDate = DATEADD(DAY, 1, PrevAbsenceEndDate) 
        THEN 1 
        ELSE 0 
    END AS IncorrectAbsence_Flag
INTO #tempDimAbsencePeekLoad
FROM 
    DimAbsencePeekLoad;

--IncorrectAbsenceMap:
SELECT Distinct
	AbsenceKey,
	IncorrectAbsence_Flag
INTO #tempIncorrectAbsenceMap
FROM #tempDimAbsencePeekLoad;

SELECT
	1 as DimAbsence_Flag,
	st.AbsenceKey, 
	CASE 
		WHEN DATEDIFF(
			DAY, 
			DATEADD(DAY, -1, AbsenceStartDate), 
			CASE 
				WHEN LEN(CAST(AbsenceEndDate AS VARCHAR)) < 1 OR AbsenceEndDate IS NULL THEN GETDATE()
				ELSE AbsenceEndDate 
			END
		) < 20 THEN 'Short'
		WHEN DATEDIFF(
			DAY, 
			DATEADD(DAY, -1, AbsenceStartDate), 
			CASE 
				WHEN LEN(CAST(AbsenceEndDate AS VARCHAR)) < 1 OR AbsenceEndDate IS NULL THEN GETDATE()
				ELSE AbsenceEndDate 
			END
		) >= 20 THEN 'Long'
		ELSE 'No Data'
	END AS DimAbsenceTermCalculatedByDate,
	AbsenceID,  
	CAST(AbsenceStartDate AS DATE) AS AbsenceStartDate, 
	CAST(AbsenceEndDate AS DATE) AS AbsenceEndDate, 
    CASE 
        WHEN AbsenceEndDate IS NULL OR LEN(AbsenceEndDate) < 1 THEN 1
        ELSE 0
    END AS DimAbsenceNoEndDate_Flag,
	AbsenceTypeID, 
	AbsenceGroup, 
	AbsenceType, 
    CASE 
        WHEN LEN(AbsenceReason) < 1 THEN 'No Absence Reason'
        ELSE AbsenceReason
    END AS AbsenceReason,
	AbsenceReasonCategory, 
	AbsenceTerm, 
	TotalTimeLost, 
	TotalDaysLost, 
	MATB1IssueDate, 
	MPPEndDate, 
	MPPStartDate, 
	EarliestMATB1Date, 
	EarliestMPPStartDate, 
	ExpectedBirthDate, 
	ExpectedWeekofBirth, 
	QualifyingWeekCommences
INTO #tempDimAbsence1
FROM [staging].[mhr_dimabsence] st;

SELECT 
	tda.*,
	--ApplyMap('IncorrectAbsenceMap',AbsenceKey,0)as AbsenceConsecutive_Flag,
    CASE 
        WHEN LEN(ti.IncorrectAbsence_Flag) < 1 THEN 0
        ELSE 1
    END AS AbsenceConsecutive_Flag
INTO #tempDimAbsence2
FROM #tempDimAbsence1 tda
LEFT JOIN #tempIncorrectAbsenceMap ti ON tda.AbsenceKey = ti.AbsenceKey
;

SELECT Distinct
	fa.*,
	ta.AbsenceType as AbsenceTypeMap,
	tar.AbsenceReason as AbsenceReasonMap
INTO #tempFactAbsenceDaily
FROM Fact_AbsenceDaily fa
LEFT JOIN #TempAbsenceTypeMap ta ON ta.AbsenceKey = fa.AbsenceKey
LEFT JOIN #TempAbsenceReasonMap tar ON tar.AbsenceKey = fa.AbsenceKey
;

/**************
AbsencesCount
***************/

SELECT
    Distinct
	AbsenceKey,
	PersonIdTemp as PersonId,
	MIN(CAST(IndexDate AS DATE)) AS AbsenceStartDate
INTO #TempAbsenceTriggersLoad1_Date
FROM #tempFactAbsenceDaily
WHERE
	AbsenceTypeMap = 'Company Sick Pay' 
	AND AbsenceReasonMap NOT IN ('Pregnancy Related Sickness', 'Covid-19', 'Cancer', 'Bereavement')
	AND TempAbsenceConsecutive_Flag ='0'  
	AND IndexDate >= '2019-04-01' AND IndexDate <= '2021-03-31'
GROUP BY AbsenceKey, PersonIdTemp;


SELECT
	Distinct 
	PersonId,
	CONVERT(DATE, AbsenceStartDate) AS AbsenceStartDate
INTO #TempAbsenceTriggersLoad2_Date
FROM #TempAbsenceTriggersLoad1_Date;

--the following will create full outer join to allow determination of which dates are within 01/04/19 and 31/03/21
SELECT Distinct
	PersonId,
	AbsenceStartDate
INTO #tmpAbsenceTriggers_Date
FROM #TempAbsenceTriggersLoad2_Date;

SELECT Distinct
    t1.PersonId,
    t1.AbsenceStartDate,
    t2.AbsenceStartDate AS Date
INTO #tmpAbsenceTriggers_Date2
FROM #tmpAbsenceTriggers_Date t1
INNER JOIN #tmpAbsenceTriggers_Date t2 ON t1.PersonId = t2.PersonId;

-- //this filters out dates between 01/04/19 and 31/03/21
SELECT Distinct
	PersonId,
	AbsenceStartDate,
	Date
INTO #tmpnewAbsenceTriggers_Date
FROM #tmpAbsenceTriggers_Date2
where Date<=AbsenceStartDate;

--this aggregates the dates and gets the count
SELECT Distinct
	PersonId,
	AbsenceStartDate,
	count(Date) as AbsencesCount
INTO #tempaggrAbsenceTriggers_Date
FROM #tmpnewAbsenceTriggers_Date
group by PersonId,AbsenceStartDate;

--add it back to the original data
SELECT Distinct
	tda.*,
	tmp.AbsencesCount
INTO #TempAbsenceTriggersLoad1_Date2
FROM #TempAbsenceTriggersLoad1_Date tda
LEFT JOIN #tempaggrAbsenceTriggers_Date tmp ON tda.PersonId = tmp.PersonId
;

-- Aggregating #TempAbsenceTriggersLoad1_Date2 to ensure one row per AbsenceKey
SELECT 
    Distinct
    AbsenceKey,
    COUNT(*) AS AbsencesCount
INTO #TempAbsenceTriggersAggregated
FROM #TempAbsenceTriggersLoad1_Date2
GROUP BY AbsenceKey;

-- Joining the aggregated table with #tempDimAbsence2
SELECT 
    DISTINCT
    tda.*,
    COALESCE(tmp.AbsencesCount, 0) AS AbsencesCount  -- Use COALESCE to handle NULLs
INTO #tempDimAbsence3
FROM #tempDimAbsence2 tda
LEFT JOIN #TempAbsenceTriggersAggregated tmp ON tda.AbsenceKey = tmp.AbsenceKey;

/**************
Absenceswithin12months
***************/

SELECT
    Distinct
	AbsenceKey,
	PersonIdTemp as PersonId,
	MIN(CAST(IndexDate AS DATE)) AS AbsenceStartDate
INTO #TempAbsenceTriggersLoad1
FROM #tempFactAbsenceDaily
WHERE
	AbsenceTypeMap = 'Company Sick Pay' 
	AND AbsenceReasonMap NOT IN ('Pregnancy Related Sickness', 'Covid-19', 'Cancer', 'Bereavement')
	AND TempAbsenceConsecutive_Flag ='0'  
GROUP BY AbsenceKey, PersonIdTemp;

SELECT
	Distinct 
	PersonId,
	CAST(AbsenceStartDate AS DATE) as AbsenceStartDate
INTO #TempAbsenceTriggersLoad2
FROM #TempAbsenceTriggersLoad1;

--the following will create full outer join to allow determination of which dates are within 1 year
SELECT 
    Distinct
	PersonId,
	AbsenceStartDate
INTO #TemptmpAbsenceTriggers
FROM #TempAbsenceTriggersLoad2;

-- Create #TemptmpAbsenceTriggers1 table and inner join with #TemptmpAbsenceTriggers
SELECT 
    Distinct
    t1.PersonId,
    t1.AbsenceStartDate,
    t2.AbsenceStartDate as Date
INTO #TemptmpAbsenceTriggers1
FROM #TemptmpAbsenceTriggers t1
INNER JOIN #TemptmpAbsenceTriggers t2 ON t1.PersonId = t2.PersonId AND t1.AbsenceStartDate = t2.AbsenceStartDate;

--this filters out dates outside of 1 year
SELECT 
    Distinct
    PersonId,
    AbsenceStartDate,
    Date
INTO #TempnewAbsenceTriggers
FROM #TemptmpAbsenceTriggers1
WHERE Date <= AbsenceStartDate AND Date >= DATEADD(YEAR, -1, AbsenceStartDate);

--this aggregates the dates and gets the count
SELECT 
    Distinct
    PersonId,
    AbsenceStartDate,
    count(Date) as Absenceswithin12months
INTO #TempaggrAbsenceTriggers
FROM #TempnewAbsenceTriggers
Group By PersonId, AbsenceStartDate;

--add it back to the original data
SELECT Distinct
    t1.AbsenceKey,
    t1.PersonId,
    t1.AbsenceStartDate,
    t2.Absenceswithin12months
INTO #TempJoinedAbsenceTriggers
FROM #TempAbsenceTriggersLoad1 t1
INNER JOIN #TempaggrAbsenceTriggers t2
ON t1.PersonId = t2.PersonId AND t1.AbsenceStartDate = t2.AbsenceStartDate;

--Join Absence Triggers on to Main Absence Table
SELECT Distinct
    tda.*,
    tjat.Absenceswithin12months
INTO #tempDimAbsence4
FROM #tempDimAbsence3 tda
LEFT JOIN #TempJoinedAbsenceTriggers tjat ON tda.AbsenceKey = tjat.AbsenceKey;

/**************
Absenceswithin6months
***************/

SELECT
    Distinct
	AbsenceKey,
	PersonIdTemp as PersonId,
	MIN(CAST(IndexDate AS DATE)) AS AbsenceStartDate
INTO #TempAbsenceTriggersLoad1_6M
FROM #tempFactAbsenceDaily
WHERE
	AbsenceTypeMap = 'Company Sick Pay' 
	AND AbsenceReasonMap NOT IN ('Pregnancy Related Sickness', 'Covid-19', 'Cancer', 'Bereavement')
	AND TempAbsenceConsecutive_Flag ='0'  
GROUP BY AbsenceKey, PersonIdTemp;

SELECT
	Distinct 
	PersonId,
	CAST(AbsenceStartDate AS DATE) as AbsenceStartDate
INTO #TempAbsenceTriggersLoad2_6M
FROM #TempAbsenceTriggersLoad1_6M;

--the following will create full outer join to allow determination of which dates are within 1 year
SELECT 
    Distinct
	PersonId,
	AbsenceStartDate
INTO #TemptmpAbsenceTriggers_6M
FROM #TempAbsenceTriggersLoad2_6M;

-- Create #TemptmpAbsenceTriggers1 table and inner join with #TemptmpAbsenceTriggers
SELECT 
    Distinct
    t1.PersonId,
    t1.AbsenceStartDate,
    t2.AbsenceStartDate as Date
INTO #TemptmpAbsenceTriggers_6M_1
FROM #TemptmpAbsenceTriggers_6M t1
INNER JOIN #TemptmpAbsenceTriggers_6M t2 ON t1.PersonId = t2.PersonId AND t1.AbsenceStartDate = t2.AbsenceStartDate;

--this filters out dates outside of 6 months
SELECT 
    Distinct
    PersonId,
    AbsenceStartDate,
    Date
INTO #TempnewAbsenceTriggers_6M
FROM #TemptmpAbsenceTriggers_6M_1
WHERE Date <= AbsenceStartDate AND Date >= DATEADD(MONTH, -6, AbsenceStartDate);

--this aggregates the dates and gets the count
SELECT 
    Distinct
    PersonId,
    AbsenceStartDate,
    count(Date) as Absenceswithin6months
INTO #TempaggrAbsenceTriggers_6M
FROM #TempnewAbsenceTriggers_6M
Group By PersonId, AbsenceStartDate;

--add it back to the original data
SELECT Distinct
    t1.AbsenceKey,
    t1.PersonId,
    t1.AbsenceStartDate,
    t2.Absenceswithin6months
INTO #TempJoined6MAbsenceTriggers
FROM #TempAbsenceTriggersLoad1_6M t1
INNER JOIN #TempaggrAbsenceTriggers_6M t2
ON t1.PersonId = t2.PersonId AND t1.AbsenceStartDate = t2.AbsenceStartDate;

--Join Absence Triggers on to Main Absence Table
SELECT Distinct
    tda.*,
    tjat.Absenceswithin6months
INTO #tempDimAbsence5
FROM #tempDimAbsence4 tda
LEFT JOIN #TempJoined6MAbsenceTriggers tjat ON tda.AbsenceKey = tjat.AbsenceKey;

/**************
DimAbsenceFinal
***************/

SELECT Distinct
    tda.*,
    CASE
        WHEN Absenceswithin12months >= 3 THEN 1
        WHEN TotalDaysLost >= 10 THEN 1
        ELSE 0
    END AS DimAbsence12mTrigger3DaysLost10_Flag,

    CASE
        WHEN Absenceswithin12months >= 4 THEN 1
        WHEN TotalDaysLost >= 10 THEN 1
        ELSE 0
    END AS DimAbsence12mTrigger4DaysLost10_Flag,

    CASE
        WHEN Absenceswithin6months >= 3 THEN 1
        WHEN TotalDaysLost >= 5 THEN 1
        ELSE 0
    END AS DimAbsence6mTrigger3DaysLost10_Flag
INTO dwh.Dim_Absence
FROM #tempDimAbsence5 tda;


END;
dwh	BuildDimAddressAttribute	-- =============================================
-- Author:      <Author, , Name>
-- Create Date: <Create Date, , >
-- Description: <Description, , >
-- =============================================
CREATE PROCEDURE [dwh].[BuildDimAddressAttribute]
AS
BEGIN
    -- SET NOCOUNT ON added to prevent extra result sets from
    -- interfering with SELECT statements.
    SET NOCOUNT ON

	TRUNCATE TABLE dwh.Dim_AddressAttribute

    INSERT INTO dwh.Dim_AddressAttribute
    (
		AddressId,
		AddressStreet,
		AddressPostcode,
		AddressBuildingName,
        AddressLocality,
		AddressSubDwelling,
        AddressTown,
        AddressPostCodeDistrict,
        BuildingNumber,
        DependentStreet,
        DoubleLocality,
        NLPGREF
	)
    SELECT 
        [add].AddressId,
        [add].Street AS AddressStreet, 
        [add].Postcode AS AddressPostcode,
        BuildingName AS AddressBuildingName,
        Locality AS AddressLocality,
        SubDwelling AS AddressSubDwelling,
        Town AS AddressTown,
        (SELECT TOP 1 [value] FROM STRING_SPLIT(PostCode, ' ', 1) ORDER BY ordinal) AS AddressPostCodeDistrict,
        BuildingNumber,
        DependentStreet,
        DoubleLocality,
        NLPGREF
    FROM staging.cx_Address [add]



END
dwh	BuildDimADUsers	


-- =============================================
-- Author:      Amit Kakkad
-- Create Date: 03rd June 2024
-- Description: Transforms ADUsers Data
-- =============================================

CREATE PROCEDURE [dwh].[BuildDimADUsers] 
AS
BEGIN

    -- SET NOCOUNT ON added to prevent extra result sets from
    -- interfering with SELECT statements.
    SET NOCOUNT ON

-- Check if the Dim_CX_Calendar table exists
IF OBJECT_ID('dwh.Dim_ADUsers') IS NOT NULL
BEGIN
    DROP TABLE dwh.Dim_ADUsers;
END;

SELECT 
	[displayname] as AD_DisplayName,
	[sn] as AD_Surname,
	[mail] as EmailAddress,
	[givenname] as AD_GivenName,
	[sAMAccountName] as AD_sAMAccountName,
	[userAccountControl] as AD_userAccountControl,
	[distinguishedName] as AD_DistinguishedName,
	[manager] as AD_Manager,
	[title] as AD_Title,
	[telephoneNumber] as AD_telephoneNumber,
	[department] as AD_Department,
	[mobile] as AD_MobileNumber
INTO dwh.Dim_ADUsers
FROM [staging].[mhr_adusers];



END;
dwh	BuildDimAgreement	CREATE PROCEDURE [dwh].[BuildDimAgreement]

AS

TRUNCATE TABLE [dwh].[Dim_Agreement]

-- Insert rows into table 'TableName' in schema '[dbo]'
INSERT INTO [dwh].[Dim_Agreement]
( -- Columns to insert data into
  AgreementId,AgreementCurrentFormer
)
select AgreementId, Live_Flag from staging.[StagingRentAgreement]
dwh	BuildDimApplicant	








-- =============================================
-- Author:      Amit Kakkad
-- Create Date: 23rd May 2024
-- Description: Transforms DimApplicant Data

-- Author:      Amit Kakkad
-- Create Date: 28th June 2024
-- Description: Fix Applicant_EthnicOriginMissing_Flag issue

-- =============================================

CREATE PROCEDURE [dwh].[BuildDimApplicant] 
AS
BEGIN
    -- SET NOCOUNT ON added to prevent extra result sets from
    -- interfering with SELECT statements.
    SET NOCOUNT ON

-- Check if the DimApplicant table exists
IF OBJECT_ID('dwh.Dim_Applicant') IS NOT NULL
BEGIN
    DROP TABLE dwh.Dim_Applicant;
END;


SELECT 
	ApplicantKey, 
	ApplicantID, 
	PersonID as ApplicantPersonId, 
	ApplicantReference, 
	CASE 
		WHEN InternalApplication = 'T' THEN 'Yes' 
		ELSE 'No' 
	END AS DimApplicantInternalApplication,
	LastUpdated, 
	PreferredSalary, 
	PreferredLocation, 
	CurrentSalary, 
	CurrentLocation, 
	NoticePeriod, 
	NoticePeriodTime, 
	CurrentFlag as ApplicantCurrent_Flag,
	1 as DimApplicant_Flag
INTO #TempDim_Applicant
FROM [staging].[mhr_dimapplicant]
;

SELECT 
    da2.ApplicantKey,
    da2.ApplicantID,
    da2.ApplicantPersonId,
    da2.ApplicantReference,
    da2.DimApplicantInternalApplication,
    da2.LastUpdated,
    da2.PreferredSalary,
    da2.PreferredLocation,
    da2.CurrentSalary,
    da2.CurrentLocation,
    da2.NoticePeriod,
    da2.NoticePeriodTime,
    da2.ApplicantCurrent_Flag,
    da2.DimApplicant_Flag,
    CASE 
        WHEN da_joined.ApplicantKey IS NOT NULL THEN 1 
        ELSE 0 
    END AS Applicant_EthnicOriginMissing_Flag
INTO dwh.Dim_Applicant
FROM 
    #TempDim_Applicant da2
LEFT JOIN 
    (
        SELECT DISTINCT 
            da.PersonID, 
            da.ApplicantKey
        FROM 
            (
                SELECT DISTINCT ApplicantPersonID AS PersonID, ApplicantKey
                FROM #TempDim_Applicant
            ) da
        JOIN 
            (
                SELECT DISTINCT ApplicantKey, FactRecruitmentDaily_Flag
                FROM dwh.Fact_RecruitmentDaily
                WHERE FactRecruitmentDaily_Flag = 1
            ) frd
        ON da.ApplicantKey = frd.ApplicantKey
        JOIN 
            (
                SELECT 
                    PersonID, 
                    MAX(EthnicOriginMissing_Flag) AS Max_EthnicOriginMissing_Flag
                FROM 
                    dwh.Dim_Person dp
                GROUP BY 
                    PersonID
                HAVING 
                    MAX(EthnicOriginMissing_Flag) > 0
            ) dp
        ON da.PersonID = dp.PersonID
    ) da_joined
ON da2.ApplicantKey = da_joined.ApplicantKey;

END;
dwh	BuildDimAsset	

CREATE PROCEDURE [dwh].[BuildDimAsset]
AS

    SET NOCOUNT ON

	TRUNCATE TABLE [dwh].[Dim_Asset]

    DECLARE @MaxDHJobId NVARCHAR(12) = (SELECT MAX(JobID) AS JobID FROM staging.Keystone_MIView_DHResult_Asset)

    DROP TABLE IF EXISTS #CurrentAgreementTenureType

    SELECT 
        raa.AssetId, 
        l.[Description]

    INTO 
        #CurrentAgreementTenureType

    FROM 
        staging.cx_RentAgreementEpisode rae

        LEFT JOIN staging.cx_rentagreementasset raa
        ON rae.AgreementId = raa.AgreementId

        LEFT JOIN staging.cx_RentAgreementTenureType ratt
        ON rae.AgreementTenureTypeId = ratt.AgreementTenureTypeID

        LEFT JOIN staging.cx_lookup l
        ON ratt.TenureTypeID = l.LookupReference
        AND LookupTypeId = 37

        WHERE 
        l.DESCRIPTION = 'Assured Shorthold'
        AND (rae.EffectiveToDate IS NULL
            OR (rae.EffectiveToDate >= CAST(GETDATE() AS DATE) AND rae.EffectiveFromDate < CAST(GETDATE() AS DATE)))


    DROP TABLE IF EXISTS #KeyStoneCharacteristicLatestDate

    SELECT
        UPRN,
        MAX(DateUpdated) AS LastUpdatedDate

    INTO
        #KeyStoneCharacteristicLatestDate

    FROM 
        staging.Keystone_AssetCharacteristics

    WHERE 
        Characteristic = 'Wall Construction Type'

    GROUP BY 
        UPRN


    DROP TABLE IF EXISTS #BuildType


    SELECT 
        UPRN, 
        MIN(TraditionalBuildFlag) AS TraditionalBuildFlag

    INTO
        #BuildType

    FROM
        (
            SELECT 
                UPRN,
                CASE --0 = non-traditional, 1 = traditional
                    WHEN AttributeFullDescription = 'boswell' OR AttributeFullDescription LIKE '%concrete%' OR AttributeFullDescription LIKE '%solid%' OR AttributeFullDescription LIKE '%timber%' THEN 0
                    WHEN AttributeFullDescription IS NOT NULL THEN 1
                    ELSE 99
                END AS TraditionalBuildFlag

            FROM 
                staging.keystone_miview_asset_surveyattributes

            WHERE 
                Component ='Wall Structure'

            UNION

            SELECT
                ac.UPRN,
                --Some houses are both traditional and non-traditional. In these instances the house must be marked as non-traditional, which MIN will insure
                CASE --0 = non-traditional, 1 = traditional
                    WHEN ac.Value = 'boswell' OR ac.Value LIKE '%concrete%' OR ac.Value LIKE '%solid%' OR ac.Value LIKE '%timber%' OR ac.Value LIKE '%system%' OR ac.Value LIKE '%system built%' THEN 0
                    WHEN ac.Value IS NOT NULL THEN 1
                    ELSE 99
                END AS TraditionalBuildFlag

            FROM 
                staging.Keystone_AssetCharacteristics ac JOIN #KeyStoneCharacteristicLatestDate lDate
                ON ac.UPRN = lDate.UPRN
                AND ac.DateUpdated = lDate.LastUpdatedDate

            where 
                Characteristic = 'Wall Construction Type'

        ) SurveyData

    GROUP BY UPRN


    DROP TABLE IF EXISTS #DecentHome

    SELECT DISTINCT 
        UPRN, 
        Result 

    INTO 
        #DecentHome

    FROM 
        staging.Keystone_MIView_DHResult_Asset dh

    WHERE dh.JobID = @MaxDHJobId



    --Asset Live Flag

    DROP TABLE IF EXISTS #LiveFlag

    /*;With MaxStatus as (
        select AssetId, Max(StatusId) as MaxStatusId from staging.cx_assetstatus group by AssetId
    )*/
	;
	With MaxStatus as (
        select AssetId, StatusId as MaxStatusId from staging.cx_assetstatus a where CAST(GETDATE() AS DATE) >= a.EffectiveFromDate 
				 AND (a.EffectiveToDate IS NULL OR GETDATE() <= a.EffectiveToDate)
    )
    select Ass.AssetId, stat.statuscode as StatusDescription,  mast.description as MasterStatusDescription,ass.EffectiveFromDate, ass.EffectiveToDate,
    CASE
        WHEN ass.EffectiveToDate is null and stat.statuscode like 'X%' THEN 0
        WHEN CAST(ass.EffectiveFromDate AS DATETIME) <= GETDATE() AND (((CAST(ass.EffectiveToDate AS DATETIME) >= GETDATE())) OR ass.EffectiveToDate is null) THEN 1
        ELSE 0
    END AS Live_Flag

    INTO #LiveFlag   
    
    from staging.cx_asset ass
    left join MaxStatus max on ass.assetid = max.assetid
    left join staging.cx_assetstatus a on max.assetid = a.assetid and max.MaxStatusId = a.StatusId
    left join staging.cx_assetstatuscode stat on a.StatusCodeId = stat.statuscodeid
    left join staging.cx_assetmasterstatuscode mast on stat.masterstatuscodeid = mast.masterstatuscodeid


    --GIS Data

    DROP TABLE IF EXISTS #GIS

    SELECT [gid]
      ,[assetid]
	  ,[assetreference]
      ,lat as GISLat
	  ,long as GISLong
	  ,x as GISX
	  ,y as GISY
	  ,position as GISPositionStatus
	  ,[boundarylocalauthoritygis] as GISLocalAuthority
	  ,[boundaryestatesgis] as GISEstate
	  ,[boundary_relationship_area] as GISRelationshipArea
      ,[boundarywardgis] as GISWard
	  ,[boundaryparlimentaryconstituencygis] as GISConstituency

    INTO 
        #GIS

    FROM 
        staging.gis_pdh_addresses a




	-- Parent Asset Id

	DROP TABLE IF EXISTS #ParentAsset

	;with MaxAssetHierarchyId as 
	(
		SELECT AssetId, MAX([AssetHierarchyId]) as [AssetHierarchyId]
		FROM [staging].[cx_assethierarchydetail]
		WHERE ImmediateParent = 1 and (GETDATE() >= EffectiveFromDate AND (EffectiveToDate IS NULL OR GETDATE() <= EffectiveToDate))
		GROUP BY AssetId 
	)
	SELECT a.[AssetId],
			a.[AssetHierarchyId],
			a.[ParentAssetId],
			a.[ImmediateParent]
	INTO #ParentAsset
	FROM [staging].[cx_assethierarchydetail] a
	LEFT JOIN MaxAssetHierarchyId m on a.[AssetId] = m.[AssetId]
	WHERE m.AssetHierarchyId = a.AssetHierarchyId 
	and a.ImmediateParent = 1 
	and (GETDATE() >= EffectiveFromDate AND (EffectiveToDate IS NULL OR GETDATE() <= EffectiveToDate))

	DROP TABLE IF EXISTS #Sava

	;With CountOfEnergyJobs as 
	(
		SELECT intEnergyJobId,COUNT(intEnergyJobId) as intEnergyJobIdCount FROM staging.keystone_miviewauditenergyjobresult
		GROUP BY intEnergyJobId
	),
	JobId as 
	(
		SELECT MAX(intEnergyJobId) Id
		FROM CountOfEnergyJobs 
		WHERE intEnergyJobIdCount >= 11500 --check for a job survey result of more than 11500 properties, this generally means there has been a full survey done of all PD assets??
	)
	select intAssetId, intEnergyJobId, numSAP, vchSAPBand 
	INTO #Sava
	from staging.keystone_miviewauditenergyjobresult jr
	join JobId on jr.intEnergyJobId = jobid.Id

	/*
	   LEFT JOIN staging.keystone_miviewauditenergyjobresult jr
    ON ma.AssetId = jr.intAssetId
    AND intEnergyJobId = '1508'*/
	
	DROP TABLE IF EXISTS #GasTest;
	DROP TABLE IF EXISTS #ElecTest;


	select AssetId, Min(NextComplianceCheckDate) as NextComplianceCheckDate
	Into #GasTest From dwh.Fact_Compliance 
	where ComplianceType = 'Gas Service' 
	GROUP BY AssetId

	select AssetId, Min(NextComplianceCheckDate) as NextComplianceCheckDate  
	Into #ElecTest From dwh.Fact_Compliance 
	where ComplianceType = 'EICR' 
	GROUP BY AssetId



--    select * from #LiveFlag where AssetId = 8131


    INSERT INTO dwh.Dim_Asset
    (     
    AssetId,
    AddressId,
    AssetReference,
    AssetDescription,
    Category ,
    EffectiveFromDate,
    EffectiveToDate,
    AssetStatus,
    IsLive,
    Management,
	TypeDescription,
    AssetDateOfConstruction,
    AssetConstructionAge,
    BoundaryLocalAuthority,
    AssetCategoryTypeDescriptionDerived,
    AssetNumberOfBedrooms,
    AssetClassificationType,
    AssetKeystoneSAVASAPBand,
    AssetKeystoneNonTraditionalBuild,
    AssetKeystoneDecentHomeStatus,
    IsHome,
    AssetLetable,
    GISLat,
    GISLong,
    GISX,
    GISY,
    GISPositionStatus,
    GISLocalAuthority,
    GISEstate,
    GISRelationshipArea,
    GISWard,
    GISConstituency,
	--[DimAssetId],
	[ParentAssetId],
	[CxAssetId],
	[KeystoneAssetId],
	[UPRN],
	[HMLRTitleNumber],
	[HMLRRestrictions],
	[PropertyUnderCharge],
	[PropertyUnderChargeDetails],
	[Address],
	[AssetType],
	[LocalAuthority],
	[AssetCategoryType],
	[OwnershipType],
	[LeaseStartDate],
	[LeaseTerm],
	[LeaseEndDate],
	[NumberOfBedrooms],
	[EffectiveFrom],
	[EffectiveTo],
	[IsCurrent],
	--[IsLive],
	[EICRServicesNextServiceDate],
	[GasServicesNextServiceDate]
    )


    SELECT DISTINCT
        a.AssetId as AssetId, 
        a.AddressId as AddressId,
        a.AssetReference as AssetReference, 
        a.AssetDescription as AssetDescription, 
        s.Category as Category, 
        --a.CategoryTypeId as CategoryTypeId, 
        a.EffectiveFromDate as EffectiveFromDate, 
        a.EffectiveToDate as EffectiveToDate, 
        lf.StatusDescription as AssetStatus,
        lf.Live_Flag as IsLive,
        -- CASE 
        --         WHEN 
        --             CAST(a.EffectiveFromDate AS DATE) <= GETDATE() AND 
        --             (CAST(a.EffectiveToDate AS DATE) > GETDATE() or a.EffectiveToDate is null)
        --         THEN 1 
        --         ELSE 0 
        --     END AS Live_Flag,
        s.Management as Management,
        --s.Management as TypeDescription, 
		at.Description as TypeDescription,
        a.ConstructionDate AS AssetDateOfConstruction,
        dbo.GetAge(GETDATE(), a.ConstructionDate) AS AssetConstructionAge,
        l3.[Description] AS BoundaryLocalAuthority,
        CASE
            WHEN l.Description = 'General Needs' AND catt.Description = 'Assured Shorthold' THEN 'General Needs AST'
            ELSE l.[Description]
        END AS AssetCategoryTypeDescriptionDerived,
        a.NumberOfBedrooms AS AssetNumberOfBedrooms,
        
		CASE 
			WHEN l2.[Description] = 'None' and at.Description = 'Flat' THEN 'Flat' 
			ELSE l2.[Description] END AS AssetClassificationType, --if the Asset Classifcation is none but the asset type is flat, make it a flat. 
        
		jr.vchSAPBand AS AssetKeystoneSAVASAPBand,
        CASE bt.TraditionalBuildFlag
            WHEN 0 THEN 'Non-Traditional'
            WHEN 1 THEN 'Traditional'
            ELSE 'No Data'
        END AS AssetKeystoneNonTraditionalBuild,
        dh.Result AS AssetKeystoneDecentHomeStatus,
        at.Residential AS IsHome,
        at.Letable AS AssetLetable,
        g.GISLat,
        g.GISLong,
        g.GISX,
        g.GISY,
        g.GISPositionStatus,
        g.GISLocalAuthority,
        g.GISEstate,
        g.GISRelationshipArea,
        g.GISWard,
        g.GISConstituency,
		ahd.[ParentAssetId] as [ParentAssetId],
		--null as ParentAssetId,
		a.assetId as [CxAssetId],
		ka.intAssetID as [KeystoneAssetId],
		--'' as [KeystoneAssetId],
		a.AssetReference as [UPRN],
		null as [HMLRTitleNumber],
		null as [HMLRRestrictions],
		null as [PropertyUnderCharge],
		null as [PropertyUnderChargeDetails],
	 	ad.FormattedAddress as [Address],
		at.Description as [AssetType],
	  	l3.Description as [LocalAuthority],
		l.Description as [AssetCategoryType],
		sl.Description as [OwnershipType],
		null as [LeaseStartDate],
		null as [LeaseTerm],
		null as [LeaseEndDate],
		a.NumberOfBedrooms as [NumberOfBedrooms],
	    a.EffectiveFromDate	as [EffectiveFrom],
		a.EffectiveToDate as [EffectiveTo],
		CASE WHEN CAST(GETDATE() AS DATE) >= a.EffectiveFromDate AND (a.EffectiveToDate IS NULL OR GETDATE() <= a.EffectiveToDate) THEN 1 ELSE 0 END AS IsCurrent,
		--'' as [IsLive],
		electric.NextComplianceCheckDate,
		gas.NextComplianceCheckDate


    FROM [staging].[cx_asset] a

    LEFT JOIN #GIS g 
    on a.AssetReference = g.assetreference

    LEFT JOIN staging.cx_assetsummary_v s 
    on a.AssetId = s.AssetId

    LEFT JOIN staging.cx_lookup l --AssetCategoryType
    ON a.CategoryTypeId = l.LookupReference
    AND l.LookupTypeId = 23

    LEFT JOIN #CurrentAgreementTenureType catt
    ON a.AssetId = catt.AssetId

    LEFT JOIN staging.cx_lookup l2 --AssetClassificationType
    ON a.ClassificationTypeId = l2.LookupReference
    AND l2.LookupTypeId = 22

    LEFT JOIN staging.cx_lookup l3 --LocalAuthority
    ON a.LocalAuthorityId = l3.LookupReference
    AND l3.LookupTypeId = 55

    LEFT JOIN staging.keystone_MIView_Asset ma
    ON a.AssetReference = ma.UPRN

    --LEFT JOIN staging.keystone_miviewauditenergyjobresult jr
	LEFT JOIN #Sava jr
    ON ma.AssetId = jr.intAssetId
    --AND intEnergyJobId = '1508'

    LEFT JOIN #BuildType bt
    ON a.AssetReference = bt.UPRN

    LEFT JOIN #DecentHome dh
    ON a.AssetReference = dh.UPRN

    LEFT JOIN staging.cx_AssetType at
    ON a.AssetTypeId = at.AssetTYpeId

    LEFT JOIN #LiveFlag lf 
    on a.AssetId = lf.AssetId

	--LEFT JOIN staging.[cx_assethierarchydetail] ahd 
	--on a.assetid = ahd.assetid and ahd.ImmediateParent = 1 and ahd.EffectiveToDate is null

	LEFT JOIN #ParentAsset ahd
	on a.assetid = ahd.AssetId

	LEFT JOIN staging.cx_AssetReference ar on a.assetid = ar.AssetId and ar.AssetReferenceTypeId = 3 and (GETDATE() >= ar.EffectiveFromDate AND (ar.EffectiveToDate IS NULL OR GETDATE() <= ar.EffectiveToDate))
	
	LEFT JOIN staging.keystone_tblAsset ka on ar.Reference = ka.vchUPRN 

	LEFT JOIN staging.cx_address ad on a.AddressId = ad.AddressId 

	left join staging.cx_assetownership ao on a.AssetId = ao.AssetId and ao.EffectiveToDate is null left join staging.cx_systemlookup sl on ao.OwnershipCategoryId = sl.LookupReference and sl.LookupTypeId = 75 

	left join #GasTest gas on a.AssetId = gas.AssetId
	left join #ElecTest electric on a.AssetId = electric.AssetId 

    ORDER BY 1

    DROP TABLE #CurrentAgreementTenureType
    DROP TABLE #BuildType
    DROP TABLE #DecentHome
    DROP TABLE #KeyStoneCharacteristicLatestDate
    DROP TABLE #GIS
    
dwh	BuildDimAssetCharacteristic	CREATE PROCEDURE [dwh].[BuildDimAssetCharacteristic]
AS

    SET NOCOUNT ON

    TRUNCATE TABLE dwh.Dim_AssetCharacteristic

    DROP TABLE IF EXISTS #Characteristics;

    SELECT 
        ac.AssetId,
        act.[Description] AS CharacteristicDescription,
        CASE
            WHEN act.LookupTableId = 0 THEN COALESCE(CAST(TextValue AS VARCHAR(100)), CAST(DateValue AS VARCHAR(100)), CAST(IntValue AS VARCHAR(100)), CAST(DecimalValue AS VARCHAR(100)), CAST(BitValue AS VARCHAR(100)))
            ELSE ul.[Description]
        END AS CharacteristicValue

    INTO #Characteristics

    FROM staging.cx_AssetCharacteristic ac LEFT JOIN staging.cx_AssetCharacteristicType act
    ON ac.CharacteristicTypeId = act.AssetCharacteristicTypeId

    LEFT JOIN staging.cx_udflookup ul
    ON act.LookupTableId = LookupTypeId
    AND IntValue  = ul.LookupReference

    WHERE ac.EffectiveToDate IS NULL
    AND ul.EffectiveToDate IS NULL



    INSERT INTO dwh.Dim_AssetCharacteristic
    (
        [AssetId],
        [AssetDateAquired],
        [AssetDateBuilt],
        [AssetPropertyGrant],
        [AssetPropertyDepreciation],
        [AssetSharedOwnershipPercentage],
        [AssetOlderPersonsorDeterminedNeed],
        [AssetRamp],
        [AssetWheelchairAdapted],
        [AssetPetsAllowed],
        [AssetSheltered],
        [AssetLevelAccessShower],
        [AssetSinkingFund],
        [AssetPropertyNBV],
        [AssetPropertyCost],
        [AssetReinstatementcosts],
        [AssetLongitude],
        [AssetLatitude],
        [AssetFloorLevel],
        [AssetPropertySubType],
        [AssetNumberofRooms],
        [AssetGardenType],
        [AssetHeatingType],
        [AssetAffordableRent],
        [AssetT2-Scheme],
        [AssetT3-Neighbourhood],
        [AssetT4-Development],
        [AssetLettingsArea],
        [AssetHousingOfficer],
        [AssetArrearsOfficer],
        [AssetRepairsArea],
        [AssetRepairsOfficer],
        [AssetManagementArea],
        [AssetHistoricLA],
        [AssetYearBuiltRange],
        [AssetManagingAgent],
        [AssetLettingsOfficer],
        [AssetRentReviewCalculation],
        [AssetGasMeterType],
        AssetActualHandoverDate,
        AssetAdditionalWC,
        AssetBathingFacilities,
        AssetBathroomLocation,
        AssetBuildType,
        AssetChiefRent,
        AssetClientGroup,
        AssetCouncilTaxBand,
        AssetDevelopmentScheme,
        AssetEstateCaretaker,
        AssetFireEvacuationStrategy,
        AssetFundingYear,
        AssetGroundRent,
        AssetHardwiredTelecareAlarm,
        AssetIntermediateRentFunding,
        AssetManagementCompany,
        AssetParkingFacilities,
        AssetProductType,
        AssetRefurbishmentDate,
        AssetRepairsAllowanceStartDate,
        AssetS106OrHousingStatementApplicable,
        AssetShelteredScheme,
        AssetSinkingFundOnExit
    )

    SELECT
        p1.AssetId,
        [Date Acquired],
        [Date Built],
        [Property Grant],
        [Property Depreciation],
        [Shared Ownership Percentage],
        [Older Persons or Determined Need],
        [Ramp],
        [Wheelchair Adapted],
        [Pets Allowed],
        [Sheltered],
        [Level Access Shower],
        [Sinking Fund],
        [Property NBV],
        [Property Cost],
        [Reinstatement costs],
        [Longitude],
        [Latitude],
        [Floor Level],
        [Property Sub Type],
        [Number of Rooms],
        [Garden Type],
        [Heating Type],
        [Affordable Rent],
        [T2 - Scheme],
        [T3 - Neighbourhood],
        [T4 - Development ],
        [Lettings Area],
        [Housing Officer],
        [Arrears Officer],
        [Repairs Area],
        [Repairs Officer],
        [Management Area],
        [HistoricLA],
        [Year Built Range],
        [Managing Agent],
        [Lettings Officer],
        [Rent Review Calculation],
        [Gas Meter Type],
        [Acutal Handover Date],
        --Additional fields added. BR 19/06/2025
        [Additional WC],
        [Bathing Facilities],
        [Bathroom Location],
        [Build Type],
        [Chief Rent ],
        [Client Group],
        [Council Tax Band],
        [Development Scheme],
        [Estate Caretaker],
        [Fire Evacuation Strategy],
        [Funding Year],
        [Ground Rent ],
        [Hardwired Telecare Alarm],
        [Intermediate Rent Funding],
        [Management Company],
        [Parking Facilities],
        [ProductType],
        [Refurbishment Date],
        [Repairs Allowance Start Date],
        [S106 or Housing Statement Applicable],
        [ShelteredScheme],
        [Sinking Fund on Exit]

    FROM
        (
            SELECT
                AssetId,
                CharacteristicDescription,
                CharacteristicValue

            FROM 
                #Characteristics

        ) SubQuery

    PIVOT
    (
        MIN(CharacteristicValue) --MIN does nothing as there won't be more than one value. There just has to be an agg function for a pivot to work.
        FOR CharacteristicDescription IN 
        (
            [Date Acquired],
            [Date Built],
            [Property Grant],
            [Property Depreciation],
            [Shared Ownership Percentage],
            [Older Persons or Determined Need],
            [Ramp],
            [Wheelchair Adapted],
            [Pets Allowed],
            [Sheltered],
            [Level Access Shower],
            [Sinking Fund],
            [Property NBV],
            [Property Cost],
            [Reinstatement costs],
            [Longitude],
            [Latitude],
            [Floor Level],
            [Property Sub Type],
            [Number of Rooms],
            [Garden Type],
            [Heating Type],
            [Affordable Rent],
            [T2 - Scheme],
            [T3 - Neighbourhood],
            [T4 - Development ],
            [Lettings Area],
            [Housing Officer],
            [Arrears Officer],
            [Repairs Area],
            [Repairs Officer],
            [Management Area],
            [HistoricLA],
            [Year Built Range],
            [Managing Agent],
            [Lettings Officer],
            [Rent Review Calculation],
            [Gas Meter Type],
            [Acutal Handover Date],
            --Additional fields added. BR 19/06/2025
            [Additional WC],
            [Bathing Facilities],
            [Bathroom Location],
            [Build Type],
            [Chief Rent ],
            [Client Group],
            [Council Tax Band],
            [Development Scheme],
            [Estate Caretaker],
            [Fire Evacuation Strategy],
            [Funding Year],
            [Ground Rent ],
            [Hardwired Telecare Alarm],
            [Intermediate Rent Funding],
            [Management Company],
            [Parking Facilities],
            [ProductType],
            [Refurbishment Date],
            [Repairs Allowance Start Date],
            [S106 or Housing Statement Applicable],
            [ShelteredScheme],
            [Sinking Fund on Exit]
        )
    ) p1
--GO
dwh	BuildDimAssetHMLR	
CREATE PROCEDURE dwh.BuildDimAssetHMLR
AS
BEGIN
    SET NOCOUNT ON;

	TRUNCATE TABLE dwh.Dim_AssetHMLR

    INSERT INTO dwh.Dim_AssetHMLR (
        AssetReference,
        HMLRType,
        TitleNumber,	
        Tenur,	
        Proprietor,	
        Address,
        ChargeNo,
        LeaseInfo,
        RegisteredLeaseDetails,
        LengthOfLease,
        LeaseExpiration,
        DaysRemainingOnLease,
        MonthsRemainingOnLease,	
        YearsRemainingOnLease,	
        Charge,	
        FreeholdOwner,	
        AdditionalInfo
    )
    SELECT 
        h.assetreference,
        'Leasehold' as HMLRType,
        d.Prop_0,	
        d.Prop_1,	
        d.Prop_2,	
        d.Prop_3,
        d.Prop_4,
        d.Prop_5,
        d.Prop_6,
        d.Prop_7,
        d.Prop_8,
        d.Prop_9,
        d.Prop_10,	
        d.Prop_11,	
        d.Prop_13,
        d.Prop_14,	
        d.Prop_15
    FROM staging.gis_pdh_addresses_hmlr h 
    JOIN staging.hmlr_data d 
        ON h.lrleaseholdtitle = d.Prop_0 
    WHERE d.Prop_0 <> 'Title Number'

    UNION ALL

    SELECT 
        h.assetreference,
        'Freehold' as HMLRType,
        d.Prop_0,	
        d.Prop_1,	
        d.Prop_2,	
        d.Prop_3,
        d.Prop_4,
        d.Prop_5,
        d.Prop_6,
        d.Prop_7,
        d.Prop_8,
        d.Prop_9,
        d.Prop_10,	
        d.Prop_11,	
        d.Prop_13,
        d.Prop_14,	
        d.Prop_15
    FROM staging.gis_pdh_addresses_hmlr h 
    JOIN staging.hmlr_data d 
        ON h.lrfreeholdtitle = d.Prop_0 
    WHERE d.Prop_0 <> 'Title Number';
END;
dwh	BuildDimCalendarCX	











-- =============================================
-- Author:      Amit Kakkad
-- Create Date: 13th May 2024
-- Description: Initial Version: Transforms Calendar Data
-- =============================================

-- =============================================
-- Author:      Amit Kakkad
-- Create Date: 10th September 2024
-- Description: Fix issue with YTDPreviousMonth_Flag, YTDPreviousPreviousMonth_Flag, YTDPreviousPreviousPreviousMonth_Flag
-- =============================================

-- =============================================
-- Author:      Amit Kakkad
-- Create Date: 11th September 2024
-- Description: Fix issue with FiscalYearNumeric and FiscalYearNumeric2 for 1st April dates
-- =============================================

CREATE PROCEDURE [dwh].[BuildDimCalendarCX] 
AS
BEGIN
    -- SET NOCOUNT ON added to prevent extra result sets from
    -- interfering with SELECT statements.
    SET NOCOUNT ON

-- Check if the Dim_CX_Calendar table exists
IF OBJECT_ID('dwh.Dim_CX_Calendar') IS NOT NULL
BEGIN
    DROP TABLE dwh.Dim_CX_Calendar;
END;

-- Check if the #temp table exists
IF OBJECT_ID('tempdb..#TempCalendar1') IS NOT NULL
BEGIN
    -- Drop the #temp table
    DROP TABLE #TempCalendar1;
END;

IF OBJECT_ID('tempdb..#TempCalendar2') IS NOT NULL
BEGIN
    -- Drop the #temp table
    DROP TABLE #TempCalendar2;
END;
IF OBJECT_ID('tempdb..#TempCalendar3') IS NOT NULL
BEGIN
    -- Drop the #temp table
    DROP TABLE #TempCalendar3;
END;

IF OBJECT_ID('tempdb..#Temp_BankHolidaysNotableDates') IS NOT NULL
BEGIN
    -- Drop the #temp table
    DROP TABLE #Temp_BankHolidaysNotableDates;
END;
IF OBJECT_ID('tempdb..#Temp_RentCalendar') IS NOT NULL
BEGIN
    -- Drop the #temp table
    DROP TABLE #Temp_RentCalendar;
END;
IF OBJECT_ID('tempdb..#Temp_RentCalendarFiscalYearMap') IS NOT NULL
BEGIN
    -- Drop the #temp table
    DROP TABLE #Temp_RentCalendarFiscalYearMap;
END;
IF OBJECT_ID('tempdb..#Temp_RentCalendarFiscalYearNumericMap') IS NOT NULL
BEGIN
    -- Drop the #temp table
    DROP TABLE #Temp_RentCalendarFiscalYearNumericMap;
END;


DECLARE @vToday DATE = GETDATE();
DECLARE @vYearStartMonth INT = 4;

DECLARE @vCurrentFiscalYearNumeric INT;
DECLARE @vPreviousFiscalYearNumeric INT;
DECLARE @vPreviousPreviousFiscalYearNumeric INT;
DECLARE @vPreviousPreviousPreviousFiscalYearNumeric INT;

-- Adjust for the fiscal year starting from 1st April
SET @vCurrentFiscalYearNumeric = 
    CASE 
        WHEN @vToday >= DATEFROMPARTS(YEAR(@vToday) - 1, @vYearStartMonth, 1) THEN YEAR(@vToday)
        ELSE YEAR(@vToday) - 1
    END;

-- Calculate the previous fiscal year
SET @vPreviousFiscalYearNumeric = @vCurrentFiscalYearNumeric - 1;
SET @vPreviousPreviousFiscalYearNumeric = @vPreviousFiscalYearNumeric - 1;
SET @vPreviousPreviousPreviousFiscalYearNumeric = @vPreviousPreviousFiscalYearNumeric - 1;


-- Displaying the values
--PRINT 'vToday: ' + CAST(@vToday AS VARCHAR(10));
--PRINT 'vCurrentFiscalYearNumeric: ' + CAST(@vCurrentFiscalYearNumeric AS VARCHAR(5));
--PRINT 'vPreviousFiscalYearNumeric: ' + CAST(@vPreviousFiscalYearNumeric AS VARCHAR(5));
--PRINT 'vPreviousPreviousFiscalYearNumeric: ' + CAST(@vPreviousPreviousFiscalYearNumeric AS VARCHAR(5));
--PRINT 'vPreviousPreviousPreviousFiscalYearNumeric: ' + CAST(@vPreviousPreviousPreviousFiscalYearNumeric AS VARCHAR(5));


DECLARE @vMinDate DATE = DATEADD(MONTH, DATEDIFF(MONTH, 0, DATEADD(YEAR, -5, GETDATE())), 0);
--DECLARE @vMaxDate DATE = DATEFROMPARTS(YEAR(GETDATE()) + 2, 3, 31);
DECLARE @vMaxDate DATE = DATEADD(DAY, -1, DATEFROMPARTS(YEAR(GETDATE()) + 2, 4, 1));

-- BankHolidayMap
SELECT CONVERT(VARCHAR(10), [Date], 23) as DayDate
  INTO #Temp_BankHolidaysNotableDates
  FROM [config].[BankHolidaysNotableDates]
Where Lower([Bank Holiday]) ='true';

-- RentCalendar
SELECT
    RCY.[CalenderYearId],
    RCY.[CalendarId],
    RCY.[Year] as RentCalendarFiscalYearNumeric,
    CONCAT(RCY.[Year] - 1, '-', RCY.[Year]) AS RentCalendarFiscalYear,
    RCP.[PeriodNumber],
    CAST(RCP.[PeriodStartDate] AS DATE) AS [PeriodStartDate],
	CAST(RCP.PeriodEndDate AS DATE) AS PeriodEndDate,
    1 as RentCalendarIDCounter
INTO #Temp_RentCalendar
FROM
    [staging].[CX_RentCalendarYear] RCY
LEFT JOIN
    [staging].[CX_RentCalendarPeriod] RCP ON RCY.[CalenderYearId] = RCP.[CalendarYearId];

-- RentCalendarFiscalYearMap
SELECT DISTINCT 
	[PeriodEndDate],
	RentCalendarFiscalYear
INTO #Temp_RentCalendarFiscalYearMap
FROM #Temp_RentCalendar
WHERE [CalendarId]=5;

-- RentCalendarFiscalYearNumericMap
SELECT DISTINCT 
	[PeriodEndDate],
	RentCalendarFiscalYearNumeric
INTO #Temp_RentCalendarFiscalYearNumericMap
FROM #Temp_RentCalendar
WHERE [CalendarId]=5;

-- Rent Calendar Weeks
SELECT
    PeriodNumber as Week,
	[PeriodEndDate] as WeekendDate,
    CASE WHEN [PeriodEndDate] >= DATEADD(DAY, -DATEDIFF(DAY, 0, GETDATE()) % 7, CAST(GETDATE() AS DATE))
              AND [PeriodEndDate] < DATEADD(DAY, 7 - (DATEDIFF(DAY, 0, GETDATE()) % 7), CAST(GETDATE() AS DATE))
         THEN 1
         ELSE 0
    END AS CurrentWeek_Flag,
    CASE WHEN [PeriodEndDate] >= DATEADD(DAY, -DATEDIFF(DAY, 0, GETDATE()) % 7 - 7, CAST(GETDATE() AS DATE))
              AND [PeriodEndDate] < DATEADD(DAY, -DATEDIFF(DAY, 0, GETDATE()) % 7, CAST(GETDATE() AS DATE))
         THEN 1
         ELSE 0
    END AS PreviousWeek_Flag
INTO #Temp_RentWeek
FROM #Temp_RentCalendar
WHERE [CalendarId]=1;

-- Create a Calendar CTE with dates between @vMinDate and @vMaxDate
WITH CalendarCTE AS (
    SELECT @vMinDate AS CalendarDate
    UNION ALL
    SELECT DATEADD(DAY, 1, CalendarDate)
    FROM CalendarCTE
    WHERE DATEADD(DAY, 1, CalendarDate) <= @vMaxDate
)

SELECT 
    CalendarDate as IndexDate,
	--CAST(CAST(CalendarDate AS DATETIME) AS FLOAT) + 2 AS IndexDate, --The +2 ensures the returned value matches Qlik which uses 30/12/1899 as its calendar start. SQL Server uses 01/01/1900.
	DATENAME(WEEKDAY, CalendarDate) AS DayName,
    CASE WHEN CalendarDate <= GETDATE() THEN 1 ELSE 0 END AS CurrentDate_Flag,
    CASE WHEN CalendarDate = CAST(GETDATE() AS DATE) THEN 1 ELSE 0 END AS Today_Flag,
    CASE -- date(floor(weekend(Date))) as WeekendDate,
        WHEN DATEPART(WEEKDAY, CalendarDate) = 1 THEN CalendarDate  -- Check if current date is Sunday
        ELSE DATEADD(DAY, 8 - DATEPART(WEEKDAY, CalendarDate), CAST(CalendarDate AS DATE))  -- Calculate next Sunday
    END AS WeekendDate,
    CASE WHEN DATEPART(WEEKDAY, CalendarDate) IN (1, 7) THEN 1 ELSE 0 END AS Weekend_Flag,
    DATENAME(MONTH, CalendarDate) + ' ' + CAST(YEAR(CalendarDate) AS VARCHAR(4)) AS FiscalMonthName,
    LEFT(FORMAT(CalendarDate, 'MMM'), 3) AS FiscalMonth,
    LEFT(FORMAT(CalendarDate, 'MMM'), 3) AS [Month],
    LEFT(FORMAT(CalendarDate, 'MMM'), 3) + '-' + CAST(YEAR(CalendarDate) AS VARCHAR(4)) AS MonthYear,
    LEFT(FORMAT(CalendarDate, 'MMM'), 3) + '-' + CAST(YEAR(CalendarDate) AS VARCHAR(4)) AS MonthYearNumeric,
    MONTH(DATEADD(MONTH, 9, CalendarDate)) AS FiscalMonthNumeric,
	CASE WHEN MONTH(CalendarDate) < 4
		THEN CAST(YEAR(CalendarDate) - 1 AS VARCHAR(4)) + '-' + CAST(YEAR(CalendarDate) AS VARCHAR(4))
		ELSE CAST(YEAR(CalendarDate) AS VARCHAR(4)) + '-' + CAST(YEAR(CalendarDate) + 1 AS VARCHAR(4))
	END AS FiscalYear2,
	--CAST(RIGHT(CONVERT(VARCHAR(4), YEAR(CalendarDate)), 4) AS INT) AS FiscalYearNumeric2, - calculated further down
	CASE WHEN CAST(CalendarDate AS DATE) = CAST(EOMONTH(DATEADD(MONTH, -1, GETDATE())) AS DATE)
		 THEN 1
		 ELSE 0
	END AS PreviousMonthEnd_Flag,
	DATEDIFF(MONTH, CalendarDate, GETDATE()) AS MonthsAgo,
	CASE WHEN DATEDIFF(MONTH, CalendarDate, GETDATE()) BETWEEN -5 AND 6
		 THEN 1
		 ELSE 0
	END AS SixMonthsBeforeandAfter_Flag,
	CASE WHEN DATEPART(WEEKDAY, CalendarDate) = 2 AND DAY(CalendarDate) <= 7
		 THEN 1
		 ELSE 0
	END AS FirstMonday_Flag,
	--CASE WHEN YEAR(CalendarDate) = YEAR(GETDATE()) AND CalendarDate <= EOMONTH(GETDATE())
	--	 THEN 1
	--	 ELSE 0
	--END AS YTD_Flag,
    CASE 
        WHEN CalendarDate >= DATEFROMPARTS(YEAR(GETDATE()), 1, 1) AND CalendarDate <= GETDATE() THEN 1
        ELSE 0
    END AS YTD_Flag,
	CASE WHEN YEAR(CalendarDate) = YEAR(DATEADD(MONTH, -1, GETDATE())) AND CalendarDate <= EOMONTH(DATEADD(MONTH, -1, GETDATE()))
		 THEN 1
		 ELSE 0
	END AS YTDPreviousMonth_Flag,
	CASE WHEN YEAR(CalendarDate) = YEAR(DATEADD(MONTH, -2, GETDATE())) AND CalendarDate <= EOMONTH(DATEADD(MONTH, -2, GETDATE()))
		 THEN 1
		 ELSE 0
	END AS YTDPreviousPreviousMonth_Flag,
	CASE WHEN YEAR(CalendarDate) = YEAR(DATEADD(MONTH, -3, GETDATE())) AND CalendarDate <= EOMONTH(DATEADD(MONTH, -3, GETDATE()))
		 THEN 1
		 ELSE 0
	END AS YTDPreviousPreviousPreviousMonth_Flag,
	--CASE WHEN YEAR(CalendarDate) = YEAR(DATEADD(YEAR, -1, GETDATE()))
	--	 THEN 1
	--	 ELSE 0
	--END AS PreviousYear_Flag
    CASE 
        WHEN YEAR(CalendarDate) = YEAR(DATEADD(YEAR, -1, GETDATE())) THEN 1
        ELSE 0
    END AS PreviousYear_Flag

INTO #TempCalendar1
FROM CalendarCTE
Order by 1 desc
OPTION (MAXRECURSION 0)
;

-- Create a local temporary table based on the result set of the SELECT statement
SELECT 
	*,
	CASE	-- ApplyMap('BankHolidayMap',date(Date),'0') as BankHoliday_Flag,
	  WHEN EXISTS (SELECT 1 FROM #Temp_BankHolidaysNotableDates WHERE DayDate = IndexDate) THEN 1
	  ELSE 0
	END as BankHoliday_Flag,

	CAST(
	CASE	-- applymap('RentCalendarFiscalYearMap', date(floor(weekend(Date))), null()) as FiscalYear,
	  WHEN EXISTS (SELECT 1 FROM #Temp_RentCalendarFiscalYearMap WHERE [PeriodEndDate] = WeekendDate) THEN (SELECT RentCalendarFiscalYear FROM #Temp_RentCalendarFiscalYearMap WHERE [PeriodEndDate] = WeekendDate)
	  ELSE null
	END AS VARCHAR(10)
	) as FiscalYear,

    CAST(RIGHT(
        CASE
            WHEN EXISTS (SELECT 1 FROM #Temp_RentCalendarFiscalYearMap WHERE [PeriodEndDate] = WeekendDate) 
            THEN (SELECT RentCalendarFiscalYear FROM #Temp_RentCalendarFiscalYearMap WHERE [PeriodEndDate] = WeekendDate)
            ELSE '0000-0000' -- Default value in case FiscalYear is NULL
        END, 4) AS INT) AS FiscalYearNumeric2,

	CASE	-- applymap('RentCalendarFiscalYearNumericMap', date(floor(weekend(Date))), null()) as FiscalYearNumeric,
	  WHEN EXISTS (SELECT 1 FROM #Temp_RentCalendarFiscalYearNumericMap WHERE [PeriodEndDate] = WeekendDate) THEN (SELECT RentCalendarFiscalYearNumeric FROM #Temp_RentCalendarFiscalYearNumericMap WHERE [PeriodEndDate] = WeekendDate)
	  ELSE null
	END as FiscalYearNumeric,

	CASE WHEN MonthsAgo BETWEEN 1 AND 12 THEN 1 ELSE 0 END AS Previous12Months_Flag,
	CASE WHEN MonthsAgo BETWEEN 13 AND 24 THEN 1 ELSE 0 END AS PreviousPrevious12Months_Flag,
	CASE WHEN MonthsAgo BETWEEN 25 AND 36 THEN 1 ELSE 0 END AS PreviousPreviousPrevious12Months_Flag,
	CASE WHEN MonthsAgo BETWEEN 2 AND 13 THEN 1 ELSE 0 END AS Previous12MonthsOffset1Month_Flag,
	CASE WHEN MonthsAgo BETWEEN 1 AND 24 THEN 1 ELSE 0 END AS Previous24Months_Flag,
	CASE
		WHEN MonthsAgo IN (1, 13, 25) THEN 1
		WHEN MonthsAgo IN (2, 14, 26) THEN 2
		WHEN MonthsAgo IN (3, 15, 27) THEN 3
		WHEN MonthsAgo IN (4, 16, 28) THEN 4
		WHEN MonthsAgo IN (5, 17, 29) THEN 5
		WHEN MonthsAgo IN (6, 18, 30) THEN 6
		WHEN MonthsAgo IN (7, 19, 31) THEN 7
		WHEN MonthsAgo IN (8, 20, 32) THEN 8
		WHEN MonthsAgo IN (9, 21, 33) THEN 9
		WHEN MonthsAgo IN (10, 22, 34) THEN 10
		WHEN MonthsAgo IN (11, 23, 35) THEN 11
		WHEN MonthsAgo IN (12, 24, 36) THEN 12
		ELSE 0 -- You can set a default value if needed
	END AS Rolling12MonthsYearonYearComparisonSort,

	CASE WHEN IndexDate = EOMONTH(IndexDate) THEN 1 ELSE 0 END As LastDayInMonth_Flag

INTO #TempCalendar2
FROM #TempCalendar1;

SELECT 
    tc.*,
    CASE
        WHEN DayName NOT IN ('Saturday', 'Sunday') 
             AND BankHoliday_Flag = 0 AND Weekend_Flag = 0
        THEN dwh.fn_GetWorkingDayNumberForMonth(tc.IndexDate)
        ELSE 0
    END AS WorkingDayNumber,
	trw.Week,
	trw.CurrentWeek_Flag,
	trw.PreviousWeek_Flag
INTO #TempCalendar3
FROM #TempCalendar2 tc
LEFT JOIN #Temp_RentWeek trw ON tc.WeekendDate = trw.WeekendDate;

-- Max Week Date
SELECT 
	MAX(IndexDate) as IndexDate,
	MonthYear,
	1 as MaxWeekInMonth_Flag
INTO #TempMaxWeekInMonth_Flag
FROM #TempCalendar3
WHERE DayName = 'Monday'
GROUP BY MonthYear;

SELECT 
    tc.*,
	CASE WHEN tmg.MaxWeekInMonth_Flag = 1 THEN 1 ELSE 0 END as MaxWeekInMonth_Flag
INTO #TempCalendar4
FROM #TempCalendar3 tc
LEFT JOIN #TempMaxWeekInMonth_Flag tmg ON tc.IndexDate = tmg.IndexDate;

-- Min Week Date
SELECT *
INTO #TempMinWeekInMonth_Flag
FROM
	(
	SELECT 
		MIN(IndexDate) as IndexDate,
		MIN(Week) as MinWeek,
		CONVERT(DATE, DATEADD(DAY, DATEDIFF(DAY, '19000101', MIN(IndexDate))/7*7, '19000101') , 112) AS StartOfWeek,
		CONVERT(DATE, DATEADD(DAY, DATEDIFF(DAY, '19000101', MIN(IndexDate))/7*7 + 6, '19000101')  , 112) AS EndOfWeek,
		MonthYear,
		1 as MinWeekInMonth_Flag
	FROM #TempCalendar4
	WHERE DayName in ('Monday')
	GROUP BY MonthYear
	) AS Subquery;

SELECT 
    tc.*,
	CASE WHEN MinWeekInMonth_Flag = 1 THEN 1 ELSE 0 END as MinWeekInMonth_Flag,
	CASE WHEN tc.IndexDate = tmg.StartOfWeek OR tc.IndexDate = tmg.EndOfWeek  THEN 1 ELSE 0 END as MinWeekInMonth_Flag1,
	tmg.StartOfWeek,
	tmg.EndOfWeek,
	tmg.MinWeek
INTO #TempCalendar5
FROM #TempCalendar4 tc
LEFT JOIN #TempMinWeekInMonth_Flag tmg ON tc.IndexDate = tmg.IndexDate;

-- Max Week in Month
SELECT 
  MAX(Week) as MaxWeekInMonth,
  MonthYear
INTO #TempMaxWeekInMonth
FROM #TempCalendar5
Group by MonthYear;

SELECT 
    tc.*,
	twm.MaxWeekInMonth as MaxWeekInMonth
INTO #TempCalendar6
FROM #TempCalendar5 tc
LEFT JOIN #TempMaxWeekInMonth twm ON tc.MonthYear = twm.MonthYear;

DECLARE @vCW INT; -- Current Week
DECLARE @vLW1 INT; -- Last Week
DECLARE @vLW5 INT; -- Four Weeks Ago

SELECT @vCW = MAX(Week)
FROM #TempCalendar6
WHERE Today_flag = 1;

SET @vLW1 = @vCW - 1; -- Last Week
SET @vLW5 = @vCW - 5; -- Last Week

-- Last Day In Quarter
SELECT
    MAX(DATEADD(day, -1 * DAY(IndexDate), IndexDate)) AS IndexDate,
    MONTH(IndexDate) AS Month,
    YEAR(IndexDate) AS FiscalYearNumeric2,
    1 AS LastDayInQuarter2_Flag
INTO #TempLastDayInQuarter2
FROM #TempCalendar6
WHERE 1=1
--AND MONTH(IndexDate) IN (3, 6, 9, 12)
AND Month IN('Mar', 'Jun','Sep', 'Dec')
GROUP BY MONTH(IndexDate), YEAR(IndexDate);

SELECT 
    tc.*,
	CASE WHEN twm.LastDayInQuarter2_Flag = 1 THEN 1 ELSE 0 END As LastDayInQuarter2_Flag
INTO #TempCalendar7
FROM #TempCalendar6 tc
LEFT JOIN #TempLastDayInQuarter2 twm ON tc.IndexDate = twm.IndexDate;

SELECT *,
       CONVERT(VARCHAR, Week) + FiscalYear As WeekFiscalYear,
	   FiscalYear + '-' + CONVERT(VARCHAR, Week) as FiscalYearWeek,
	   CASE WHEN	FiscalYearNumeric = @vCurrentFiscalYearNumeric or
					FiscalYearNumeric = @vPreviousFiscalYearNumeric
			THEN 1 ELSE 0 
		END As LastTwoFiscalYears_Flag,
	   CASE WHEN	FiscalYearNumeric = @vCurrentFiscalYearNumeric or
					FiscalYearNumeric = @vPreviousFiscalYearNumeric or
					FiscalYearNumeric = @vPreviousPreviousFiscalYearNumeric
			THEN 1 ELSE 0 
		END As LastThreeFiscalYears_Flag,
	   CASE WHEN	FiscalYearNumeric = @vCurrentFiscalYearNumeric or
					FiscalYearNumeric = @vPreviousFiscalYearNumeric or
					FiscalYearNumeric = @vPreviousPreviousFiscalYearNumeric or
					FiscalYearNumeric = @vPreviousPreviousPreviousFiscalYearNumeric
			THEN 1 ELSE 0 
		END As LastFourFiscalYears_Flag,
	   CASE WHEN	Month = 'Mar' AND
					LastDayInMonth_Flag = 1
			THEN 1 ELSE 0 
	   END As LastDayInFiscalYearNumeric2_Flag,
	   CASE
			WHEN Week <= 13 THEN 'Q1'
			WHEN Week <= 26 THEN 'Q2'
			WHEN Week <= 39 THEN 'Q3'
			ELSE 'Q4'
		END AS Quarter,
    CASE
        WHEN Week <= 13 THEN 'Q1'
        WHEN Week <= 26 THEN 'Q2'
        WHEN Week <= 39 THEN 'Q3'
        ELSE 'Q4'
    END + CAST(FiscalYearNumeric AS VARCHAR(4)) AS QuarterYearId,
    CASE WHEN Week <= @vCW THEN 1 ELSE 0 END AS YTDWeek_Flag,
    CASE WHEN Week <= (@vCW - 4) THEN 1 ELSE 0 END AS YTDWeekLess4_Flag,

	--DATEDIFF(MONTH, '2019-04-01', GETDATE())+1 AS FiscalMonthId,
	DATEDIFF(MONTH, '2019-04-01', IndexDate)+1 AS FiscalMonthId,
	

    DENSE_RANK() OVER (ORDER BY Week, FiscalYear) AS WeekFiscalYearId,
    CASE
        WHEN MONTH IN ('Apr', 'May', 'Jun') THEN 'Q1'
        WHEN MONTH IN ('Jul', 'Aug', 'Sep') THEN 'Q2'
        WHEN MONTH IN ('Oct', 'Nov', 'Dec') THEN 'Q3'
        WHEN MONTH IN ('Jan', 'Feb', 'Mar') THEN 'Q4'
    END AS Quarter2,
    CASE
        WHEN MONTH IN ('Apr', 'May', 'Jun') THEN '1'
        WHEN MONTH IN ('Jul', 'Aug', 'Sep') THEN '2'
        WHEN MONTH IN ('Oct', 'Nov', 'Dec') THEN '3'
        WHEN MONTH IN ('Jan', 'Feb', 'Mar') THEN '4'
    END AS Quarter2Id
INTO #TempCalendar8
FROM #TempCalendar7 tc;

SELECT 
    MAX(IndexDate) AS IndexDate, -- Need to add WeekStart
    QuarterYearId,
	1 as MaxWeekinQuarter
INTO #TempMAXWeekStart
FROM #TempCalendar8
GROUP BY QuarterYearId;

SELECT 
    FiscalYear,
    MAX(Week) AS MaxWeekInYear
INTO #TempMaxWeekInYear
FROM #TempCalendar8
GROUP BY FiscalYear;

SELECT
	tc.*,
	MaxWeekinQuarter,
	MaxWeekInYear
INTO dwh.Dim_CX_Calendar
FROM #TempCalendar8 tc
LEFT JOIN #TempMAXWeekStart tws ON tc.IndexDate = tws.IndexDate
LEFT JOIN #TempMaxWeekInYear tmy ON tc.FiscalYear = tmy.FiscalYear;

Drop Table #TempCalendar1, #TempCalendar2, #TempCalendar3, #TempCalendar4, #TempCalendar5, #TempCalendar6, #TempCalendar7, #Temp_BankHolidaysNotableDates;
Drop Table #Temp_RentWeek, #Temp_RentCalendar, #Temp_RentCalendarFiscalYearMap, #Temp_RentCalendarFiscalYearNumericMap, #TempMaxWeekInMonth_Flag;

--YTDPreviousMonth_Flag, YTDPreviousPreviousMonth_Flag, YTDPreviousPreviousPreviousMonth_Flag should only be set for the current Fiscal Year 
UPDATE dwh.Dim_CX_Calendar
SET 
    YTDPreviousMonth_Flag = 0,
    YTDPreviousPreviousMonth_Flag = 0,
    YTDPreviousPreviousPreviousMonth_Flag = 0
WHERE 1=1
AND FiscalYearNumeric2 <> (SELECT MAX(FiscalYearNumeric2) FROM dwh.Dim_CX_Calendar)
AND (YTDPreviousMonth_Flag = 1
     OR YTDPreviousPreviousMonth_Flag = 1
     OR YTDPreviousPreviousPreviousMonth_Flag = 1);

-- There is no SQL equivalent for the Qlik "num(right(yearname(Date,0, 4),4)) as FiscalYearNumeric2"
-- So, for 1st April dates, increment FiscalYearNumeric and FiscalYearNumeric2 by 1
UPDATE dwh.Dim_CX_Calendar
SET FiscalYearNumeric2 = FiscalYearNumeric2 + 1,
    FiscalYearNumeric = FiscalYearNumeric + 1
WHERE IndexDate LIKE '%-04-01';

END;
dwh	BuildDimCalendarPeriod	
-- =============================================
-- Author:      Ben Reeve
-- Create Date: 05/03/2025
-- Description: Builds calendar period dimension table
-- =============================================
CREATE PROCEDURE [dwh].[BuildDimCalendarPeriod]
AS
BEGIN
    -- SET NOCOUNT ON added to prevent extra result sets from
    -- interfering with SELECT statements.
    SET NOCOUNT ON

    TRUNCATE TABLE dwh.Dim_CalendarPeriod;

	INSERT INTO dwh.Dim_CalendarPeriod
	(
		DimCalendarPeriodId,
		CalendarPeriodId,
		Description,
		Year,
		PeriodNumber,
		PeriodStartDate,
		PeriodEndDate
	)


	SELECT 
		ROW_NUMBER() OVER (ORDER BY Year, Description, PeriodNumber) AS DimCalendarPeriodId,
		rcp.CalendarPeriodId,
		rc.Description,
		rcy.Year,
		rcp.PeriodNumber,
		rcp.PeriodStartDate,
		rcp.PeriodEndDate

	
	FROM 
		staging.cx_rentcalendarperiod rcp 
	
		JOIN staging.cx_rentcalendaryear rcy
		ON rcp.CalendarYearId = rcy.CalenderYearId

		JOIN staging.cx_rentcalendar rc
		ON rcy.CalendarId = rc.CalendarId

	ORDER BY 
		Year, 
		Description, 
		PeriodNumber
END
dwh	BuildDimCase	-- =============================================
-- Author:      Carl Hunter
-- Create Date: <Create Date, , >
-- Description: <Description, , >
-- =============================================
CREATE PROCEDURE [dwh].[BuildDimCase]
AS
BEGIN
    -- SET NOCOUNT ON added to prevent extra result sets from
    -- interfering with SELECT statements.
    SET NOCOUNT ON

	TRUNCATE TABLE dwh.Dim_Case

    DROP TABLE IF EXISTS #DisrepairResp 

    select ct.caseid, udf.description as DisrepairLiableFlag 
    into #DisrepairResp
    from staging.cx_systemcasetask ct 
    join staging.cx_SystemCaseTaskInformationFieldResponse liable on ct.taskid = liable.taskid and TaskDefinitionInformationFieldId = 332
    join staging.cx_udflookup udf on udf.lookupreference = liable.LookupIdResponse and udf.lookuptypeid = 22


	INSERT INTO dwh.Dim_Case
	(
		CaseId,
		CaseType,
		CaseGenericType,
		CaseGenericCategoryType,
        CaseCreatedBy,
		CaseStatus,
		CaseCreatedDate,
		CaseStartDate,
		CaseEndDate,
        IsDisrepairResponsible,
        CaseEntityType,
        CaseEntityId,
        CaseContactId,
        ContactId,
        AddressId,
        AssetId,
        ContractGroupId,
        CRMCaseId,
        EstateId,
        FeedbackCaseId,
        CxAccountId,
        CxAgreementId,
		CxAssetId
	)
	
	SELECT
		sc.CaseId,
		--OrderReference,
		CaseType.[Description] AS CaseType,
		--gct.Description AS CaseGenericType,
        s.[Description] AS CaseGenericType,
		--l.[Description] AS CaseGenericCategoryType,
        SubjectType.[Description] AS CaseGenericCategoryType,
        u.fullname as CreatedBy,
		--CaseOutcome,
		CaseStatus.[Description] AS CaseStatus,
		CAST(sc.CreatedDate AS DATE) AS CaseCreatedDate,
		CAST(sc.ActualStartDate AS DATE) AS CaseStartDate,
		CAST(sc.ActualEndDate AS DATE) AS CaseEndDate,
        r.DisrepairLiableFlag AS IsDisrepairResponsible,
        --sc.EntityId,
        EntityType.[Description] as EntityType,
        sc.EntityId as CaseEntity,
        CaseContact.ContactId as CaseContactId,
        CASE WHEN EntityType.[Description] = 'Contact' THEN sc.EntityId else null end as ContactId,
        CASE WHEN EntityType.[Description] = 'Address' THEN sc.EntityId else null end as AddressId,
        CASE WHEN EntityType.[Description] = 'Asset' THEN sc.EntityId else null end as AssetId,
        CASE WHEN EntityType.[Description] = 'Contract Group' THEN sc.EntityId else null end as ContractGroupId,
        CASE WHEN EntityType.[Description] = 'CRM Case' THEN sc.EntityId else null end as CRMCaseId,
        CASE WHEN EntityType.[Description] = 'Estate' THEN sc.EntityId else null end as EstateId,
        CASE WHEN EntityType.[Description] = 'Feedback Case' THEN sc.EntityId else null end as FeedbackCaseId,
        CASE WHEN EntityType.[Description] = 'Rent Account' THEN sc.EntityId else null end as RentAccountId,
        CASE WHEN EntityType.[Description] = 'Rent Agreement' THEN sc.EntityId else null end as RentAgreementId,
		CASE WHEN EntityType.[Description] = 'Asset' THEN sc.EntityId else null end as CxAssetId


	FROM 
		staging.cx_systemcase sc

        left join staging.cx_crmsubject s 
        on sc.CRMSubjectId = s.SubjectId
        
        left join staging.cx_lookup SubjectType 
        on s.CaseTypeId = SubjectType.LookupReference and SubjectType.LookupTypeId = 104
        
        left join staging.cx_securityuser u 
        on u.userid = sc.CreatedBy
        
        left join #DisrepairResp r 
        on sc.CaseId = r.CaseId

		LEFT JOIN staging.cx_SystemLookup CaseType
		ON sc.ClassificationId = CaseType.LookupReference
		AND CaseType.LookupTypeId = 159
    
		LEFT JOIN staging.cx_GenericCaseType gct
		ON sc.GenericCaseTypeId = gct.CaseTypeId

		LEFT JOIN staging.cx_lookup l
		ON gct.CaseCategoryTypeId = l.LookupReference
		AND l.LookupTypeId = 155

		LEFT OUTER JOIN staging.cx_SystemLookup CaseStatus
		ON sc.StatusId = CaseStatus.LookupReference
		AND CaseStatus.LookupTypeId = 137

        LEFT OUTER JOIN staging.cx_SystemLookup EntityType
        ON sc.EntityTypeId = EntityType.LookupReference
		AND EntityType.LookupTypeId = 24

        LEFT JOIN staging.cx_systemcasecontact CaseContact 
        ON sc.caseId = CaseContact.caseid 
        and CaseContact.primecontact = 1



    -- If the Various Entity lookups are null (either CaseEntity or COALESCE() the columns), then, set ContactId to be the "prime contact" ContactId from SystemCaseContact for the linked Case
    UPDATE dwh.Dim_Case
    SET ContactId = CaseContactId
    WHERE (CaseEntityId is null or CaseEntityId = 0)
    and CaseContactId is not null

END
dwh	BuildDimComplianceKpiMapping	CREATE PROC [dwh].[BuildDimComplianceKpiMapping]
AS
    TRUNCATE TABLE dwh.Dim_ComplianceKpiMapping;

    WITH KpiMapping
    AS
    (

        SELECT
            c.ComplianceId, --EquipmentTypeId, ServiceType, c.ComplianceType,
            CASE
                WHEN c.ComplianceType = 'Disabled Lifting Equipment' THEN
                    CASE
                        WHEN EquipmentTypeId = 40 THEN 'Clos-o-Mat Toilet Servicing'
                        WHEN c.ServiceType = 'Stairlift/Hoist/Homelift LOLER inspections'
                            AND EquipmentTypeId IN (38, 41,46) THEN 'Hoists LOLER'
                        WHEN c.ServiceType = 'Hoist servicing'
                            AND EquipmentTypeId IN (38, 41,46) THEN 'Hoists Servicing'
                        WHEN c.ServiceType = 'Stairlift/Hoist/Homelift LOLER inspections'
                            AND EquipmentTypeId = 36 THEN 'Stairlifts LOLER'
                        WHEN c.ServiceType = 'Stairlift Servicing'
                            AND EquipmentTypeId = 36 THEN 'Stairlifts Servicing'
                         WHEN EquipmentTypeId = 39 
                            AND c.ServiceType = 'Stairlift/Hoist/Homelift LOLER inspections' THEN 'Through Floor Lift LOLER'

                    END
                WHEN ComplianceType = 'Electrical Safety' AND EquipmentTypeId = 34 THEN 'PAT Testing'
                WHEN ComplianceType = 'Electrical Testing' THEN
                    CASE
                        WHEN EquipmentTypeId = 48 THEN 'Air Conditioning'
                        WHEN EquipmentTypeId = 49 THEN 'Automatic Door Closures'
                        WHEN EquipmentTypeId = 58 THEN 'Electric Gates'
                        WHEN EquipmentTypeId = 55 THEN 'Intruder Alarm'
                        WHEN EquipmentTypeId = 63 THEN 'Lightning Conductors'
                        WHEN EquipmentTypeId IN (64, 66) THEN 'Roller Shutter Doors Servicing'
                        WHEN EquipmentTypeId = 50 THEN 'Fall Arrest System'
                    END
                WHEN ComplianceType = 'Fire Safety' THEN
                    CASE
                        WHEN EquipmentTypeId = 59 THEN 'AOV Inspections'
                        WHEN EquipmentTypeId = 32 THEN 'Dry Riser Inspections'
                        WHEN EquipmentTypeId = 28 THEN 'Emergency Lighting Inspections'
                        WHEN EquipmentTypeId IN (33, 27) THEN 'Fire Alarm Systems Inspections'
                        WHEN EquipmentTypeId = 29 THEN 'Fire Extinguishers Inspections'
                        WHEN ServiceType LIKE 'FRA Level [1,2,3]' THEN 'Fire Safety Compliance'
                    END
                WHEN ComplianceType = 'Water Safety' THEN
                    CASE
                        WHEN EquipmentTypeId = 73 THEN 'CWST inspections'
                        WHEN EquipmentTypeId = 76 AND ServiceType = 'Legionella testing' THEN 'Legionella monthly testing'
                        WHEN EquipmentTypeId = 71 THEN 'Pressurised Cylinder Inspections'
                        WHEN EquipmentTypeId = 60 THEN 'Rainwater Harvesting'
                        WHEN EquipmentTypeId = 74 THEN 'Showerhead Inspections'
                        WHEN EquipmentTypeId = 45 THEN 'TMV Inspections'
                        WHEN EquipmentTypeId = 69 THEN 'Water Boosting Equipment'
                        WHEN EquipmentTypeId = 75 THEN 'Water sampling'
                        WHEN EquipmentTypeId IN (65, 70) THEN 'Septic Tanks/Sewage Pumps'
                    END
                WHEN ComplianceType = 'Lifting Safety'
                    AND ServiceType = 'Passenger Lift Servicing'
                    AND EquipmentTypeId = 35 THEN 'Passenger lift servicing'
                WHEN ComplianceType = 'Play Area' AND EquipmentTypeId = 61 THEN 'Play Area Inspections'
                WHEN ComplianceType = 'Asbestos Reinspection' AND EquipmentTypeId = 83 AND ServiceType = 'Annual inspection/service' THEN 'Asbestos Reinspection'
                WHEN ComplianceType = 'Asbestos Survey' AND EquipmentTypeId = 84 AND ServiceType = 'Asbestos Survey' THEN 'Asbestos Survey'
                WHEN ComplianceType = 'Gas Service' AND ServiceType = 'Annual Gas Service' THEN 'Gas Safety Certificate'
                WHEN ComplianceType = 'Carbon Monoxide Alarm Service' AND EquipmentTypeId = 94 AND ServiceType = 'Carbon Monoxide Alarm' THEN 'Carbon Monoxide Alarm Service'
                WHEN ComplianceType = 'Passenger Lift' AND EquipmentTypeId = 35 AND ServiceType = 'Lift LOLER inspection' THEN 'Passenger Lifts LOLER'
                WHEN ComplianceType = 'Legionella L8' AND ServiceType = 'Legionella L8' THEN 'Legionella L8 Risk Assessment'
                WHEN ComplianceType = 'EICR' AND ServiceType = 'Electrical Periodic Test' THEN 'EICR Certificate'
                ELSE ComplianceType
            END AS Kpi

        FROM
            dwh.Fact_Compliance c 

            LEFT JOIN dwh.Dim_Equipment e
            ON c.EquipmentId = e.EquipmentId

        UNION ALL

        SELECT
            ComplianceId,
            'Fire Alarms Inspections' AS Kpi

        FROM 
            dwh.Fact_Compliance c 

            LEFT JOIN dwh.Dim_Equipment e
            ON c.EquipmentId = e.EquipmentId

        WHERE 
            EquipmentTypeId = 27
    )

    INSERT INTO dwh.Dim_ComplianceKpiMapping
    (
        ComplianceId,
        Kpi
    )

    SELECT 
        ComplianceId,
        Kpi

    FROM
        KpiMapping

    WHERE Kpi IS NOT NULL

    ORDER BY ComplianceId
dwh	BuildDimContact	-- =============================================
-- Author:      Ben Reeve
-- Create Date: 21/05/2025
-- Description: Builds Dim Contact.
--
-- 03/06/2025 - BR - Added join to staging.cxpor_useraccounts and added logic for columns IsPortalUser, LastActive, Disabled and LockedOut.
-- 13/06/2025 - BR - Added CTE for LatestCommDetail to join records based on MAX Effective from date in order to only return 1 active record for each detail category id
-- =============================================
CREATE PROCEDURE [dwh].[BuildDimContact]
AS
BEGIN
    -- SET NOCOUNT ON added to prevent extra result sets from
    -- interfering with SELECT statements.
    SET NOCOUNT ON

	TRUNCATE TABLE dwh.Dim_Contact;

	
	WITH LatestCommDetail
	AS
	(
		SELECT  
			ContactId, 
			CommunicationDetailCategoryId, 
			MAX(EffectiveFromDate) AS MaxEffFrom

		FROM 
			staging.cx_contactcommunicationdetail
		
		WHERE 
			PrimaryCommunication = 1
			AND EffectiveToDate IS NULL
			and ContactId = 2295

		GROUP BY ContactId, 
			CommunicationDetailCategoryId
	),
	ContactComm
	AS
	(
		SELECT DISTINCT 
			ccd.ContactId, 
			ccd.CommunicationDetailCategoryId, 
			ccd.Reference

		FROM 
			staging.cx_contactcommunicationdetail ccd 
			
			JOIN LatestCommDetail lcd
			ON ccd.ContactId = lcd.ContactId
			AND ccd.CommunicationDetailCategoryId = lcd.CommunicationDetailCategoryId
			AND ccd.EffectiveFromDate = lcd.MaxEffFrom		
	)
	,
	ContactTypeDistinct
	AS
	(
		SELECT DISTINCT
			ContactId, 
			Description,
			CASE
				--TypeId = 5 for Former Tenant
				WHEN ct.EffectiveToDate IS NULL AND ct.TypeId = 5 THEN 1 
				ELSE 0
			END AS FormerTenant
		
		FROM 
			staging.cx_contacttype ct

			LEFT JOIN staging.cx_lookup l34
			ON ct.TypeId = l34.LookupReference
			AND l34.LookupTypeId = 34
			AND l34.EffectiveFromDate <= ISNULL(l34.EffectiveToDate, GETDATE())
	),
	ContactTypeAgg
	AS
	(
		SELECT 
			ContactID, 
			STRING_AGG(Description, '; ') WITHIN GROUP (ORDER BY Description ASC) AS ContactTypes,
			SUM(FormerTenant) AS FormerTenant

		FROM
			ContactTypeDistinct

		GROUP BY
			ContactId
	),
	Disabilities
	AS
	(
		SELECT 
		cdis.ContactId, 
		STRING_AGG(l31.[Description], '; ') WITHIN GROUP(ORDER BY l31.Description) AS Disabilities

		FROM 
			staging.cx_contactdisability cdis

			LEFT JOIN staging.cx_lookup l31
			ON cdis.DisabilityId = l31.LookupReference
			AND l31.LookupTypeId = 31

		GROUP BY
			cdis.ContactId
	),
	Alerts
	AS
	(
		SELECT 
			ca.ContactId, 
			STRING_AGG(ca.Comments, '; ') AS Alerts

		FROM 
			staging.cx_contactalert ca

		WHERE 
			AlertId <> 56 --Exclude passwords
			AND EffectiveToDate IS NULL
			AND NULLIF(TRIM(ca.Comments), '') IS NOT NULL

		GROUP BY 
		ca.ContactId
	)

	INSERT INTO dwh.Dim_Contact
	(
		CxContactId,
		DateOfBirth,
		Age,
		NINumber,
		Title,
		Forename,
		Middlename,
		Surname,
		FormattedName,
		MaritalStatus,
		Sex,
		Gender,
		RelatedToStaff,
		Ethnicity,
		Nationality,
		SexualOrientation,
		Religion,
		ContactTypes,
		Disabilities,
		DateofUniversalCreditClaim,
		UCClaimant,
		UCJointClaim,
		UCAssessmentFrom,
		UCAssessmentTo,
		PDVCustomer,
		UCpaymentDate,
		LandlordPlusCustomer,
		DHPAwardedFrom,
		DHPAwardEnd,
		DHPPaymentFrequency,
		DHPAmount,
		TenancySustainability,
		APAappliedfor,
		DateAPAappliedfor,
		Partofthehomelessproject,
		BreathingSpaceThirtyDaysStartDate,
		BreathingSpaceThirtyDaysEndDate,
		BreathingSpaceSixtyDaysStartDate,
		BreathingSpaceSixtyDaysEndDate,
		BreathingSpaceNinetyDaysStartDate,
		BreathingSpaceNinetyDaysEndDate,
		BreathingSpaceInformation,
		UCAPAVulnerabilityTierOne,
		UCAPAVulnerabilityTierTwo,
		UCAbsentJointTenant,
		CustomerrequestedahardcopyofUnityMagazine,
		HousingBand,
		ResidentAssessmentDate,
		SafeguardingInformation,
		PrimaryLandline,
		PrimaryMobile,
		PrimaryEmail,
		Braille,
		LargeFont,
		Alerts,
		IsPortalUser,
		LastActive,
		Disabled,
		LockedOut,
		EffectiveFrom,
		EffectiveTo,
		IsCurrent
	)

	SELECT distinct
		c.ContactId AS CxContactId,
		c.DOB DateOfBirth,
		dbo.GetAge(GETDATE(), DOB) AS Age,
		c.NINumber,
		l48.[Description] AS Title,
		cd.Forename,
		cd.Middlename,
		cd.Surname,
		cd.FormattedName,
		l50.[Description] AS MaritalStatus,
		sl8.[Description] AS Sex,
		l201.[Description] AS Gender,
		cd.RelatedToStaff,
		l6.[Description] AS Ethnicity,
		l7.[Description] AS Nationality,
		l30.[Description] AS SexualOrientation,
		l28.[Description] AS Religion,
		cta.ContactTypes,
		d.Disabilities,
		cu.UCClaimDate AS DateofUniversalCreditClaim,
		cu.UCClaim AS UCClaimant,
		cu.UCJoint AS UCJointClaim,
		cu.UCAssessmentFrom AS UCAssessmentFrom,
		cu.UCAssessmentTo AS UCAssessmentTo,
		cu.PDVCustomerr AS PDVCustomer,
		cu.UCPaymentDate AS UCpaymentDate,
		cu.LandlordPlusCustomers AS LandlordPlusCustomer,
		cu.DHPAwardedFrom AS DHPAwardedFrom,
		cu.DHPAwardEnd AS DHPAwardEnd,
		cu.DHPPaymentFrequency AS DHPPaymentFrequency,
		cu.DHPAwardAmount AS DHPAmount,
		cu.TenancySustainability AS TenancySustainability,
		cu.APAAppliedFor AS APAappliedfor,
		cu.DateAPAappliedfor AS DateAPAappliedfor,
		cu.PartOfTheHomelessProject AS Partofthehomelessproject,
		cu.BreathingSpaceThirtyDaysStartDate AS BreathingSpaceThirtyDaysStartDate,
		cu.BreathingSpaceThirtyDaysEndDate AS BreathingSpaceThirtyDaysEndDate,
		cu.BreathingSpaceSixtyDaysStartDate AS BreathingSpaceSixtyDaysStartDate,
		cu.BreathingSpaceSixtyDaysEndDate AS BreathingSpaceSixtyDaysEndDate,
		cu.BreathingSpaceNinetyDaysStartDate AS BreathingSpaceNinetyDaysStartDate,
		cu.BreathingSpaceNinetyDaysEndDate AS BreathingSpaceNinetyDaysEndDate,
		cu.BreathingSpaceInformation AS BreathingSpaceInformation,
		cu.UCAPAVulnerabilityTierOne AS UCAPAVulnerabilityTierOne,
		cu.UCAPAVulnerabilityTierTwo AS UCAPAVulnerabilityTierTwo,
		cu.UCAbsentJointTenant AS UCAbsentJointTenant,
		cu.CustomerRequestedHardCopyOfUnityMagazine AS CustomerRequestedAHardCopyOfUnityMagazine,
		cu.HousingBand AS HousingBand,
		cu.ResidentAssessmentDate AS ResidentAssessmentDate,
		NULL AS SafeguardingInformation, -- Can't find this
		ccd1.Reference AS PrimaryLandline,
		ccd2.Reference AS PrimaryMobile,
		ccd3.Reference AS PrimaryEmail,
		CASE 
			WHEN ccn2.ContactId IS NOT NULL THEN 1
			ELSE 0
		END AS Braille,
		CASE
			WHEN ccn1.ContactId IS NOT NULL THEN 1
			ELSE 0
		END AS LargeFont,
		a.Alerts,
		CASE
			WHEN ua.CxContactId IS NOT NULL THEN 1
			ELSE 0
		END AS IsPortalUser,
		ua.LastActive AS LastActive,
		ua.[Disabled] AS Disabled,
		ua.LockedOut AS LockedOut,
		cd.EffectiveFromDate AS EffectiveFrom,
		cd.EffectiveToDate AS EffectiveTo,
		CASE
			WHEN cd.EffectiveFromDate <= GETDATE() AND cd.EffectiveToDate IS NULL AND ISNULL(cta.FormerTenant, 0) = 0 THEN 1
			ELSE 0
		END AS IsCurrent

	FROM 
		staging.cx_contact c

		LEFT JOIN staging.cx_contactdetail cd
		ON c.ContactId = cd.ContactId
		AND cd.EffectiveToDate IS NULL

		LEFT JOIN staging.cx_lookup l48
		ON cd.TitleId = l48.LookupReference
		AND l48.LookupTypeId = 48 --Title
		AND l48.EffectiveFromDate <= ISNULL(l48.EffectiveToDate, GETDATE())

		LEFT JOIN staging.cx_lookup l50
		ON cd.MaritalStatusId = l50.LookupReference
		AND l50.LookupTypeId = 50 --Marital Status
		AND l50.EffectiveFromDate <= ISNULL(l50.EffectiveToDate, GETDATE())

		LEFT JOIN staging.cx_systemlookup sl8
		ON cd.SexId = sl8.LookupReference
		AND sl8.LookupTypeId = 8 --Sex

		LEFT JOIN staging.cx_lookup l201
		ON cd.GenderId = l201.LookupReference
		AND l201.LookupTypeId = 201 --Gender
		AND l201.EffectiveFromDate <= ISNULL(l201.EffectiveToDate, GETDATE())

		LEFT JOIN staging.cx_contactethnicity ce
		ON c.ContactId = ce.ContactId
		AND ce.EffectiveToDate IS NULL

		LEFT JOIN staging.cx_lookup l6
		ON ce.EthnicityId = l6.LookupReference
		AND l6.LookupTypeId = 6 --Ethnicity
		AND l6.EffectiveFromDate <= ISNULL(l6.EffectiveToDate, GETDATE())

		LEFT JOIN staging.cx_lookup l7
		ON ce.NationalityId = l7.LookupReference
		AND l7.LookupTypeId = 7 --Nationality
		AND l7.EffectiveFromDate <= ISNULL(l7.EffectiveToDate, GETDATE())

		LEFT JOIN staging.cx_contactsexualorientation cso
		ON c.ContactId = cso.ContactId
		AND cso.EffectiveToDate IS NULL

		LEFT JOIN staging.cx_lookup l30
		ON cso.OrientationId = l30.LookupReference
		AND l30.LookupTypeId = 30 --Sexual Orientation
		AND l30.EffectiveFromDate <= ISNULL(l30.EffectiveToDate, GETDATE())

		LEFT JOIN staging.cx_contactreligion cr
		ON c.ContactId = cr.ContactId
		AND cr.EffectiveToDate IS NULL

		LEFT JOIN staging.cx_lookup l28
		ON cr.ReligionId = l28.LookupReference
		AND l28.LookupTypeId = 28 --Religion
		AND l28.EffectiveFromDate <= ISNULL(l28.EffectiveToDate, GETDATE())

		LEFT JOIN ContactTypeAgg cta
		ON c.ContactId = cta.ContactId

		LEFT JOIN Disabilities d
		ON c.ContactId = d.ContactId

		LEFT JOIN staging.cx_contact_user cu
		ON c.ContactId = cu.ContactId

		LEFT JOIN ContactComm ccd1
		ON c.ContactId = ccd1.ContactId
		AND ccd1.CommunicationDetailCategoryId = 1 --Main Landline

		LEFT JOIN ContactComm ccd2
		ON c.ContactId = ccd2.ContactId
		AND ccd2.CommunicationDetailCategoryId = 2 --Main Mobile

		LEFT JOIN ContactComm ccd3
		ON c.ContactId = ccd3.ContactId
		AND ccd3.CommunicationDetailCategoryId = 3 --Main Email

		LEFT JOIN staging.cx_contactcommunicationneed ccn1
		ON c.ContactId = ccn1.ContactId
		AND ccn1.CommunicationNeedId = 1 --Large Font
		AND ccn1.EffectiveToDate IS NULL

		LEFT JOIN staging.cx_contactcommunicationneed ccn2
		ON c.ContactId = ccn2.ContactId
		AND ccn2.CommunicationNeedId = 2 --Braille
		AND ccn2.EffectiveToDate IS NULL

		LEFT JOIN Alerts a
		ON c.ContactId = a.ContactId

		LEFT JOIN staging.cxpor_useraccounts ua
		ON c.ContactId = ua.CxContactId

		--Query became extremely slow and started adding nested loops into the query plan which don't work well in this warehouse. The option below forces the query plan
		--to use hash joins, which work much better for this query (< 30 seconds with option or ~10 minutes without)
		OPTION (HASH JOIN)

END
dwh	BuildDimContactAddress	-- =============================================
-- Author:      Ben Reeve
-- Create Date: 21/05/2025
-- Description: Builds Dim Contact Address.
-- =============================================
CREATE PROCEDURE [dwh].[BuildDimContactAddress]
AS
BEGIN
    -- SET NOCOUNT ON added to prevent extra result sets from
    -- interfering with SELECT statements.
    SET NOCOUNT ON

	TRUNCATE TABLE dwh.Dim_ContactAddress

	INSERT INTO dwh.Dim_ContactAddress
	(
		DimContactId, 
		AddressType,
		Street,
		Locality,
		Town,
		County,
		PostCode,
		Country
	)

	SELECT DISTINCT 
		dc.DimContactId, 
		l36.[Description] AS AddressType,
		ad.Street,
		ad.Locality,
		ad.Town,
		ad.County,
		ad.PostCode,
		ad.Country

	FROM 
		staging.cx_contactaddress ca 
		
		JOIN staging.cx_address ad
		ON ca.AddressId = ad.AddressId

		JOIN staging.cx_lookup l36
		ON ca.AddressTypeId = l36.LookupReference
		AND l36.LookupTypeId = 36

		JOIN dwh.Dim_Contact dc
		ON ca.ContactId = dc.CxContactId

	WHERE 
		ca.SendPostHere = 1
		AND ca.EffectiveToDate IS NULL

END
dwh	BuildDimContactGroup	

CREATE PROCEDURE [dwh].[BuildDimContactGroup]
AS
BEGIN

    SET NOCOUNT ON

    TRUNCATE TABLE dwh.Dim_ContactGroup

	DROP TABLE IF EXISTS #ContGroup;

	WITH Contact
	AS
	(
		SELECT DISTINCT
			c.ContactId, 
			dbo.GetAge(GETDATE(), c.DOB) AS Age,
			MAX(CASE
				WHEN [Description] NOT LIKE '%former%' THEN 1
				ELSE 0
			END)AS ContactIsCurrent
		
		FROM 
			staging.cx_contact c LEFT JOIN staging.cx_contacttype ct
			ON c.ContactId = ct.ContactId
			AND ct.EffectiveToDate IS NULL

			LEFT JOIN staging.cx_lookup l34
			ON ct.TypeId = l34.LookupReference
			AND l34.LookupTypeId = 34
			AND l34.EffectiveFromDate <= ISNULL(l34.EffectiveToDate, GETDATE())

		GROUP BY 
			c.ContactId, c.DOB
	)



	SELECT 
		cg.ContactGroupId as ContactGroupId, 
		cg.EffectiveFromDate,
		cg.EffectiveToDate,
		--cgm.contactid as contactid, 
		CASE
            WHEN c.ContactIsCurrent = 1 THEN 1
            ELSE 0
        END AS ContactIsCurrent,
        case 
			when cgm.Responsible = 1 AND ContactIsCurrent = 1 THEN 1 
			else 0 
		end as Responsible, 
		case 
			when cgm.Responsible = 1 then 0 
			WHEN c.ContactIsCurrent = 1 THEN 1
            ELSE 0
		end  as NotResponsible,
		--c.DOB, 
		--DATEDIFF(YEAR, c.DOB, GETDATE()) as Age, --DATEDIFF on year doesn't provide an accurate age as it doesn't account for the day / month of the year
        c.Age,
		case 
			when c.Age < 18 AND c.ContactIsCurrent = 1 THEN 1 
			else 0
		end as  ContactLessThan18,
        --cd.GroupName,
        cgd.GroupName,
        cgd.FormattedResponsibleNames,
		CASE 
			WHEN cg.EffectiveToDate IS NULL OR cg.EffectiveToDate > GETDATE() THEN 1
            ELSE 0
		END as IsCurrent

	INTO #ContGroup 

	from 
        staging.cx_contactgroup cg 
        
        left join staging.cx_ContactGroupMember cgm 
        on cg.ContactGroupId = cgm.ContactGroupId
        
        left join Contact c 
        on cgm.contactid = c.contactid
        
        left join staging.cx_ContactDetail cd 
        on c.contactid = cd.contactid 
        and cd.EffectiveToDate is null
        
        LEFT JOIN staging.cx_contactgroupdetail cgd 
        ON cg.ContactGroupId = cgd.ContactGroupId 
        AND cgd.EffectiveToDate IS NULL


	INSERT INTO [dwh].[Dim_ContactGroup]
           ([CxContactGroupId],
           [NrMembers],
           [NrResponsibleMembers],
           [NrUnder18],
           GroupName,
           FormattedResponsibleNames,
           [EffectiveFrom],
           [EffectiveTo],
           [IsCurrent],
           [IsLatest])



	SELECT 
		ContactGroupId as [CxContactGroupId],
		--Count(*),
		SUM(ContactIsCurrent) AS NrMembers,
		SUM(Responsible) as NrResponsibleMembers,
		SUM(ContactLessThan18) as NrUnder18,
		GroupName,
		FormattedResponsibleNames,
		EffectiveFromDate,
		EffectivetoDate,
		IsCurrent as [IsCurrent],
		IsCurrent as [IsLatest]

	FROM 
		#ContGroup
	Group by 
		ContactGroupId, 
		GroupName, 
		FormattedResponsibleNames, 
		EffectiveFromDate, 
		EffectivetoDate, 
		IsCurrent


	-- DROP TABLE IF EXISTS #ContGroup 

	-- SELECT cg.ContactGroupId as ContactGroupId, 
	-- 	cg.EffectiveFromDate,
	-- 	cg.EffectiveToDate,
	-- 	cgm.contactid as contactid, 
	-- 	case 
	-- 		when cgm.Responsible = 1 then 1 
	-- 		else null 
	-- 	end as Responsible, 
	-- 	case 
	-- 		when cgm.Responsible = 1 then null 
	-- 		else 1 
	-- 	end  as NotResponsible,
	-- 	c.DOB, 
	-- 	DATEDIFF(YEAR, c.DOB, GETDATE()) as Age, 
	-- 	case 
	-- 		when DATEDIFF(YEAR, c.DOB, GETDATE()) < 18 then 1 
	-- 		else null
	-- 	end as  ContactLessThan18,
	-- 	CASE 
	-- 		WHEN cg.EffectiveToDate IS NULL OR cg.EffectiveToDate > GETDATE() THEN 1
    --         ELSE 0
	-- 	END as IsCurrent

	-- INTO #ContGroup 
	-- from staging.cx_contactgroup cg 
	-- left join staging.cx_ContactGroupMember cgm on cg.ContactGroupId = cgm.ContactGroupId
	-- left join staging.cx_contact c on cgm.contactid = c.contactid
	-- left join staging.cx_ContactDetail cd on c.contactid = cd.contactid and cd.EffectiveToDate is null

	-- --select EffectiveFromDate, EffectivetoDate, ContactGroupId, Count(*) as NrMembers, count(Responsible) as NrResponsibleMembers,count(NotResponsible) as NrNotResponsibleMembers, count(ContactLessThan18) as NrUnder18 
	-- --from #ContGroup --where ContactGroupId = 50
	-- --Group by ContactGroupId,EffectiveFromDate, EffectivetoDate order by contactgroupid

	-- INSERT INTO [dwh].[Dim_ContactGroup]
    --        ([CxContactGroupId],
    --        [NrMembers],
    --        [NrResponsibleMembers],
    --        [NrUnder18],
    --        [EffectiveFrom],
    --        [EffectiveTo],
    --        [IsCurrent],
    --        [IsLatest])
    --  SELECT 
	-- 	ContactGroupId as [CxContactGroupId],
	-- 	Count(*),
	-- 	count(Responsible) as NrResponsibleMembers,
	-- 	count(ContactLessThan18) as NrUnder18,
	-- 	EffectiveFromDate,
	-- 	EffectivetoDate,
	-- 	IsCurrent as [IsCurrent],
	-- 	IsCurrent as [IsLatest]
	-- FROM #ContGroup
	-- Group by ContactGroupId,EffectiveFromDate, EffectivetoDate, IsCurrent
		






	--/******************************************************
	--Create #CurrentContactFlags to mark contacts as current
	--******************************************************/
	--DROP TABLE IF EXISTS #CurrentContactFlags

	--SELECT 
	--	c.ContactId, 
	--	CASE
	--		WHEN l.[Description] LIKE '%former%' THEN 0
	--		ELSE 1
	--	END AS ContactCurrentFlag

	--INTO
	--	#CurrentContactFlags

	--FROM 
	--	staging.cx_contact c

	--	LEFT JOIN staging.cx_ContactType ct
	--	ON c.ContactId = ct.ContactId
	--	AND ct.EffectiveToDate IS NULL

	--	LEFT JOIN staging.cx_lookup l
	--	ON ct.TypeId = l.LookupReference
	--	AND LookupTypeId = '34'
	--	AND l.EffectiveToDate IS NULL

	--	WHERE c.EffectiveToDate IS NULL


	--/*************************************************************************************************************************************
	--Create #ContactGroupsWithDisability. If a contact group is in this table, then there is a disability associated with the contact group
	--**************************************************************************************************************************************/
	--DROP TABLE IF EXISTS #ContactGroupsWithDisability

	--SELECT DISTINCT 
	--	cgm.ContactGroupId

	--INTO
	--	#ContactGroupsWithDisability

	--FROM 
	--	staging.cx_ContactDisability cd

	--	JOIN staging.cx_lookup l
	--	ON cd.DisabilityId = l.LookupReference
	--	AND l.LookupTypeId = 31
	--	AND l.EffectiveToDate IS NULL

	--	JOIN staging.cx_contactgroupmember cgm
	--	ON cd.ContactId = cgm.ContactGroupId

	--WHERE
	--	cd.EffectiveToDate IS NULL
	--	AND cgm.EffectiveToDate IS NULL
	--	AND l.description <> 'No Long Term Disability'


	--/************************************************************************************************************************************************
	--Create #ContactGroupProfile. It's easier to create the contact group level information here and join it to back to the contact group head data later
	--************************************************************************************************************************************************/
	--DROP TABLE IF EXISTS #ContactGroupProfile

	--SELECT
	--	cg.ContactGroupId,
	--	SUM
	--	(   CASE
	--			WHEN dbo.GetAge(GETDATE(), DOB) >=18 AND DOB > '19000101' THEN 1
	--			ELSE 0
	--		END) AS ContactGroupProfileNumAdults,
	--	COUNT(c.ContactId) AS ContactGroupProfileNumContacts,
	--	CASE
	--		WHEN cgwd.ContactGroupId IS NULL THEN 'Yes'
	--		ELSE 'No'
	--	END AS ContactGroupProfileDisabledinHousehold

	--INTO
	--	#ContactGroupProfile

	--FROM
	--	staging.cx_contactGroup cg

	--	JOIN staging.cx_ContactGroupMember cgm
	--	ON cg.ContactGroupId = cgm.ContactGroupId

	--	JOIN staging.cx_Contact c
	--	ON cgm.ContactId = c.ContactId

	--	JOIN #CurrentContactFlags ccf
	--	ON c.ContactId = ccf.ContactId

	--	LEFT JOIN #ContactGroupsWithDisability cgwd
	--	ON cg.ContactGroupId = cgwd.ContactGroupId

	--WHERE 
	--	ccf.ContactCurrentFlag = 1
	--	AND cg.EffectiveToDate IS NULL
	--	AND c.EffectiveToDate IS NULL
	--	AND cgm.EffectiveToDate IS NULL

	--GROUP BY
	--	cg.ContactGroupId,
	--	CASE
	--		WHEN cgwd.ContactGroupId IS NULL THEN 'Yes'
	--		ELSE 'No'
	--	END


	--DROP TABLE IF EXISTS #ContactGroupHead

	--SELECT DISTINCT
	--	c.ContactId,
	--	cd.Forename,
	--	cd.Surname,
	--	dbo.GetAge(GETDATE(), c.DOB) AS Age,
	--	nationality.[Description] AS Nationality,
	--	ethnicity.[Description] AS Ethnicity,
	--	sexOr.[Description] AS SexualOrientation,
	--	religion.[Description] AS Religion,
	--	gender.[Description] AS Gender,
	--	sex.[Description] AS Sex,
	--	cgm.ContactGroupId
  
	--INTO
	--	#ContactGroupHead

	--FROM
	--	staging.cx_contact c

	--	JOIN staging.cx_contactgroupmember cgm
	--	ON c.ContactId = cgm.ContactId
	--	AND cgm.EffectiveToDate IS NULL

	--	LEFT JOIN staging.cx_contactdetail cd
	--	ON c.ContactId = cd.ContactId
	--	AND cd.EffectiveToDate IS NULL

	--	LEFT JOIN staging.cx_ContactEthnicity ce
	--	ON c.ContactId = ce.ContactId
	--	AND ce.EffectiveToDate IS NULL

	--	LEFT JOIN staging.cx_lookup nationality
	--	ON ce.NationalityId = nationality.LookupReference
	--	AND nationality.LookupTypeId = 7
	--	AND nationality.EffectiveToDate IS NULL

	--	LEFT JOIN staging.cx_lookup ethnicity
	--	ON ce.EthnicityId = ethnicity.LookupReference
	--	AND ethnicity.LookupTypeId = 6
	--	AND ethnicity.EffectiveToDate IS NULL

	--	LEFT JOIN staging.cx_ContactSexualOrientation cso
	--	ON c.ContactId = cso.ContactId
	--	AND cso.EffectiveToDate IS NULL

	--	LEFT JOIN staging.cx_lookup sexOr
	--	ON cso.OrientationId = sexOr.LookupReference
	--	AND sexOr.LookupTypeId = 30
	--	AND sexOr.EffectiveToDate IS NULL

	--	LEFT JOIN staging.cx_ContactReligion cr
	--	ON c.ContactId = cr.ContactId
	--	AND cr.EffectiveToDate IS NULL

	--	LEFT JOIN staging.cx_lookup religion
	--	ON cr.ReligionId = religion.LookupReference
	--	AND religion.LookupTypeId = 28
	--	AND religion.EffectiveToDate IS NULL

	--	LEFT JOIN staging.cx_lookup gender
	--	ON cd.GenderId = gender.LookupReference
	--	AND gender.LookupTypeId = 201
	--	AND gender.EffectiveToDate IS NULL

	--	LEFT JOIN staging.cx_lookup sex
	--	ON cd.SexId = sex.LookupReference
	--	AND sex.LookupTypeId = 50237
	--	AND sex.EffectiveToDate IS NULL


	--WHERE
	--	cgm.HeadOfGroup = 1
	--	AND cgm.EffectiveToDate IS NULL
	--	AND c.EffectiveToDate IS NULL


	--INSERT INTO dwh.Dim_ContactGroup
	--(
	--	ContactGroupId,
	--	ContactGroupHeadContactId ,
	--	ContactGroupResponsibleNames,
	--	ContactGroupHeadForename,
	--	ContactGroupHeadSurname,
	--	ContactGroupHeadAge,
	--	ContactGroupHeadNationality,
	--	ContactGroupHeadEthnicity,
	--	ContactGroupHeadSexualOrientation,
	--	ContactGroupHeadReligion,
	--	ContactGroupHeadGender,
	--	ContactGroupHeadSex,
	--	ContactGroupHeadAgeBand,
	--	ContactGroupProfileNumAdults,
	--	ContactGroupProfileNumContacts,
	--	ContactGroupProfileDisabledinHousehold
	--)


	--SELECT 
	--	cgh.ContactGroupId,
	--	cgh.ContactId AS ContactGroupHeadContactId,
	--	cgd.FormattedResponsibleNames AS ContactGroupResponsibleNames,
	--	cgh.Forename AS ContactGroupHeadForename,
	--	cgh.Surname AS ContactGroupHeadSurname,
	--	cgh.Age AS ContactGroupHeadAge,
	--	cgh.Nationality AS ContactGroupHeadNationality,
	--	cgh.Ethnicity AS ContactGroupHeadEthnicity,
	--	cgh.SexualOrientation AS ContactGroupHeadSexualOrientation,
	--	cgh.Religion AS ContactGroupHeadReligion,
	--	cgh.Gender AS ContactGroupHeadGender,
	--	cgh.Sex AS ContactGroupHeadSex,
	--	CASE
	--		WHEN Age < 16 THEN '<16'
	--		WHEN Age <= 20 THEN '16-20'
	--		WHEN Age <= 30 THEN '21-30'
	--		WHEN Age <= 40 THEN '31-40'
	--		WHEN Age <= 50 THEN '41-50'
	--		WHEN Age <= 60 THEN '51-60'
	--		WHEN Age <= 70 THEN '61-70'
	--		WHEN Age > 70 THEN '70+'
	--		ELSE 'DOB Missing'
	--	END AS ContactGroupHeadAgeBand,
	--	cgp.ContactGroupProfileNumAdults,
	--	cgp.ContactGroupProfileNumContacts,
	--	cgp.ContactGroupProfileDisabledinHousehold

	--FROM
	--	#ContactGroupHead cgh LEFT JOIN #ContactGroupProfile cgp
	--	ON cgh.ContactGroupId = cgp.ContactGroupId

	--	LEFT JOIN staging.cx_contactgroupdetail cgd
	--	ON cgh.ContactGroupId = cgd.ContactGroupId
	--	AND cgd.EffectiveToDate IS NULL

END
dwh	BuildDimContactGroup_Old	
CREATE PROCEDURE dwh.BuildDimContactGroup
AS
BEGIN

    SET NOCOUNT ON

    TRUNCATE TABLE dwh.Dim_ContactGroup

	/******************************************************
	Create #CurrentContactFlags to mark contacts as current
	******************************************************/
	DROP TABLE IF EXISTS #CurrentContactFlags

	SELECT 
		c.ContactId, 
		CASE
			WHEN l.[Description] LIKE '%former%' THEN 0
			ELSE 1
		END AS ContactCurrentFlag

	INTO
		#CurrentContactFlags

	FROM 
		staging.cx_contact c

		LEFT JOIN staging.cx_ContactType ct
		ON c.ContactId = ct.ContactId
		AND ct.EffectiveToDate IS NULL

		LEFT JOIN staging.cx_lookup l
		ON ct.TypeId = l.LookupReference
		AND LookupTypeId = '34'
		AND l.EffectiveToDate IS NULL

		WHERE c.EffectiveToDate IS NULL


	/*************************************************************************************************************************************
	Create #ContactGroupsWithDisability. If a contact group is in this table, then there is a disability associated with the contact group
	**************************************************************************************************************************************/
	DROP TABLE IF EXISTS #ContactGroupsWithDisability

	SELECT DISTINCT 
		cgm.ContactGroupId

	INTO
		#ContactGroupsWithDisability

	FROM 
		staging.cx_ContactDisability cd

		JOIN staging.cx_lookup l
		ON cd.DisabilityId = l.LookupReference
		AND l.LookupTypeId = 31
		AND l.EffectiveToDate IS NULL

		JOIN staging.cx_contactgroupmember cgm
		ON cd.ContactId = cgm.ContactGroupId

	WHERE
		cd.EffectiveToDate IS NULL
		AND cgm.EffectiveToDate IS NULL
		AND l.description <> 'No Long Term Disability'


	/************************************************************************************************************************************************
	Create #ContactGroupProfile. It's easier to create the contact group level information here and join it to back to the contact group head data later
	************************************************************************************************************************************************/
	DROP TABLE IF EXISTS #ContactGroupProfile

	SELECT
		cg.ContactGroupId,
		SUM
		(   CASE
				WHEN dbo.GetAge(GETDATE(), DOB) >=18 AND DOB > '19000101' THEN 1
				ELSE 0
			END) AS ContactGroupProfileNumAdults,
		COUNT(c.ContactId) AS ContactGroupProfileNumContacts,
		CASE
			WHEN cgwd.ContactGroupId IS NULL THEN 'Yes'
			ELSE 'No'
		END AS ContactGroupProfileDisabledinHousehold

	INTO
		#ContactGroupProfile

	FROM
		staging.cx_contactGroup cg

		JOIN staging.cx_ContactGroupMember cgm
		ON cg.ContactGroupId = cgm.ContactGroupId

		JOIN staging.cx_Contact c
		ON cgm.ContactId = c.ContactId

		JOIN #CurrentContactFlags ccf
		ON c.ContactId = ccf.ContactId

		LEFT JOIN #ContactGroupsWithDisability cgwd
		ON cg.ContactGroupId = cgwd.ContactGroupId

	WHERE 
		ccf.ContactCurrentFlag = 1
		AND cg.EffectiveToDate IS NULL
		AND c.EffectiveToDate IS NULL
		AND cgm.EffectiveToDate IS NULL

	GROUP BY
		cg.ContactGroupId,
		CASE
			WHEN cgwd.ContactGroupId IS NULL THEN 'Yes'
			ELSE 'No'
		END


	DROP TABLE IF EXISTS #ContactGroupHead

	SELECT DISTINCT
		c.ContactId,
		cd.Forename,
		cd.Surname,
		dbo.GetAge(GETDATE(), c.DOB) AS Age,
		nationality.[Description] AS Nationality,
		ethnicity.[Description] AS Ethnicity,
		sexOr.[Description] AS SexualOrientation,
		religion.[Description] AS Religion,
		gender.[Description] AS Gender,
		sex.[Description] AS Sex,
		cgm.ContactGroupId
  
	INTO
		#ContactGroupHead

	FROM
		staging.cx_contact c

		JOIN staging.cx_contactgroupmember cgm
		ON c.ContactId = cgm.ContactId
		AND cgm.EffectiveToDate IS NULL

		LEFT JOIN staging.cx_contactdetail cd
		ON c.ContactId = cd.ContactId
		AND cd.EffectiveToDate IS NULL

		LEFT JOIN staging.cx_ContactEthnicity ce
		ON c.ContactId = ce.ContactId
		AND ce.EffectiveToDate IS NULL

		LEFT JOIN staging.cx_lookup nationality
		ON ce.NationalityId = nationality.LookupReference
		AND nationality.LookupTypeId = 7
		AND nationality.EffectiveToDate IS NULL

		LEFT JOIN staging.cx_lookup ethnicity
		ON ce.EthnicityId = ethnicity.LookupReference
		AND ethnicity.LookupTypeId = 6
		AND ethnicity.EffectiveToDate IS NULL

		LEFT JOIN staging.cx_ContactSexualOrientation cso
		ON c.ContactId = cso.ContactId
		AND cso.EffectiveToDate IS NULL

		LEFT JOIN staging.cx_lookup sexOr
		ON cso.OrientationId = sexOr.LookupReference
		AND sexOr.LookupTypeId = 30
		AND sexOr.EffectiveToDate IS NULL

		LEFT JOIN staging.cx_ContactReligion cr
		ON c.ContactId = cr.ContactId
		AND cr.EffectiveToDate IS NULL

		LEFT JOIN staging.cx_lookup religion
		ON cr.ReligionId = religion.LookupReference
		AND religion.LookupTypeId = 28
		AND religion.EffectiveToDate IS NULL

		LEFT JOIN staging.cx_lookup gender
		ON cd.GenderId = gender.LookupReference
		AND gender.LookupTypeId = 201
		AND gender.EffectiveToDate IS NULL

		LEFT JOIN staging.cx_lookup sex
		ON cd.SexId = sex.LookupReference
		AND sex.LookupTypeId = 50237
		AND sex.EffectiveToDate IS NULL


	WHERE
		cgm.HeadOfGroup = 1
		AND cgm.EffectiveToDate IS NULL
		AND c.EffectiveToDate IS NULL


	INSERT INTO dwh.Dim_ContactGroup
	(
		ContactGroupId,
		ContactGroupHeadContactId ,
		ContactGroupResponsibleNames,
		ContactGroupHeadForename,
		ContactGroupHeadSurname,
		ContactGroupHeadAge,
		ContactGroupHeadNationality,
		ContactGroupHeadEthnicity,
		ContactGroupHeadSexualOrientation,
		ContactGroupHeadReligion,
		ContactGroupHeadGender,
		ContactGroupHeadSex,
		ContactGroupHeadAgeBand,
		ContactGroupProfileNumAdults,
		ContactGroupProfileNumContacts,
		ContactGroupProfileDisabledinHousehold
	)


	SELECT 
		cgh.ContactGroupId,
		cgh.ContactId AS ContactGroupHeadContactId,
		cgd.FormattedResponsibleNames AS ContactGroupResponsibleNames,
		cgh.Forename AS ContactGroupHeadForename,
		cgh.Surname AS ContactGroupHeadSurname,
		cgh.Age AS ContactGroupHeadAge,
		cgh.Nationality AS ContactGroupHeadNationality,
		cgh.Ethnicity AS ContactGroupHeadEthnicity,
		cgh.SexualOrientation AS ContactGroupHeadSexualOrientation,
		cgh.Religion AS ContactGroupHeadReligion,
		cgh.Gender AS ContactGroupHeadGender,
		cgh.Sex AS ContactGroupHeadSex,
		CASE
			WHEN Age < 16 THEN '<16'
			WHEN Age <= 20 THEN '16-20'
			WHEN Age <= 30 THEN '21-30'
			WHEN Age <= 40 THEN '31-40'
			WHEN Age <= 50 THEN '41-50'
			WHEN Age <= 60 THEN '51-60'
			WHEN Age <= 70 THEN '61-70'
			WHEN Age > 70 THEN '70+'
			ELSE 'DOB Missing'
		END AS ContactGroupHeadAgeBand,
		cgp.ContactGroupProfileNumAdults,
		cgp.ContactGroupProfileNumContacts,
		cgp.ContactGroupProfileDisabledinHousehold

	FROM
		#ContactGroupHead cgh LEFT JOIN #ContactGroupProfile cgp
		ON cgh.ContactGroupId = cgp.ContactGroupId

		LEFT JOIN staging.cx_contactgroupdetail cgd
		ON cgh.ContactGroupId = cgd.ContactGroupId
		AND cgd.EffectiveToDate IS NULL

END
dwh	BuildDimContactGroupMember	-- =============================================
-- Author:      Ben Reeve
-- Create Date: 02/06/2025
-- Description: Builds Dim_ContactGroupMember
-- =============================================
CREATE PROCEDURE [dwh].[BuildDimContactGroupMember]
AS
BEGIN
    -- SET NOCOUNT ON added to prevent extra result sets from
    -- interfering with SELECT statements.
    SET NOCOUNT ON

	TRUNCATE TABLE dwh.Dim_ContactGroupMember

	INSERT INTO dwh.Dim_ContactGroupMember
	(
		DimContactId,
		DimContactGroupId,
		FromDate,
		ToDate,
		HeadOfGroup,
		Responsible
	)

	SELECT 
		dc.DimContactId,
		dcg.DimContactGroupId,
		cgm.EffectiveFromDate AS FromDate,
		cgm.EffectiveToDate AS ToDate,
		ISNULL(cgm.HeadOfGroup, 0) AS HeadOfGroup,
		ISNULL(cgm.Responsible, 0) AS Responsible

	FROM 
		staging.cx_contactgroupmember cgm

		JOIN dwh.Dim_Contact dc
		ON cgm.ContactId = dc.CxContactId

		JOIN dwh.Dim_ContactGroup dcg
		ON cgm.ContactGroupId = dcg.CxContactGroupId

	WHERE 
		cgm.EffectiveFromDate < ISNULL(cgm.EffectiveToDate, GETDATE())


END
dwh	BuildDimCurrentManagers	







-- =============================================
-- Author:      Amit Kakkad
-- Create Date: 21st May 2024
-- Description: Transforms DimCurrentManagers Data
-- =============================================

CREATE PROCEDURE [dwh].[BuildDimCurrentManagers] 
AS
BEGIN
    -- SET NOCOUNT ON added to prevent extra result sets from
    -- interfering with SELECT statements.
    SET NOCOUNT ON

-- Check if the DimCurrentManagers table exists
IF OBJECT_ID('dwh.Dim_CurrentManagers') IS NOT NULL
BEGIN
    DROP TABLE dwh.Dim_CurrentManagers;
END;

--SELECT Distinct
--	PersonID,
--	PreferredName + ' ' + Surname AS ManagedName
--INTO #tempNameMap
--FROM [staging].[mhr_DimPerson]
--WHERE CurrentFlag ='1' and EmployeeType ='0';

--SELECT Distinct
--	PersonID
--INTO #tempDimCurrentManagers1
--FROM [staging].[mhr_DimPerson]
--WHERE CurrentFlag ='1' and EmployeeType ='0';

--SELECT Distinct
--	MgrPersonID as PersonID,
--	1 as IsManager_Flag,
--	CurrentPersonID
--INTO #tempDimCurrentManagers2
--FROM [staging].[mhr_DimPosition]
--WHERE CurrentFlag =1 and len(MgrPersonID)>=1 and len(CurrentPersonID)>=1
----Order by 1 desc
--;

--SELECT Distinct
--	MgrPersonID as PersonID,
--    CASE
--        WHEN LEN(tn.ManagedName) < 1 OR tn.ManagedName IS NULL THEN 'No Data'
--        ELSE tn.ManagedName
--    END AS ManagedName
--INTO #tempDimCurrentManagers3
--FROM [staging].[mhr_DimPosition] sm
--LEFT JOIN #tempNameMap tn ON tn.PersonID = sm.MgrPersonID
--WHERE CurrentFlag ='1' and len(MgrPersonID)>=1 and len(CurrentPersonID)>=1
--;

--SELECT
--    t1.PersonID,
--    t2.IsManager_Flag  
--INTO #tempDimCurrentManagers4
--FROM #tempDimCurrentManagers2 t2
--RIGHT JOIN #tempDimCurrentManagers1 t1 ON t1.PersonID = t2.PersonID;

--SELECT
--    t3.*,
--    t4.IsManager_Flag  
--INTO dwh.Dim_CurrentManagers
--FROM #tempDimCurrentManagers3 t3
--LEFT JOIN #tempDimCurrentManagers4 t4 ON t3.PersonID = t4.PersonID;

SELECT DISTINCT
    dp.MgrPersonID AS PersonID,
    1 AS IsManager_Flag,
    dp.CurrentPersonID,
    p.PreferredName + ' ' + p.Surname AS ManagedName,
    p.CurrentFlag,
    p.EmployeeType
INTO dwh.Dim_CurrentManagers
FROM
    [staging].[mhr_DimPosition] dp
INNER JOIN
    [staging].[mhr_DimPerson] p
ON
    dp.CurrentPersonID = p.PersonID
WHERE
    dp.CurrentFlag = 1
    AND LEN(dp.MgrPersonID) >= 1
    AND LEN(dp.CurrentPersonID) >= 1
    AND p.CurrentFlag = 1
    AND p.EmployeeType = 0
	;

END;
dwh	BuildDimEquipment	
CREATE PROCEDURE dwh.BuildDimEquipment
AS
BEGIN

    TRUNCATE TABLE dwh.Dim_Equipment

    INSERT INTO dwh.Dim_Equipment
    (
        EquipmentId,
        EquipmentTypeId,
        EquipmentType
    )


    SELECT DISTINCT
        EquipmentID, 
        EquipmentTypeID, 
        EquipmentType

    FROM 
        staging.keystone_miview_ksi_equipment
END
dwh	BuildDimInternalMovers	










-- =============================================
-- Author:      Amit Kakkad
-- Create Date: 24th May 2024
-- Description: Transforms DimInternalMovers Data

-- Author:      Amit Kakkad
-- Create Date: 16th June 2024
-- Description: Fix bugs

-- =============================================

CREATE PROCEDURE [dwh].[BuildDimInternalMovers] 
AS
BEGIN
    -- SET NOCOUNT ON added to prevent extra result sets from
    -- interfering with SELECT statements.
    SET NOCOUNT ON

-- Check if the DimInternalMovers table exists
IF OBJECT_ID('dwh.Dim_InternalMovers') IS NOT NULL
BEGIN
    DROP TABLE dwh.Dim_InternalMovers;
END;


WITH CTE_IndexedData AS (
    SELECT
        fphd.DatePersonKey,
        ISNULL(tpim.PersonID, 'No Data') AS PersonIdTemp,
        ISNULL(tprm.PostReference, 'No Data') AS PostReferenceTemp,
        fphd.IndexDate,
        ISNULL(tptm.Type, 'No Data') AS PositionTypeTemp,
        fphd.PersonKey, 
        ISNULL(tpnm.PostName, 'No Data') AS PostNameTemp,
        ISNULL(tprm.PostReference, 'No Data') AS PostReference,
        LAG(fphd.IndexDate) OVER (PARTITION BY tpim.PersonID ORDER BY fphd.IndexDate) AS PrevIndexDate,
        LAG(ISNULL(tptm.Type, 'No Data')) OVER (PARTITION BY tpim.PersonID ORDER BY fphd.IndexDate) AS PrevType,
        LAG(ISNULL(tpnm.PostName, 'No Data')) OVER (PARTITION BY tpim.PersonID ORDER BY fphd.IndexDate) AS PrevPostName
    FROM dwh.Fact_PersonHeadcountDaily fphd
    LEFT JOIN (
        SELECT DISTINCT
            PersonKey,
            PersonID
        FROM dwh.Dim_Person
    ) tpim ON fphd.PersonKey = tpim.PersonKey
    LEFT JOIN (
        SELECT DISTINCT
            PositionKey,
            PostReference
        FROM dwh.Dim_Position
    ) tprm ON fphd.PositionKey = tprm.PositionKey
    LEFT JOIN (
        SELECT DISTINCT
            PositionKey,
            Type 
        FROM dwh.Dim_Position
    ) tptm ON fphd.PositionKey = tptm.PositionKey
    LEFT JOIN (
        SELECT DISTINCT
            PositionKey,
            PostName
        FROM dwh.Dim_Position
    ) tpnm ON fphd.PositionKey = tpnm.PositionKey
)
SELECT
    DatePersonKey,
    PersonIdTemp,
    PostReferenceTemp,
    IndexDate,
    PositionTypeTemp,
    PersonKey, 
    PostNameTemp,
    PostReference,
    CASE
        WHEN PrevIndexDate IS NOT NULL
             AND DATEDIFF(day, PrevIndexDate, IndexDate) = 1
             AND PrevType <> PositionTypeTemp
        THEN 1
        ELSE 0
    END AS InternalMover_Flag,
    CASE
        WHEN PrevIndexDate IS NOT NULL
             AND DATEDIFF(day, PrevIndexDate, IndexDate) = 1
             AND PrevPostName <> PostNameTemp
        THEN 1
        ELSE 0
    END AS InternalMover_Flag1,
    CASE
        WHEN PrevIndexDate IS NOT NULL
             AND DATEDIFF(day, PrevIndexDate, IndexDate) = 1
             AND PrevType <> PositionTypeTemp
        THEN PrevPostName + ' (' + PrevType + ') --> ' + PostNameTemp
        ELSE NULL
    END AS InternalMoverPostName,
    CASE
        WHEN PrevIndexDate IS NOT NULL
             AND DATEDIFF(day, PrevIndexDate, IndexDate) = 1
             AND PrevPostName <> PostNameTemp
        THEN PrevPostName + ' --> ' + PostNameTemp
        ELSE NULL
    END AS InternalMoverPostName1
INTO #TempInternalMovers1
FROM CTE_IndexedData
WHERE 1=1
--AND (ISNULL(PersonIdTemp, 'No Data') in ('8369733J8I') AND (IndexDate = '2024-05-21' OR IndexDate = '2024-05-22'))
--OR (ISNULL(PersonIdTemp, 'No Data') in ('6976800Fo8') AND (IndexDate = '2024-05-05' OR IndexDate = '2024-05-06'))
ORDER BY 9 DESC, 10 DESC
;

SELECT Distinct
	 [DatePersonKey]
	,[PersonIdTemp]
	,[PostReferenceTemp]
	,[IndexDate]
	,[PositionTypeTemp]
	,[PersonKey]
	,[PostNameTemp]
	,[PostReference]
	,CASE WHEN [InternalMover_Flag] = 1 OR [InternalMover_Flag1] = 1
	    THEN 1
		ELSE 0
     END AS [InternalMover_Flag]
	,CASE WHEN LEN([InternalMoverPostName]) > 1 THEN [InternalMoverPostName]
	      WHEN LEN([InternalMoverPostName1]) > 1 THEN [InternalMoverPostName1]
		  ELSE NULL
     END AS [InternalMoverPostNames]
INTO dwh.Dim_InternalMovers
FROM #TempInternalMovers1;




END;
dwh	BuildDimPerson	


-- =============================================
-- Author:      Amit Kakkad
-- Create Date: 15th May 2024
-- Description: Transforms Person Data
-- =============================================

CREATE PROCEDURE [dwh].[BuildDimPerson] 
AS
BEGIN

    -- SET NOCOUNT ON added to prevent extra result sets from
    -- interfering with SELECT statements.
    SET NOCOUNT ON

-- Check if the Dim_CX_Calendar table exists
IF OBJECT_ID('dwh.Dim_Person') IS NOT NULL
BEGIN
    DROP TABLE dwh.Dim_Person;
END;

-- EmailFixMap
-- Insert data into #Temp_EmailFixMap
CREATE TABLE #Temp_EmailFixMap (
    PersonalReference NVARCHAR(50),
    ActualEmail NVARCHAR(100)
);
INSERT INTO #Temp_EmailFixMap (PersonalReference, ActualEmail) VALUES ('000744', 'andrea.johnson@plusdane.co.uk');
INSERT INTO #Temp_EmailFixMap (PersonalReference, ActualEmail) VALUES ('002645', 'barbara.paxton@plusdane.co.uk');
INSERT INTO #Temp_EmailFixMap (PersonalReference, ActualEmail) VALUES ('002779', 'bernie.greenough@plusdane.co.uk');
INSERT INTO #Temp_EmailFixMap (PersonalReference, ActualEmail) VALUES ('002821', 'chadt@plusdane.co.uk');
INSERT INTO #Temp_EmailFixMap (PersonalReference, ActualEmail) VALUES ('002794', 'darren.knox@plusdane.co.uk');
INSERT INTO #Temp_EmailFixMap (PersonalReference, ActualEmail) VALUES ('002819', 'gillian.healey@plusdane.co.uk');
INSERT INTO #Temp_EmailFixMap (PersonalReference, ActualEmail) VALUES ('002317', 'jonc@plusdane.co.uk');
INSERT INTO #Temp_EmailFixMap (PersonalReference, ActualEmail) VALUES ('002712', 'katherine.wood@plusdane.co.uk');
INSERT INTO #Temp_EmailFixMap (PersonalReference, ActualEmail) VALUES ('001596', 'lai.kinghlaw@plusdane.co.uk');
INSERT INTO #Temp_EmailFixMap (PersonalReference, ActualEmail) VALUES ('002769', 'michelle.birdsall@plusdane.co.uk');
INSERT INTO #Temp_EmailFixMap (PersonalReference, ActualEmail) VALUES ('002820', 'vickym@plusdane.co.uk');
INSERT INTO #Temp_EmailFixMap (PersonalReference, ActualEmail) VALUES ('002381', 'mark.roberts2@plusdane.co.uk');
INSERT INTO #Temp_EmailFixMap (PersonalReference, ActualEmail) VALUES ('001911', 'stephen.mcgowan@plusdane.co.uk');
INSERT INTO #Temp_EmailFixMap (PersonalReference, ActualEmail) VALUES ('002874', 'marie.mcnabb@plusdane.co.uk');
INSERT INTO #Temp_EmailFixMap (PersonalReference, ActualEmail) VALUES ('002787', 'jane.owens@plusdane.co.uk');
--SELECT * FROM #Temp_EmailFixMap;

--CurrentPositionMap
SELECT Distinct 
       CurrentPersonID,
       PositionName
INTO #Temp_CurrentPositionMap
FROM [staging].[mhr_DimPosition]
WHERE CurrentFlag = 1;
--SELECT * FROM #Temp_CurrentPositionMap

SELECT 
    1 as DimPerson_Flag,
    CASE WHEN LeavingDate IS NULL OR LEN(LeavingDate) < 1 THEN 0 ELSE 1 END as DimLeaver_Flag,
    CASE WHEN LeavingDate IS NULL OR LEN(LeavingDate) < 1 THEN 'No' ELSE 'Yes' END as LeaverYesNo,
    CASE WHEN EmailAddress IS NULL OR LEN(EmailAddress) < 1 THEN 'No Data' ELSE LOWER(EmailAddress) END as EmailAddress,
    CASE WHEN EmailAddress IS NULL OR LEN(EmailAddress) < 1 THEN 'No Data' ELSE LOWER(SUBSTRING(EmailAddress, CHARINDEX('@', EmailAddress) + 1, LEN(EmailAddress))) END as EmailAddressDomain,
    CASE WHEN EmailAddress IS NULL OR LEN(EmailAddress) <= 1 THEN 1 ELSE 0 END as EmailAddressMissing_Flag,
    ISNULL(NULLIF(PreferredName, '') + ' ' + Surname, Forename1 + ' ' + Surname) as PreferredFullName,
    PersonKey, 
    PersonID, 
    LeaverID, 
    Title, 
    Surname, 
    Forename1, 
    Forename2, 
    Forename3, 
    FullName, 
    NINumber, 
    NINumberLegislation, 
    EmployeeFullReference, 
    BirthDate, 
    --DATEDIFF(YEAR, BirthDate, GETDATE()) as Age,
	DATEDIFF(YEAR, BirthDate, GETDATE()) - 
		CASE 
			WHEN DATEADD(YEAR, DATEDIFF(YEAR, BirthDate, GETDATE()), BirthDate) > GETDATE() 
			THEN 1 
			ELSE 0 
		END AS Age,
    BirthVerifiedDate, 
    Generation, 
    Status, 
    CASE WHEN MaritalStatus IS NULL OR LEN(MaritalStatus) < 1 THEN 'No Data' ELSE MaritalStatus END as MaritalStatus, 
    PersonDeceasedDate, 
    PersonHonorsQualifications, 
    OrganisationKey, 
    OrganisationID, 
    EmployeeType, 
    SurnameUPC, 
    Forename1UPC, 
    PersonRank, 
    SurnameSDX, 
    Forename1SDX, 
    SelfCertifiedDisability, 
    BackgroundCheckDate, 
    CommitalDate, 
    CASE WHEN Gender IS NULL OR Gender IS NULL THEN 'No Data' ELSE Gender END as Gender, 
    LanguageID, 
    IsGraduate, 
    ContinuousServiceDate, 
    ManualStartDate, 
    RetirementAge, 
    RetirementAgeMonths, 
    CalculatedRetirementDate, 
    RetireDate, 
    RetireDateBasis, 
    PreferredName, 
    PreviousSurname, 
    DFEEReferenceNumber, 
    FastTrack, 
    EthnicCodeID, 
    EthnicOrigin,
    CASE WHEN EthnicOrigin IS NULL OR LEN(EthnicOrigin) < 1 THEN 1 ELSE 0 END as EthnicOriginMissing_Flag, 
    EthnicCode, 
    EthnicGroup, 
    OtherEthnicClassification, 
    BAMECategory, 
    DisabilityID, 
    DisabilityType, 
    DisabilityReason, 
    ConsideredDisabled, 
    CASE WHEN Nationality IS NULL OR LEN(Nationality) < 1 THEN 'No Data' 
         ELSE CASE WHEN Nationality = 'British (not Channel Islands or IOM)' THEN 'British'
                   ELSE Nationality END 
         END as Nationality, 
    SexualOrientationID, 
    SexualOrientation, 
    PreviousNameUPC, 
    PreviousNameSDX, 
    CASE WHEN Religion IS NULL OR LEN(Religion) < 1 THEN 'No Data' ELSE Religion END as Religion, 
    RIGHT('000000' + CAST(PersonalReference AS VARCHAR(6)), 6) AS PersonalReference,
    LeavingDate,
    StartingDate,
	CASE 
		WHEN LeavingDate IS NULL OR LEN(LeavingDate) < 1 THEN DATEDIFF(YEAR, StartingDate, GETDATE())
		WHEN LeavingDate > GETDATE() THEN DATEDIFF(YEAR, StartingDate, GETDATE())
		ELSE DATEDIFF(YEAR, StartingDate, LeavingDate) 
	END AS LengthofService,
    CASE WHEN LeavingDate IS NULL OR LEN(LeavingDate) < 1 THEN DATEDIFF(DAY, StartingDate, GETDATE())
         WHEN LeavingDate > GETDATE() THEN DATEDIFF(DAY, StartingDate, GETDATE())
         ELSE DATEDIFF(DAY, StartingDate, LeavingDate) END as LengthofServiceDays,
    LastWorkDate, 
    Reemployable, 
    NewCompanyName, 
    ExitInterview, 
    LastPayDate, 
    CASE WHEN LeavingReason IS NULL OR LEN(LeavingReason) < 1 THEN 'No Data' ELSE REPLACE(LeavingReason, '>', '') END as LeavingReason,
    LeavingReasonCategory, 
    LeavingReasonType, 
    PrimaryAddressType, 
    AddressLine1, 
    AddressLine2, 
    AddressLine3, 
    AddressLine4, 
    AddressLine5, 
    AddressLine6, 
    Country, 
    FirstOccupancyStartDate, 
    LastOccupancyEndDate, 
    FromDate, 
    ToDate, 
    RedactStatus, 
    CurrentFlag as PersonCurrent_Flag, 
    LoadID as DimPersonLoadID, 
    LoadDate as DimPersonLoadDate, 
    GenderReassignment, 
    SexualIdentification,
    PersonHistorySequence
INTO #Temp_DimPerson1
FROM [staging].[mhr_DimPerson]
Where 1=1
--AND FullName like '%kakkad%'
--AND PersonID IN ('9998013tnb','7235560Fo8','6003664QLi')
;


SELECT 
    tdp1.*,
	--tcpm.PositionName as CurrentPosition
    CASE
		WHEN LEN(tcpm.PositionName) > 0 THEN tcpm.PositionName
		ELSE 'No Data'
	END as CurrentPosition
INTO #Temp_DimPerson2
FROM #Temp_DimPerson1 tdp1
LEFT JOIN #Temp_CurrentPositionMap tcpm ON tdp1.PersonID = tcpm.CurrentPersonID
;

SELECT 
    PersonID,
    PreferredFullNameMax
INTO #Temp_DimPerson_FullName
FROM (
    SELECT 
        PersonID,
        PreferredFullName as PreferredFullNameMax,
        ROW_NUMBER() OVER (PARTITION BY PersonID ORDER BY PersonHistorySequence DESC) AS rn
    FROM #Temp_DimPerson2
) AS sub
WHERE rn = 1;

SELECT 
		tdp.*,
		tdpfn.PreferredFullNameMax,
		CASE 
		WHEN LOWER(SUBSTRING(EmailAddress, CHARINDEX('@', EmailAddress) + 1, LEN(EmailAddress))) <> 'plusdane.co.uk' THEN 1 
		ELSE 0 
		END AS EmailAdressNonPlusDane_Flag,
		CASE 
			WHEN Age = 0 OR LEN(Age) < 1 THEN 'No Age'
			WHEN Age >= 1 AND Age <= 20 THEN 'Under 21'
			WHEN Age >= 21 AND Age <= 30 THEN '21-30'
			WHEN Age >= 31 AND Age <= 40 THEN '31-40'
			WHEN Age >= 41 AND Age <= 50 THEN '41-50'
			WHEN Age >= 51 AND Age <= 60 THEN '51-60'
			WHEN Age >= 61 THEN 'Over 60'
			ELSE 'Error'
		END AS AgeBands,
		CASE 
			WHEN LengthofService = 1 THEN '1'
			WHEN LengthofService > 1 AND LengthofService <= 2 THEN '<2'
			WHEN LengthofService > 2 AND LengthofService <= 5 THEN '2-5'
			WHEN LengthofService > 5 AND LengthofService <= 10 THEN '5-10'
			WHEN LengthofService > 10 AND LengthofService <= 15 THEN '10-15'
			WHEN LengthofService > 15 AND LengthofService <= 20 THEN '15-20'
			WHEN LengthofService > 20 AND LengthofService <= 25 THEN '20-25'
			WHEN LengthofService > 25 AND LengthofService <= 30 THEN '25-30'
			WHEN LengthofService > 30 AND LengthofService <= 35 THEN '30-35'
			WHEN LengthofService > 35 AND LengthofService <= 40 THEN '35-40'
			WHEN LengthofService > 40 THEN '40 +'
		END AS LengthofServicesBands
INTO #Temp_DimPerson3
FROM #Temp_DimPerson2 tdp
LEFT JOIN #Temp_DimPerson_FullName tdpfn ON tdp.PersonID = tdpfn.PersonID
;

SELECT 
		tdp.*,
		CASE 
			WHEN EmailAdressNonPlusDane_Flag = 1 THEN 
				CASE 
					WHEN PreferredName IS NULL OR LEN(PreferredName) < 1 THEN LOWER(Forename1)
					ELSE LOWER(PreferredName)
				END + '.' + LOWER(Surname) + '@plusdane.co.uk'
			ELSE EmailAddress
		END AS EmailAddressCalculatedTemp
INTO #Temp_DimPerson4
FROM #Temp_DimPerson3 tdp;

SELECT 
		tdp.*,
		CASE
			WHEN tdpfn.PersonalReference IS NULL OR LEN(tdpfn.PersonalReference) < 1 THEN EmailAddressCalculatedTemp
			ELSE tdpfn.PersonalReference
		END as EmailAddressCalculated
INTO dwh.Dim_Person
FROM #Temp_DimPerson4 tdp
LEFT JOIN #Temp_EmailFixMap tdpfn ON tdp.EmailAddressCalculatedTemp = tdpfn.PersonalReference
;

END;
dwh	BuildDimPosition	
-- =============================================
-- Author:      Amit Kakkad
-- Create Date: 15th May 2024
-- Description: Transforms Position Data
-- =============================================

CREATE PROCEDURE [dwh].[BuildDimPosition] 
AS
BEGIN

    -- SET NOCOUNT ON added to prevent extra result sets from
    -- interfering with SELECT statements.
    SET NOCOUNT ON

-- Check if the Dim_CX_Calendar table exists
IF OBJECT_ID('dwh.Dim_Position') IS NOT NULL
BEGIN
    DROP TABLE dwh.Dim_Position;
END;

-- NameMap
-- Insert data into #Temp_NameMap
SELECT 
    DISTINCT
    PersonID,
    PreferredName + ' ' + Surname AS FullNameTemp
INTO #Temp_NameMap
FROM dwh.Dim_Person;


SELECT 
    CASE 
        WHEN FLOOR(ContractualHours) < 1 OR ContractualHours IS NULL THEN 35
        ELSE ContractualHours
    END AS ContractualHours,
	ContractualHours as ContractualHoursOriginal,
    CASE
        WHEN ContractualHours < 1 OR ContractualHours IS NULL THEN 1
        ELSE 0
    END AS ContractualHoursMissing_Flag,
    CASE
        WHEN LEN(Location) < 1 OR Location IS NULL THEN 'No Data'
        ELSE Location
    END AS Location,
	CurrentFlag as PositionCurrent_Flag, 
	FromDate as PositionFromDate, 
	ToDate as PositionToDate,
	PositionKey, 
	PositionID, 
	PositionName, 
	PostReference, 
	PostID, 
	PostName, 
	PositionStartDate, 
	PositionEndDate, 
	PositionExpectedEndDate, 
	PositionExpectedEndReason, 
	PositionRefNo, 
	PositionFullReference, 
	ScaleKey, 
	Salary, 
	ActualSalary, 
	SalaryBand, 
	SalaryFrequency, 
	Grade, 
	GradeDescription, 
	GradeStartDate, 
	GradeEndDate, 
	ActualGradeFrequency, 
	ActualRateofPay, 
	MinRateofPay, 
	MidRateofPay, 
	MaxRateofPay, 
	ProtectedRateofPay, 
	ProtectedGradeFrequency, 
	NextIncrementDate, 
	PaymentTable, 
	PaymentTableDescription, 
	ScaleID, 
	ScaleFrequency, 
	ScaleType, 
	ActualScalepointID, 
	ActualScalepointValue, 
	ActualScalepointReference, 
	ActualScalepointStartDate, 
	ActualScalepointEndDate, 
	MinScalepointID, 
	MinScalepointValue, 
	MinScalepointReference, 
	MinScalepointStartDate, 
	MinScalepointEndDate, 
	MidScalepointID, 
	MidScalepointValue, 
	MidScalepointReference, 
	MidScalepointStartDate, 
	MidScalepointEndDate, 
	MaxScalepointID, 
	MaxScalepointValue, 
	MaxScalepointReference, 
	MaxScalepointStartDate, 
	MaxScalepointEndDate, 
	ProtectedScalepointID, 
	ProtectedScalepointValue, 
	ProtectedScalepointReference, 
	ProtectedScalepointStartDate, 
	ProtectedScalepointEndDate, 
	BarScalepointID, 
	BarScalepointValue, 
	BarScalepointReference, 
	BarScalepointStartDate, 
	BarScalepointEndDate, 
	ContractualHoursStartDate, 
	ContractualHoursEndDate, 
	FTEHours, 
	FTEHoursStartDate, 
	FTEHoursEndDate, 
	FTE, 
	AnnualWeeksWorked, 
	AnnualWeeksWorkedStartDate, 
	AnnualWeeksWorkedEndDate, 
	Category, 
	CategoryStartDate, 
	CategoryEndDate, 
	Type, 
	TypeStartDate, 
	TypeEndDate, 
	Basis, 
	BasisStartDate, 
	BasisEndDate, 
	ReportingManager, 
	MgrPersonID, 
	JobFamily, 
	PositionHistorySequence, 
	KeyPosition, 
	Manager, 
	NumberOfStaff,  
	CurrentPersonKey 
INTO #Temp_DimPosition1
FROM [staging].[mhr_DimPosition]
Where 1=1
--AND FullName like '%kakkad%'
--AND PositionID IN ('9998013tnb','7235560Fo8','6003664QLi')
;


SELECT 
    tdp1.*,
    ISNULL(tcpm.FullNameTemp, 'No Data') AS ManagersName
INTO dwh.Dim_Position
FROM #Temp_DimPosition1 tdp1
LEFT JOIN (
    SELECT 
        PersonID,
        MAX(FullNameTemp) AS FullNameTemp
    FROM #Temp_NameMap
    GROUP BY PersonID
) tcpm ON tdp1.MgrPersonID = tcpm.PersonID;


END;
dwh	BuildDimRepair	
CREATE PROCEDURE [dwh].[BuildDimRepair]
AS

    SET NOCOUNT ON

    TRUNCATE TABLE dwh.Dim_Repair



    DROP TABLE IF EXISTS #StageHist
    
    select 
        [Job-No],
        [Stage-Date], 
        [Stage-Time], 
        [Stage-hist-number], 
        [user-id],
        [Stage-Code],
        Row_Number() OVER (PARTITION BY [Job-No] ORDER BY [Stage-hist-number] DESC) as RowNo  
    INTO #StageHist
    from [staging].[opencontractor_rm-stage-history] 
    --where [Job-No] = '11430546' and 
    where [Stage-Code] = '90'
    order by [stage-hist-number]

    
    --Bring in RFT data. Easier to hold in temp table. Linking in the view to the final query or as a CTE would add to query plan complexity.
    DROP TABLE IF EXISTS #JobRFT

    CREATE TABLE #JobRFT
    (
        JobNumber VARCHAR(100) PRIMARY KEY,
        RFT INT
    )

    INSERT INTO #JobRFT
    
    SELECT DISTINCT
        name,
        JobRft

    FROM
        staging.JobRightFirstTimeLookup 
    
    ;

    --Bring in temp table of DRS fields for use in CTE
    DROP TABLE IF EXISTS #DRS 

    SELECT  
        drs_c_job.[USERID],
        drs_c_job.[PARENTID], 
        COALESCE(stat.MappedVisitStatus, drs_c_job.[STATUS]) as [STATUS],
        drs_c_job.[BD_APPOINTMENT_SEQUENCE], 
        drs_c_job.BD_TASK_COMPLETION_STAT,
        drs_c_job.CURRENTASSIGNMENT_START,
        drs_c_job.GLOBALCURRENTTIMEWINDOW_START,
        drs_c_job.[NAME],
        drs_c_job.ASSIGNEDWORKERS,
        csc.Category as CompletionStatusCategory
    INTO #DRS
    FROM staging.drs_c_job 
    LEFT JOIN staging.mapping_CompletionStatusCategory csc
    ON drs_c_job.BD_TASK_COMPLETION_STAT = csc.VisitCompletionStatus
    LEFT JOIN staging.mapping_DRSVisitStatus stat 
	on drs_c_job.[STATUS] = stat.VisitStatus




    DROP TABLE IF EXISTS #Jobs

    /*Easier to hold job data with created date time values in a temp table. Everything could be done in one query, but takes a bit longer and gets messy with repeated
    nested DATEADD functions.*/
    CREATE TABLE #Jobs
    (
        [JOB-NO] VARCHAR(20) PRIMARY KEY,
        [SHORT-DESCRIPTION] VARCHAR(MAX),
        CONTRACT VARCHAR(20), 
        [DATE-REPORTED] DATETIME2(7),
        [DATE-LOGGED] DATETIME2(7),
        [DATE-COMP] DATETIME2(7),
        [JOB-STATUS] VARCHAR(20),
        [ORIG-LOGGED-VALUE] DECIMAL(38,18),
        [TOTAL-VALUE] DECIMAL(38,18),
        [RAISED-BY] VARCHAR(50),
        [LATEST-PRIORITY] VARCHAR(20),
        [TRADE-CODE] VARCHAR(20),
        CONTRACTOR VARCHAR(30),
        [JOB-TYPE] VARCHAR(20),
        [PLACE-REF] VARCHAR(20),
        [DATE-REPORTED-DATE] DATETIME2(7),
        [DATE-LOGGED-DATE] DATETIME2(7),
        [DATE-COMP-DATE] DATETIME2(7),
        [CURRENT-STAGE-CODE] VARCHAR(50),
        [SMV] DECIMAL (12, 2)

    );
    

    WITH JobData
    AS
    (
        /*Need to add times to the date fields, but before that we need a value for time that we can work with. Time in OC appears to be a text field that can be in many 
        formats such as 1546, 154612, 15:46:12. Its is assumed that any combination of numbers represents hours, minutes and seconds. 
        As the use of : is an exception, then remove : from time strings. Then take the left 4 to retrieve hours and minutes.*/
        SELECT
            j.[JOB-NO],
            j.[SHORT-DESCRIPTION],
            j.CONTRACT, 
            j.[DATE-REPORTED],
            LEFT(REPLACE(j.[DATE-REPORTED-TIME], ':', ''), 4) AS [DATE-REPORTED-TIME],
            j.[DATE-LOGGED],
            LEFT(REPLACE(j.[DATE-LOGGED-TIME], ':', ''), 4) AS [DATE-LOGGED-TIME],
            j.[DATE-COMP],
            LEFT(REPLACE(j.[DATE-COMP-TIME], ':', ''), 4) AS [DATE-COMP-TIME],
            j.[JOB-STATUS] as [JOB-STATUS],
            j.[ORIG-LOGGED-VALUE],
            j.[TOTAL-VALUE],
            j.[RAISED-BY],
            J.[LATEST-PRIORITY],
            j.[TRADE-CODE],
            j.CONTRACTOR,
            j.[JOB-TYPE],
            j.[PLACE-REF],
            j.[CURRENT-STAGE-CODE],
            j.[SMV]


            FROM 
                staging.[opencontractor_rm-job] j

    )

    INSERT INTO #Jobs
    --Add times to dates to return a single datetime field value.
    SELECT
        [JOB-NO],
        [SHORT-DESCRIPTION],
        CONTRACT, 
        DATEADD(mi, CAST(RIGHT([DATE-REPORTED-TIME], 2) AS INT), DATEADD(hh, CAST(LEFT([DATE-REPORTED-TIME], 2) AS INT), [DATE-REPORTED])) AS JobDateReported,
        DATEADD(mi, CAST(RIGHT([DATE-LOGGED-TIME], 2) AS INT), DATEADD(hh, CAST(LEFT([DATE-LOGGED-TIME], 2) AS INT), [DATE-LOGGED])) AS JobDateLogged,
        DATEADD(mi, CAST(RIGHT([DATE-COMP-TIME], 2) AS INT), DATEADD(hh, CAST(LEFT([DATE-COMP-TIME], 2) AS INT), [DATE-COMP])) AS JobDateCompleted,
        [JOB-STATUS],
        [ORIG-LOGGED-VALUE],
        [TOTAL-VALUE],
        [RAISED-BY],
        [LATEST-PRIORITY],
        [TRADE-CODE],
        CONTRACTOR,
        [JOB-TYPE],
        CASE 
            WHEN [PLACE-REF] = '334006B' THEN 'NURSLA006B01'
            WHEN [PLACE-REF] = '2350910' THEN 'DM127'
            WHEN [PLACE-REF] = '3180050' THEN 'BANKDR5'
            WHEN [PLACE-REF] = '3230130' THEN 'FERNCR13'
            WHEN [PLACE-REF] = '4150150' THEN 'REESCR15'
            ELSE [PLACE-REF] 
        END as [PLACE-REF], --see comment below
        [DATE-REPORTED],
        [DATE-LOGGED],
        [DATE-COMP],
        [CURRENT-STAGE-CODE],
        [SMV]

    FROM JobData;

    /*
    --case statement re place-ref
    
    PLACEREF, AssetReference, AssetId
    334006B, NURSLA006B01, 6170
    2350910, DM127, 16727
    3180050, BANKDR5, 126
    3230130, FERNCR13, 2379
    4150150, REESCR15, 8772

    --The Place Ref column above is the one in RMJOB. 
    --If a job is logged against one of these 5 refs, they are incorrect and have to converted to the correct CX Asset Ref and AssetIds (Cols 2 and 3).

    */

    DROP TABLE IF EXISTS #AssetReferenceDeDup

    --de dup the asset reference table to find out what the Open Contract PLACE-REF maps to a CX Asset record
    select 
        AssetReferenceId, 
        AssetId, 
        AssetReferenceTypeId, 
        Reference, 
        Row_Number() OVER (PARTITION BY Reference ORDER BY AssetId) as RowNo 
    INTO #AssetReferenceDeDup 
    from staging.cx_assetreference 
    WHERE /*AssetReferenceTypeId = 1 and*/ EffectiveFromDate <= getdate() 
    and (EffectiveToDate > getdate() or EffectiveToDate is null );

    DROP TABLE IF EXISTS #AssetStatusLookup

    --find out when the asset was void or tenanted
    SELECT 
        a.AssetId, 
        c.statuscode, 
        a.RentVoidEpisodeId, 
        a.RentAgreementAssetId, 
        rae.AgreementId, 
        cast(a.EffectiveFromDate as date) as EffectiveFromDate, 
        cast(COALESCE(a.EffectiveToDate,getdate()) as date) as EffectiveToDate, 
        case when RentVoidEpisodeId is not null then 1 else 0 end as VoidFlag
    INTO #AssetStatusLookup
    FROM [staging].[cx_assetstatus] a
    left join [staging].[cx_assetstatuscode] c 
        on a.statuscodeid = c.statuscodeid
    left join staging.cx_rentagreementasset rae 
        on a.RentAgreementAssetId = rae.AgreementAssetId
    --where a.AssetId = 4189 --12295
    

    DROP TABLE IF EXISTS #RentAgreementEps

    --we need to know which agreement episode is the most current, to do this look at  the rent agreement episode table and calculcate the first and current flag. 
    ;with rentagreementepisoderownumber as 
    (
        select 
            AgreementEpisodeId, 
            AgreementId, 
            ContactGroupId, 
            AgreementTenureTypeId,
            cast(EffectiveFromDate as date) as EffectiveFromDate, 
            cast(EffectiveToDate as date) as EffectiveToDate, 
            Row_Number() OVER (PARTITION BY AgreementId ORDER BY EffectiveFromDate ASC) as RowNo
        from [staging].[cx_rentagreementepisode] 
        where (EffectiveFromDate <= EffectiveToDate or EffectiveToDate is null) 
    ),
    --work out the max row no
    maxrentagreementepisoderownumber as 
    ( 
        select 
            AgreementId, 
            MAX(RowNo) as max 
        from rentagreementepisoderownumber as rae 
        group by AgreementId
    ),
    --work out the max episode from max row now
    maxagreementepisode as 
    (
        select 
            max.AgreementId, 
            max.max, e.AgreementEpisodeId, 1 as MostRecentEpisodeFlag
        FROM maxrentagreementepisoderownumber max 
        left join rentagreementepisoderownumber e 
            on max.AgreementId = e.AgreementId and max.max = e.rowno 
    )
    --calculcate the flags
    select rae.AgreementEpisodeId, 
        rae.AgreementId, 
        rae.ContactGroupId, 
        rae.AgreementTenureTypeId, 
        cast(rae.EffectiveFromDate as date) as EffectiveFromDate, 
        cast(rae.EffectiveToDate as date) as EffectiveToDate, 
        case when rae.rowno=1 then 1 else 0 end as FirstEpisodeFlag, 
        case when rae.EffectiveFromDate <= getdate() and (rae.EffectiveToDate is null or rae.EffectiveToDate > getdate()) then 1 else 0 end as CurrentEpisodeFlag,
        case when max.MostRecentEpisodeFlag = 1 then 1 else 0 end as MostRecentEpisodeFlag
    into #RentAgreementEps 
    from rentagreementepisoderownumber as rae 
    left join maxagreementepisode max 
        on rae.AgreementEpisodeId = max.AgreementEpisodeId

    DROP TABLE IF EXISTS Staging.JobAgreementContactGroup;
    
    --Calculcate which Agreement and Contact Group the repair is linked to, based on when the repair was logged and which agreement was active against the asset at that time.
    --Also find out if the repair was logged when the asset was void 
    SELECT 
        cast(j.[DATE-LOGGED] as date) as [DATE-LOGGED],
        j.[JOB-NO] as JobNo,
        j.[PLACE-REF] as PlaceRef, 
        coalesce(cast(ra.AssetId as varchar),'No Data') as Asset, 
        coalesce(cast(a.AgreementId as varchar),'No Data') as Agreement, 
        cast(a.EffectiveFromDate as date) as 'Agreement Effective From', 
        cast(a.EffectiveToDate as date) as 'Agreement Effective To',
        coalesce(cast(rae.ContactGroupId as varchar),'No Data') as ContactGroup,
        rae.EffectiveFromDate as 'Contact Group Effective From', 
        rae.EffectiveToDate  as 'Contact Group Effective To',
        coalesce(cast(asl.VoidFlag as varchar),1) as AssetVoid, --sometimes there is no void record when the property is empty. Example is AssetId 4189 and Repair 11612156. Set the flag to true if there is no void or no tenanted record from #AssetStatusLookup
        asl.RentVoidEpisodeId as VoidEpisode,
        asl.EffectiveFromDate as 'Void Effective From',
        asl.EffectiveToDate as 'Void Effective To'

    INTO Staging.JobAgreementContactGroup

    --FROM [staging].[opencontractor_rm-job] j
    FROM #Jobs j
    left join #AssetReferenceDeDup ra 
        on j.[place-ref] = ra.Reference 
        and RowNo = 1
    left join [staging].[cx_rentagreementasset] a 
        on ra.assetid = a.assetid 
        and cast(j.[date-logged] as date) between cast(a.EffectiveFromDate as date) and cast(COALESCE(a.EffectiveToDate,getdate()) as date)
        --and a.EffectiveFromDate <> a.EffectiveToDate
    left join #RentAgreementEps rae on a.AgreementId = rae.AgreementId
        and rae.MostRecentEpisodeFlag = 1
    left join #AssetStatusLookup asl 
        on ra.AssetId = asl.AssetId 
        and cast(j.[date-logged] as date) between cast(asl.EffectiveFromDate as date) and cast(COALESCE(asl.EffectiveToDate,getdate()) as date);


    DROP TABLE IF EXISTS #SorInspections

    --find jobs which have a SOR of inspection and count how many per job no. I will create a flag in dim_repair based off this.
    select 
        distinct sor.[Job-No], 
        count(sor.[Element-Code]) as CountSOR
    Into #SorInspections
    from staging.[opencontractor_rm-job-elements] sor
    join staging.mapping_SorInspections map on sor.[Element-Code] = map.SorElementCode
    group by sor.[Job-No]
    ;


    DROP TABLE IF EXISTS #ApptSeq;

    --find out the appointment sequence of a job based on DRS current assignment ordering. 
    --Return the most recent Appointment details for DRS to use as flag in dim_repair
    with AppointmentsBySequence as 
    (
        select 
            dr.[JOB-NO], 
            dr.[JOB-STATUS], 
            dra.[USERID],
            dra.[PARENTID], 
            dra.[STATUS], 
            dra.[BD_APPOINTMENT_SEQUENCE], 
            dra.BD_TASK_COMPLETION_STAT,
            dra.CURRENTASSIGNMENT_START,
            dra.CompletionStatusCategory,
            DRA.ASSIGNEDWORKERS,
            --coalesce(dra.CURRENTASSIGNMENT_START, dra.GLOBALCURRENTTIMEWINDOW_START) as JobStart,
            Row_Number() OVER (PARTITION BY dr.[JOB-NO] ORDER BY dra.GLOBALCURRENTTIMEWINDOW_START) as RowNo 
        from #Jobs dr join #DRS dra on dr.[JOB-NO] = dra.NAME 
    ),
    MaxAppointment as
    (
        select [JOB-NO], max(RowNo) as MaxRowNo 
        from AppointmentsBySequence 
        GROUP BY [JOB-NO] 
    
    ),
    LatestAppointment as 
    (
        select s.[JOB-NO], s.[USERID], m.MaxRowNo, s.[STATUS], s.BD_TASK_COMPLETION_STAT, s.[JOB-STATUS], s.CompletionStatusCategory, s.ASSIGNEDWORKERS, s.CURRENTASSIGNMENT_START
        From AppointmentsBySequence s join MaxAppointment m on s.[JOB-NO] = m.[JOB-NO] and s.RowNo = m.MaxRowNo
    )

    select * INTO #ApptSeq from LatestAppointment; 

    --select * from #ApptSeq

    --select top 100 datediff(SECOND, [DATE-REPORTED],[DATE-COMP]) as diff, (datediff(SECOND, [DATE-REPORTED],[DATE-COMP]) / 60.0 / 60.0 /24.0) as diff2,  * from #Jobs order by [DATE-REPORTED] desc

    /*To create a flag for if a job was on time, we need to see if the all the vists linked to a job were on time.
    So get the sum of job visits on time (field is a flag value of 0 or 1 where 1 means the visit was on time) and the count of visits.
    In the final query, if the sum of on time visits = count of vists then all visits were on time and therefore so was the job.*/
    WITH JobVisitsOnTime
    AS
    (   
        SELECT 
            ra.JobNumber, 
            SUM(ra.[JobVisitOnTimeCount]) As TotalVisitsOnTime, 
            COUNT(*) AS TotalVisits

        FROM 
            dwh.Fact_RepairAppointment ra

        GROUP BY 
            ra.JobNumber

    )

    INSERT INTO dwh.Dim_Repair
    (
        JobNumber,
        JobDescription,
        JobRaisedBy,
        JobPriority,
        JobPriorityCode,
        JobPrioritySimplified,
        JobContract,
        JobContractDescription,
        JobRepairType,
        JobRepairTypeSimplified,
        JobTaskType,
        JobTaskTypeDescription,
        JobTaskTypeSimplified,
        JobTrade,
        JobStatusDescription,
        JobStatus,
        JobStatusSimplified,
        JobSupplier,
        JobSupplierCode,
        JobDateTimeReported,
        JobDateTimeLogged,
        JobDateTimeCompleted,
        JobDateTimeAbandoned,
        JobTargetDateTime,
        JobTotalCost,
        JobEstimatedCost,
        JobActualCost,
        JobLength,
        JobCompleted,
        JobCompletedWithinTarget,
        JobOnTime,
        SorJobNumber,
        JobRightFirstTime,
        JobAssetReference,
        JobCancelled,
        JobOverdue,
        JobDateCompletedKey,
        DateKey,
        AgreementId,
        ContactGroupId,
        AssetId,
        JobNonSocialRepair,
        JobGarageRepair,
        JobVoidRepair,
        JobFirstVisitOrInspection,
        JobContractResponsiveOrGas,
        JobExcludedJobTaskTypes,
        JobExternalContractor,
        JobDateReported,
        JobDateLogged,
        JobDateCompleted,
        JobDateAbandoned,
        JobTargetDate,
        [JobMostRecentVisitId],
        [JobMostRecentApptStatus],
        [JobMostRecentApptCompletionStatus],
        JobMostRecentVisitDate,
        JobMostRecentTradesperson,
        JobCurrentStage,
        JobCurrentStageDescription,
        JobCompletedBy,
        JobSMV
    )


    SELECT
        j.[JOB-NO] AS JobNumber,
        j.[SHORT-DESCRIPTION] AS JobDescription,
        coalesce(u.[DESCRIPTION],[RAISED-BY]) AS JobRaisedBy,
        CASE
            WHEN P.[DESCRIPTION] LIKE '%Cat 2%' THEN 'P5 - Cat 2 Voids'
            WHEN p.[DESCRIPTION] LIKE '%Cat 3%' THEN 'P5 - Cat 3 Voids'
            WHEN p.[DESCRIPTION] LIKE '%Other%' THEN 'P4 - Other'
            WHEN p.[DESCRIPTION] LIKE '%12 M%' THEN '12 Months'
            ELSE p.[DESCRIPTION]
        END AS JobPriority,
        j.[LATEST-PRIORITY] AS JobPriorityCode,
        ps.JobPrioritySimplified, 
        j.CONTRACT AS JobContract, 
        c.[DESCRIPTION] as JobContractDescription,
        c.[DESCRIPTION] AS JobRepairType,
        rt.RepairTypeSimplified AS JobRepairTypeSimplified,
        jt.[JOB-TYPE] AS JobTaskType,
        jt.[DESCRIPTION] AS JobTaskTypeDescription,
        rtt.TaskTypeSimplified AS JobTaskTypeSimplified,
        t.DESCRIPTION AS JobTrade,
        s.DESCRIPTION AS JobStatusDescription,
        j.[JOB-STATUS] AS JobStatus,
        CASE
            WHEN s.DESCRIPTION IN ('Work Completed','Fully Completed') THEN 'Completed'
            WHEN s.DESCRIPTION = 'Abandoned' THEN 'Abandoned'
            ELSE 'Open' 
        END as JobStatusSimplified,
        CASE
            WHEN j.CONTRACTOR = '3D0010' THEN 'Plus Dane Housing'
            ELSE cont.DESCRIPTION
        END AS JobSupplier,
        j.CONTRACTOR as JobSupplierCode,
        j.[DATE-REPORTED]AS JobDateReported,
        j.[DATE-LOGGED] AS JobDateLogged,
        j.[DATE-COMP] AS JobDateCompleted,
        CASE
            WHEN j.[JOB-STATUS] = 92 THEN j.[DATE-COMP]
        END AS JobDateAbandoned,
        CASE
            WHEN pct.TargetUnits = 'Hours' THEN DATEADD(hh, pct.Target, j.[DATE-REPORTED])
            WHEN pct.TargetUnits = 'Days' THEN DATEADD(dd, pct.Target, j.[DATE-REPORTED])
            WHEN pct.TargetUnits = 'Months' THEN DATEADD(mm, pct.Target, j.[DATE-REPORTED])
            WHEN pct.TargetUnits = 'Years' THEN DATEADD(yy, pct.Target, j.[DATE-REPORTED])
        END AS JobTargetDate,
        --jtd.JobTargetDate,
        --CASE
        --    WHEN j.[JOB-STATUS] <> 93 THEN j.[ORIG-LOGGED-VALUE]
        --    ELSE j.[TOTAL-VALUE]
        --END AS JobTotalCost,
        --[j].[ORIG-LOGGED-VALUE] AS JobEstimatedCost,
        --j.[TOTAL-VALUE] AS JobActualCost,
        0 as JobTotalCost,
        0 as JobEstimatedCost,
        0 as JobActualCost,
        DATEDIFF(dd, j.[DATE-LOGGED], [DATE-COMP]) AS JobLength,
        CASE
            WHEN s.DESCRIPTION IN ('Work Completed','Fully Completed') THEN 1
            ELSE 0
        END AS JobCompleted,
        CASE
            WHEN j.[DATE-COMP] <= (
                                    CASE
                                        WHEN pct.TargetUnits = 'Hours' THEN DATEADD(hh, pct.Target, j.[DATE-REPORTED])
                                        WHEN pct.TargetUnits = 'Days' THEN DATEADD(dd, pct.Target, j.[DATE-REPORTED])
                                        WHEN pct.TargetUnits = 'Months' THEN DATEADD(mm, pct.Target, j.[DATE-REPORTED])
                                        WHEN pct.TargetUnits = 'Years' THEN DATEADD(yy, pct.Target, j.[DATE-REPORTED])
                                    END) AND s.DESCRIPTION IN ('Work Completed','Fully Completed') THEN 1
            ELSE 0
        END AS JobCompletedWithinTarget,
        CASE
            WHEN jvot.TotalVisitsOnTime IS NULL THEN NULL
            WHEN jvot.TotalVisitsOnTime = jvot.TotalVisits THEN 1
            ELSE 0
        END AS JobOnTime,
        j.[JOB-NO] AS SorJobNumber,
        CASE
            WHEN s.DESCRIPTION IN ('Work Completed','Fully Completed') THEN coalesce(rft.RFT,0)
        END AS JobRightFirstTime,
        j.[PLACE-REF] AS JobAssetReference,
        CASE
            WHEN s.DESCRIPTION = 'Abandoned' THEN 1
            ELSE 0
        END AS JobCancelled,
        CASE
            WHEN CASE
                    WHEN pct.TargetUnits = 'Hours' THEN DATEADD(hh, pct.Target, j.[DATE-REPORTED])
                    WHEN pct.TargetUnits = 'Days' THEN DATEADD(dd, pct.Target, j.[DATE-REPORTED])
                    WHEN pct.TargetUnits = 'Months' THEN DATEADD(mm, pct.Target, j.[DATE-REPORTED])
                    WHEN pct.TargetUnits = 'Years' THEN DATEADD(yy, pct.Target, j.[DATE-REPORTED])
                END < GETDATE() AND s.DESCRIPTION NOT IN ('Work Completed','Fully Completed', 'Abandoned') THEN 1
            ELSE 0
        END AS JobOverdue,
        CAST(CAST(CAST(j.[DATE-COMP] AS DATETIME) AS FLOAT) AS INT) + 2 AS JobDateCompletedKey,
        CAST(CAST(CAST(j.[DATE-LOGGED] AS DATETIME) AS FLOAT) AS INT) + 2 AS DateKey,
        jacg.Agreement,
        jacg.ContactGroup,
        ar.AssetId,
        CASE
            WHEN asset.[Category] = 'Non Social' THEN 1
            ELSE 0
        END AS JobNonSocialRepair,
        CASE
            WHEN asset.[Category] = 'Garage' THEN 1
            ELSE 0
        END AS JobGarageRepair,
        CASE
            WHEN jacg.AssetVoid= '1' THEN 1
            ELSE 0
        END AS JobVoidRepair,
        CASE
            WHEN sorinsp.[CountSOR] is not null THEN 1
            ELSE 0
        END AS JobFirstVisitOrInspection,
        CASE 
            WHEN j.CONTRACT = 'RESPM' THEN 1 --was contract?
            WHEN j.CONTRACT = 'RESPC' THEN 1 --was contract?
            WHEN j.[JOB-TYPE] = 'GASB' AND j.CONTRACT IN ('GAS3C','GAS3M') THEN 1
        ELSE 0 END as JobContractResponsiveOrGas,
        CASE 
            WHEN j.[JOB-TYPE] in ('DISR', 'RSER', 'CURE', 'DEFT', 'LORE', 'RESM') THEN 1 
        ELSE 0 END as JobExcludedJobTaskTypes,
        CASE
            WHEN j.CONTRACTOR = '3D0010' THEN 0
            ELSE 1
        END as JobExternalContractor,
        j.[DATE-REPORTED-DATE] as JobDateReported,
        j.[DATE-LOGGED-DATE] as JobDateLogged,
        j.[DATE-COMP-DATE] as JobDateCompleted,
        CASE
            WHEN j.[JOB-STATUS] = 92 THEN j.[DATE-COMP-DATE]
        END AS JobDateAbandoned,
        CASE
            WHEN pct.TargetUnits = 'Hours' THEN CAST(DATEADD(hh, pct.Target, j.[DATE-REPORTED]) AS DATE)
            WHEN pct.TargetUnits = 'Days' THEN CAST(DATEADD(dd, pct.Target, j.[DATE-REPORTED]) AS DATE)
            WHEN pct.TargetUnits = 'Months' THEN CAST(DATEADD(mm, pct.Target, j.[DATE-REPORTED]) AS DATE)
            WHEN pct.TargetUnits = 'Years' THEN CAST(DATEADD(yy, pct.Target, j.[DATE-REPORTED]) AS DATE)
        END as JobTargetDate,
        ApptSeq.USERID as [JobMostRecentVisitId],
        ApptSeq.[STATUS] as [JobMostRecentApptStatus],
        ApptSeq.CompletionStatusCategory as [JobMostRecentApptCompletionStatus],
        ApptSeq.CURRENTASSIGNMENT_START as JobMostRecentVisitDate,
        ApptSeq.ASSIGNEDWORKERS as JobMostRecentTradesperson,

        j.[CURRENT-STAGE-CODE] as JobCurrentStage,
        stage.[DESCRIPTION] as JobCurrentStageDescription,
        h.[user-id] as JobCompletedBy,
        j.SMV as JobSMV

    FROM 
        #Jobs j

        LEFT JOIN staging.[opencontractor_co-users] u
        ON j.[RAISED-BY] = u.[USER-NAME]

        LEFT JOIN staging.[opencontractor_rm-priority] p
        ON J.[LATEST-PRIORITY] = P.[PRIORITY-CODE]
        AND J.CONTRACT = P.CONTRACT

        LEFT JOIN staging.mapping_JobPrioritySimplified ps
        ON p.[DESCRIPTION] = ps.JobPriority

        LEFT JOIN staging.[opencontractor_rm-contract] c
        ON j.CONTRACT = c.CONTRACT

        LEFT JOIN staging.[opencontractor_rm_trades] t
        ON j.[TRADE-CODE] = t.[TRADE-CODE]

        LEFT JOIN staging.opencontractor_rm_stages s
        ON j.[JOB-STATUS] = s.[STAGE-CODE]

        LEFT JOIN staging.opencontractor_rm_stages stage
        ON j.[CURRENT-STAGE-CODE] = stage.[STAGE-CODE]

        LEFT JOIN staging.[opencontractor_rm-cont] cont
        ON j.CONTRACTOR = cont.CONTRACTOR

        LEFT JOIN staging.mapping_RepairType rt
        ON c.[DESCRIPTION] = rt.RepairType

        LEFT JOIN staging.[opencontractor_rm_job-type] jt
        ON j.[JOB-TYPE] = jt.[JOB-TYPE]

        LEFT JOIN staging.mapping_RepairTaskType rtt
        ON j.[JOB-TYPE] = rtt.TaskType

        LEFT JOIN staging.mapping_PriorityCodeTarget pct
        ON j.[LATEST-PRIORITY] = pct.PriorityCode

        LEFT JOIN JobVisitsOnTime jvot
        ON j.[JOB-NO] = jvot.JobNumber

        LEFT JOIN #JobRFT rft
        ON j.[JOB-NO] = rft.JobNumber

        LEFT JOIN Staging.JobAgreementContactGroup jacg
        on j.[JOB-NO] = jacg.JobNo

        LEFT JOIN #AssetReferenceDeDup ar 
        on j.[place-ref] = ar.Reference 
        and ar.RowNo = 1

        -- LEFT JOIN [dwh].[Dim_AssetCharacteristic] ac
        -- on ar.AssetId = ac.AssetId 

        LEFT JOIN [dwh].[Dim_Asset] asset
        on ar.AssetId = asset.AssetId 

        LEFT JOIN #SorInspections sorinsp
        on j.[JOB-NO] = sorinsp.[Job-No] 

        LEFT JOIN #ApptSeq ApptSeq
        ON j.[JOB-NO] = ApptSeq.[JOB-NO]

        LEFT JOIN #StageHist h
        on j.[JOB-NO] = h.[Job-No] 
        and h.RowNo = 1
dwh	BuildDimRepairAppointment	CREATE PROCEDURE [dwh].[BuildDimRepairAppointment]


AS
	SET NOCOUNT ON

	TRUNCATE TABLE dwh.Dim_RepairAppointment
	
	INSERT INTO dwh.Dim_RepairAppointment
	(
		[JobVisitId], 
		[JobNumber], 
		[JobVisitOrderReference], 
		[JobVisitPlannerComments],
		[JobVisitAppointmentReason], 
		[JobVisitOperativeComments], 
		[JobVisitUserQueue],
		JobVisitCompletionStatus,
		JobVisitCompletionStatusDescription,
		JobVisitTimeWindowStart,
		JobVisitTimeWindowEnd,
		JobVisitStatus,
		JobVisitCurrentAssignmentStart,
		JobVisitCurrentAssignmentEnd,
		JobVisitFollowOnNextTask,
		JobVisitCreatedDate,
		[JobVisitTemplateSkill],
		[JobVisitTemplateSkillGrouped]

	)
	SELECT 
		DrsJob.[USERID] as JobVisitId,
		ocjob.[JOB-NO] as JobNumber, 
		DrsJob.[PARENTID] as [JobVisitOrderReference], 
		--[STATUS], 
		DrsJob.[BD_PLANNER_COMMENTS] as [JobVisitPlannerComments], 
		DrsJob.[BD_APPOINTMENT_SEQUENCE] as [JobVisitAppointmentReason], 
		DrsJob.[BD_OPERATIVE_COMMENTS] as [JobVisitOperativeComments], 
		DrsJob.[BD_USER_QUEUE] as [JobVisitUserQueue],
		DrsJob.BD_TASK_COMPLETION_STAT as JobVisitCompletionStatus,
		csc.Category as JobVisitCompletionStatusDescription,
		DrsJob.GLOBALCURRENTTIMEWINDOW_START as JobVisitTimeWindowStart,
        DrsJob.GLOBALCURRENTTIMEWINDOW_END as JobVisitTimeWindowEnd,
		--DrsJob.[STATUS] as JobVisitStatus,
		COALESCE(stat.MappedVisitStatus, DrsJob.[STATUS]) as JobVisitStatus,
		DrsJob.CURRENTASSIGNMENT_START as JobVisitCurrentAssignmentStart,
		DrsJob.CURRENTASSIGNMENT_END as JobVisitCurrentAssignmentEnd,
		DrsJob.BD_FOLLOW_ON_NEXT_TASK as JobVisitFollowOnNextTask,
		DrsJob.CREATIONDATE as JobVisitCreatedDate,
		DrsJob.MODELID as [JobVisitTemplateSkill],
		skill.GroupedSkillTemplate as [JobVisitTemplateSkillGrouped]

	 FROM
		staging.drs_c_job DrsJob

        --JOIN to OC to only include appointments with jobs
        JOIN staging.[opencontractor_rm-job] OcJob
        ON DrsJob.NAME = ocjob.[JOB-NO]

		LEFT JOIN staging.mapping_CompletionStatusCategory csc
        ON DrsJob.BD_TASK_COMPLETION_STAT = csc.VisitCompletionStatus

		LEFT JOIN staging.mapping_DRSSkillTemplate skill 
		on DrsJob.MODELID = skill.MODELID
		
		LEFT JOIN staging.mapping_DRSVisitStatus stat 
		on DrsJob.STATUS = stat.VisitStatus
dwh	BuildDimRepairAppointmentAudit	CREATE PROCEDURE [dwh].[BuildDimRepairAppointmentAudit]
AS
    
    TRUNCATE TABLE dwh.Dim_RepairAppointmentAudit

	INSERT INTO dwh.Dim_RepairAppointmentAudit (AuditVisitId, AuditAction, AuditUsername, AuditUserEmail, AuditDateTime)
    SELECT 
        [OBJECT_USERID] AS AuditVisitId,
        CASE 
            WHEN [ACTION] = 'create' THEN 'created'
            WHEN [ACTION] = 'modifyandschedule' THEN 'modified and scheduled'
            WHEN [ACTION] = 'cancel' THEN 'suspended'
            WHEN [ACTION] = 'modify' THEN 'modified'
            ELSE [ACTION]  -- Retain original action if no match
        END AS AuditAction,
        [USER_NAME] AS AuditUsername,
        [USER_LOGIN] AS AuditUserEmail,
        [TIME_STAMP] AS AuditDateTime
    FROM staging.drs_opt_sync_histo_job;
dwh	BuildDimRequisition	







-- =============================================
-- Author:      Amit Kakkad
-- Create Date: 23rd May 2024
-- Description: Transforms DimRequisition Data
-- =============================================

CREATE PROCEDURE [dwh].[BuildDimRequisition] 
AS
BEGIN
    -- SET NOCOUNT ON added to prevent extra result sets from
    -- interfering with SELECT statements.
    SET NOCOUNT ON

-- Check if the DimRequisition table exists
IF OBJECT_ID('dwh.Dim_Requisition') IS NOT NULL
BEGIN
    DROP TABLE dwh.Dim_Requisition;
END;


SELECT 
	1 as DimRequisition_Flag,
	RequisitionKey, 
	RequisitionID, 
	RequisitionDescription, 
	RequisitionRef, 
	TimeToFill as DimRequisitionTimeToFill,
	CASE 
		WHEN RequisitionStatus = 'On Hold' AND RequisitionEndDate IS NOT NULL THEN 'Closed'
		WHEN RequisitionStatus = 'Open' AND RequisitionEndDate IS NOT NULL THEN 'Closed'
		ELSE RequisitionStatus
	END AS DimRequisitionStatus,
	CAST(RequisitionStartDate AS DATE) AS RequisitionStartDate, 
	CAST(RequisitionEndDate AS DATE) AS RequisitionEndDate,
	CAST(ClosingDate AS DATE) AS DimRequisitionClosingDate,
	CASE 
		WHEN RequisitionEndDate IS NULL THEN 0 
		ELSE 1 
	END AS DimRequisitionEnd_Flag,
	RequisitionJobTitle as DimRequisitionJobTitle, 
	RequisitionNumber, 
	RequisitionPositionID as DimRequisitionPositionID, 
	ManagerName as DimRequisitionManager, 
	ManagerTitle as DimRequisitionManagerTitle, 
	Speculative as DimRequisitionSpeculative, 
	LoadID as DimRequisitionLoadID, 
	LoadDate as DimRequisitionLoadDate 
INTO dwh.Dim_Requisition
FROM [staging].[mhr_DimRequisition]
;

END;
dwh	BuildDimServicer	CREATE PROC dwh.BuildDimServicer
AS

    TRUNCATE TABLE dwh.Dim_Servicer

    INSERT INTO dwh.Dim_Servicer (Servicer)

    SELECT DISTINCT [Servicer]

    FROM [staging].[keystone_miview_ksi_equipment]

    WHERE Servicer IS NOT NULL

    ORDER BY 1
dwh	BuildDimSOR	CREATE PROCEDURE [dwh].[BuildDimSOR]
AS

    TRUNCATE TABLE dwh.Dim_SOR
    --Create temp table to store SOR information later. Storing this data with primary keys significantly improves runtime.
    --Throughout the query, the use of temp tables with primary keys reduces runtime from 20+ minutes down to around 8 minutes. 
    DROP TABLE IF EXISTS #SorCostsWithDates

    CREATE TABLE #SorCostsWithDates
    (
        SORsKey VARCHAR(30),
        Contract VARCHAR(10),
        SORsCostCode VARCHAR(40),
        SORsDescription VARCHAR(MAX),
        SORsEffectiveFromDate DATE,
        SORsEffectiveToDate DATE,
        SORsTextLine VARCHAR(MAX),
        SORsCosts decimal(38,18)

        PRIMARY KEY CLUSTERED
        (
            SORsKey,
            SORsEffectiveFromDate,
            SORsCostCode
        )

    );

    /***************************************************************************************************************
    Get SOR data and costs
    ***************************************************************************************************************/
    WITH RMSORCOSTS
    AS
    (
        --Get SOR Cost information
        SELECT 
        CONCAT([CONTRACT], '-', [ELEMENT-CODE], '-', CAST([EFF-DATE] AS DATE)) as SORsDateKey,
            CONCAT(CONTRACT, '-', [ELEMENT-CODE]) as SORsKey,
            [COST-CODE] as SORsCostCode,
            COST as SORsCosts,
            CAST([EFF-DATE] AS DATE) as SORsEffectiveFromDate,
            [ELEMENT-CODE] as JobCode,
            CONTRACT as Contract

        FROM
            staging.[opencontractor_rm-sor-costs]

        WHERE 
            [ORG-CODE] ='01' and [ELEMENT-CODE] IS NOT NULL

    ),
    RMSORHEADER
    AS
    (

        --Get SOR header data
        SELECT DISTINCT
            CONCAT(CONTRACT, '-', [ELEMENT-CODE]) as SORsKey,
            DESCRIPTION as SORsDescription,
            [TEXT-LINE] as SORsTextLine

        FROM
            [staging].[opencontractor_rm-sor-header]

        WHERE
            [ORG-CODE] ='01' and len([ELEMENT-CODE])>0

    )
    ,
    SorDataWithPreviousRow
    AS
    (
        /*
        Need to know each period of time for which an SOR was in effect. SOR costs only have an effective from date in the system, so we need to create an effect to date to enable matching from the job to the correct 
        SOR as later on, the job element has to be linked to the SOR that was in effect at the time the job element was logged.
        To do this, order dats by Contract, JobCode, SORsCostCode and SORsEffectiveFromDate in decending order (so most recent SOR first) and then use the lag function to retrieve the Contract, JobCode, 
        SORsCostCode and SORsEffectiveFromDate from the previous record. If Contract, JobCode, SORsCostCode in the current record match the previous record then they are the same the same type of SOR
        for a job, but with different rates depending on the date. So take the effective from date from the previous record (minus one day) and use it as the effective to date for the current record. The most recent
        SOR will end up with an effective end date of today.
        */

        SELECT
            cost.SORsDateKey,
            cost.SORsKey,
            cost.SORsCostCode,
            cost.SORsCosts,
            cost.SORsEffectiveFromDate,
            cost.JobCode,
            cost.Contract,
            header.SORsDescription,
            header.SORsTextLine,
            --LAG gets the value from the previous row.
            LAG(cost.Contract) OVER (ORDER BY Contract, JobCode,SORsCostCode, SORsEffectiveFromDate Desc) AS PreviousRecordContract,
            LAG(cost.JobCode) OVER (ORDER BY Contract, JobCode,SORsCostCode, SORsEffectiveFromDate Desc) AS PreviousRecordJobCode,
            LAG(cost.SORsCostCode) OVER (ORDER BY Contract, JobCode,SORsCostCode, SORsEffectiveFromDate Desc) AS PreviousRecordSORsCostCode,
            LAG(cost.SORsEffectiveFromDate) OVER (ORDER BY Contract, JobCode,SORsCostCode, SORsEffectiveFromDate Desc) AS PreviousRecordEffDate

        FROM RMSORCOSTS cost LEFT JOIN RMSORHEADER header
        ON cost.SORsKey = header.SORsKey

    )

    --CASE statement implements the logic stated in the previous comment. If the current fields matche the previous field values then use the previous date - 1 as the effective end date. 
    INSERT INTO #SorCostsWithDates

    SELECT 
        SORsKey,
        Contract,
        SORsCostCode,
        SORsDescription,
        SORsEffectiveFromDate,
            CASE
            WHEN Contract = PreviousRecordContract AND JobCode = PreviousRecordJobCode AND SORsCostCode = PreviousRecordSORsCostCode THEN DATEADD(dd, -1, PreviousRecordEffDate)
            ELSE CAST(GETDATE() AS DATE)
        END AS SORsEffectiveToDate,
        SORsTextLine,
        SORsCosts

    FROM
        SorDataWithPreviousRow

    /***************************************************************************************************************
    End of SOR data and costs
    ***************************************************************************************************************/

    --Create temp table and insert data for job elements with primary key to improve query speed.
    DROP TABLE IF EXISTS #JobElements
    
    CREATE TABLE #JobElements
    ( 
        
        [JOB-NO] VARCHAR(20), 
        [LINE-NO] VARCHAR(10),
        [ELEMENT-CODE] VARCHAR(20),						
        [LOGGED-UNITS] decimal(38,18),
        [COMPLETED-UNITS] decimal(38,18)

        PRIMARY KEY CLUSTERED
        (
            [JOB-NO],
            [LINE-NO],
            [ELEMENT-CODE]
        )

    )

    INSERT INTO #JobElements

    SELECT
        [JOB-NO],
        [LINE-NO],
        [ELEMENT-CODE],
        [LOGGED-UNITS],
        [COMPLETED-UNITS]
    FROM staging.[opencontractor_rm-job-elements]



    --Create temp table and insert data for jobs with primary key to improve query speed.
    DROP TABLE IF EXISTS #Jobs

    CREATE TABLE #Jobs
    (
        [JOB-NO] VARCHAR(20) PRIMARY KEY,
        CONTRACT VARCHAR(20),
        [DATE-LOGGED] DATETIME2
    )


    INSERT INTO #Jobs

    SELECT [JOB-NO], CONTRACT, [DATE-LOGGED]

    FROM staging.[opencontractor_rm-job] j;

    /********************************************************************************
    Start steps for creating final datset
    ********************************************************************************/

    WITH JobElements
    AS
    (
        --Get job element and job data which will be linked back to SOR data
        --Job elements can have multiple entries, so sum up units for similar records.
        SELECT
            CONCAT(j.[Contract], '-', [ELEMENT-CODE]) as SORsKey,
            je.[JOB-NO] as OrderReference,
            SUM([LOGGED-UNITS]) as SORsLoggedUnits,
            SUM([COMPLETED-UNITS]) as SORsCompletedUnits,
            j.[DATE-LOGGED]
            
        FROM 
            #JobElements je
            
            LEFT JOIN #Jobs j
            ON je.[JOB-NO] = j.[JOB-NO]

        GROUP BY
            CONCAT(j.[Contract], '-', [ELEMENT-CODE]),
            je.[JOB-NO],
            j.[DATE-LOGGED]

    )

    INSERT INTO dwh.Dim_SOR
    (
        SorDimKey,
        SorKey,
        SorCostCode,
        SorElementCode,
        SorJobNumber,
        SorCompletedUnits,
        SorLoggedUnits,
        SorCosts,
        SorTextLine,
        SorDescription
    )
    --link job data to SOR data
    SELECT 
        CONCAT(je.OrderReference, '-', je.SorsKey, '-', stc.SORsCostCode) AS SorDimKey,
        je.SORsKey,
        stc.SORsCostCode,
        right(je.SORsKey, charindex('-', reverse(je.SORsKey)) - 1) as SorElementCode,
        je.OrderReference AS JobNumber,
        je.SORsCompletedUnits,
        je.SORsLoggedUnits,
        stc.SORsCosts,
        stc.SORsTextLine,
        stc.SORsDescription

    FROM 
        JobElements je

        JOIN #SorCostsWithDates stc
        ON je.SORsKey = stc.SORsKey

    WHERE
        --The link between job and SOR is based on when the job element was logged and when the SOR was active. Meaning that the date logged has to fall between the start and end date of the SOR
        je.[DATE-LOGGED] BETWEEN stc.SORsEffectiveFromDate AND stc.SORsEffectiveToDate
dwh	BuildDimSurveyResponse	CREATE PROCEDURE dwh.BuildDimSurveyResponse
AS

    SET NOCOUNT ON

    TRUNCATE TABLE dwh.Dim_SurveyResponse;

    --Retrieve the lastest survey for a job. Multiple surveys for a job are extremly rare and an exception.
    With MaxId
    AS
    (
        SELECT 
            jobnumber, 
            MAX(id) AS MaxId

        FROM
            staging.delighted_surveyresponses

        GROUP BY 
            jobNumber
    )

    INSERT INTO dwh.Dim_SurveyResponse
    (
        SurveyID,
        SurveyType,
        SurveyScore,
        SurveyComment,
        SurveyCreatedDate,
        SurveyUpdatedDate,
        SurveyGender,
        SurveyDisability,
        SurveyEthnicity,
        SurveySexuality,
        SurveyNeighbourhood,
        SurveyBalance,
        SurveyRepairsArea,
        SurveySource,
        SurveyTags,
        JobNumber
    )

    SELECT 
        id AS SurveyID,
        SurveyType,
        Score AS SurveyScore,
        Comment AS SurveyComment,
        --Delighted appears to be using Unix timestamps for dates. To convert to a standard datetime add the timestamp to the date 01/01/1970 00:00:00 which is the start date and time of Unix timstamps.
        --NOTE: This logic may need revisiting if Delighted ever change to the newer Unix timestamp format which is recorded in milliseconds and would be a BIGINT. BIGINT currently isn't supported with DATEADD.
        DATEADD(ss, CAST(created_at AS INT), '19700101') AS SurveyCreatedDate,
        DATEADD(ss, CAST(updated_at AS INT), '19700101') AS SurveyUpdatedDate,
        Gender AS SurveyGender,
        Disability AS SurveyDisability,
        Ethnicity AS SurveyEthnicity,
        Sexuality AS SurveySexuality,
        Neighbourhood AS SurveyNeighbourhood,
        Balance AS SurveyBalance,
        RepairsArea AS SurveyRepairsArea,
        DelightedSource AS SurveySource,
        Tags AS SurveyTags,
        sr.JobNumber

    FROM 
        staging.delighted_surveyresponses sr JOIN MaxId mi
        ON sr.id = mi.MaxId



dwh	BuildDimTradesperson	CREATE PROCEDURE dwh.BuildDimTradesperson
AS
    SET NOCOUNT ON;

    TRUNCATE TABLE dwh.Dim_Tradesperson;

    WITH DrsKironaMapping
    AS
    (
            SELECT 
            'W' + KUA_ATTRIBUTE_VALUE  as DRSUserId, 
            KUA_USR_USERNAME as KironaUserName

        FROM
            staging.jobmanager_kir_user_attributes

        Where 
            KUA_KAT_CODE = 'OPTI_RESOURCE_ID'

    )
        
    INSERT INTO dwh.Dim_Tradesperson
    (
        DRSUserId,
        TradespersonName,
        TradespersonTeamLeader,
        TradespersonTeam,
        TradespersonArea,
        TradespersonTrade
    )

    SELECT 
        DRSUserId,
        KUS_FULL_NAME as TradespersonName,  
        et.IR_TeamLeader AS TradespersonTeamLeader,
        et.IR_Team AS TradespersonTeam,
        et.IR_Area AS TradespersonArea,
        et.IR_Trade AS TradespersonTrade

    FROM 
        staging.jobmanager_kir_users u 
        
        JOIN DrsKironaMapping map
        ON u.KUS_USR_USERNAME = map.KironaUserName

        LEFT JOIN staging.mapping_EmployeeTrade et
        ON DRSUserId = et.ID


    --add blanks
    INSERT INTO dwh.Dim_Tradesperson
    (
        DRSUserId,
        TradespersonName,
        TradespersonTeamLeader,
        TradespersonTeam,
        TradespersonArea,
        TradespersonTrade
    )
    select 
        DISTINCT b.DRSUserId as [DRSUserId], 
        'No Operative' as [TradespersonName], 
        'No Operative - Teamleader' as TradespersonTeamLeader,
        'No Operative - Team' as TradespersonTeam,
        'No Operative - Area' as TradespersonArea,
        'No Operative - Trade' as TradespersonTrade
    from  dwh.Bridging_Tradesperson b 
    left join dwh.Dim_Tradesperson t 
    on b.DRSUserId = t.DRSUserId where t.DRSUserId is null
dwh	BuildDimUnitStructure	







-- =============================================
-- Author:      Amit Kakkad
-- Create Date: 21st May 2024
-- Description: Transforms DimUnitStructure Data
-- =============================================

-- =============================================
-- Author:      Amit Kakkad
-- Create Date: 17th October 2024
-- Description: Update to logic to derive Unit Names - see https://freedcamp.com/view/2728536/tasks/61414306
-- =============================================

CREATE PROCEDURE [dwh].[BuildDimUnitStructure] 
AS
BEGIN
    -- SET NOCOUNT ON added to prevent extra result sets from
    -- interfering with SELECT statements.
    SET NOCOUNT ON

-- Check if the DimUnitStructure table exists
IF OBJECT_ID('dwh.Dim_UnitStructure') IS NOT NULL
BEGIN
    DROP TABLE dwh.Dim_UnitStructure;
END;

SELECT
	UnitStructureKey, 
	StartUnitType, 
	CASE 
		WHEN LEN(ISNULL(UnitName1, '')) < 1 THEN 'No Data'
		ELSE UnitName1 
	END AS UnitName1, 
	CASE 
		WHEN LEN(ISNULL(UnitName2, '')) < 1 THEN 'No Data'
		ELSE UnitName2 
	END AS UnitName2, 
	CASE 
		WHEN LEN(ISNULL(UnitName3, '')) < 1 THEN 'No Data'
		ELSE UnitName3 
	END AS UnitName3, 
	CASE 
		WHEN UnitName3 = 'Executive' THEN 'Executive'
		WHEN UnitName3 = 'Casual Staff' THEN 'Casual Staff'
		WHEN LEN(ISNULL(UnitName4, '')) < 1 THEN 'No Data'
		ELSE UnitName4
	END AS UnitName4,
	CASE 
		WHEN LEN(ISNULL(UnitName5, '')) < 1 THEN 'No Data'
		ELSE UnitName5
	END AS UnitName5, 
	CASE 
		WHEN LEN(ISNULL(UnitName6, '')) < 1 THEN 'No Data'
		ELSE UnitName6
	END AS UnitName6,
	CASE 
		WHEN LEN(ISNULL(UnitName7, '')) < 1 THEN 'No Data'
		ELSE UnitName7
	END AS UnitName7, 
	CASE 
		WHEN LEN(ISNULL(UnitName8, '')) < 1 THEN 'No Data'
		ELSE UnitName8
	END AS UnitName8, 
		CASE 
		WHEN LEN(ISNULL(UnitName9, '')) < 1 THEN 'No Data'
		ELSE UnitName9
	END AS UnitName9, 
	CASE 
		WHEN LEN(ISNULL(UnitName10, '')) < 1 THEN 'No Data'
		ELSE UnitName10
	END AS UnitName10, 
	Leaf, 
	ReportingUnitName, 
	FromDate as UnitStructureFromDate, 
	ToDate as UnitStructureToDate, 
	CurrentFlag as UnitStructureCurrent_Flag
INTO dwh.Dim_UnitStructure
FROM [staging].[mhr_DimUnitStructure];

END;
dwh	BuildDimWorkingPattern	





-- =============================================
-- Author:      Amit Kakkad
-- Create Date: 20th May 2024
-- Description: Transforms DimWorkingPattern Data
-- =============================================

CREATE PROCEDURE [dwh].[BuildDimWorkingPattern] 
AS
BEGIN
    -- SET NOCOUNT ON added to prevent extra result sets from
    -- interfering with SELECT statements.
    SET NOCOUNT ON

-- Check if the DimWorkingPattern table exists
IF OBJECT_ID('dwh.Dim_WorkingPattern') IS NOT NULL
BEGIN
    DROP TABLE dwh.Dim_WorkingPattern;
END;

SELECT
	WorkingPatternKey, 
	WorkingPatternID, 
	FirstDayOfWorkingPattern, 
	WorkingPatternName, 
	Internal, 
	NumberOfDaysInWorkingPattern, 
	NumberOfDaysWorking
INTO dwh.Dim_WorkingPattern
FROM [staging].[mhr_DimWorkingPattern];

END;
dwh	BuildFactAbsenceDaily	






-- =============================================
-- Author:      Amit Kakkad
-- Create Date: 24th May 2024
-- Description: Transforms FactAbsenceDaily Data
-- =============================================
-- =============================================
-- Author:      Amit Kakkad
-- Create Date: 11th Sept 2024
-- Description: Set FactAbsenceFiscalYearNumeric2 based on Dim_CX_Calendar & use IncorrectAbsence_Flag
-- =============================================

CREATE PROCEDURE [dwh].[BuildFactAbsenceDaily] 
AS
BEGIN
    -- SET NOCOUNT ON added to prevent extra result sets from
    -- interfering with SELECT statements.
    SET NOCOUNT ON

-- Check if the FactAbsenceDaily table exists
IF OBJECT_ID('dwh.Fact_AbsenceDaily') IS NOT NULL
BEGIN
    DROP TABLE dwh.Fact_AbsenceDaily;
END;

WITH FactAbsenceDailyPeekLoad AS (
    SELECT Distinct
        a.AbsenceKey, 
        a.AbsenceID,
        CAST(a.AbsenceStartDate AS DATE) AS AbsenceStartDate,
        CAST(a.AbsenceEndDate AS DATE) AS AbsenceEndDate,
        fad.PersonKey,
        LAG(fad.PersonKey) OVER (PARTITION BY fad.PersonKey ORDER BY CAST(a.AbsenceStartDate AS DATE)) AS PrevPersonKey,
        LAG(CAST(a.AbsenceEndDate AS DATE)) OVER (PARTITION BY fad.PersonKey ORDER BY CAST(a.AbsenceStartDate AS DATE)) AS PrevAbsenceEndDate
    FROM 
        [staging].[mhr_DimAbsence] a
    LEFT JOIN 
        (SELECT DISTINCT PersonKey, AbsenceKey FROM [staging].[mhr_FactAbsenceDaily]) fad
        ON a.AbsenceKey = fad.AbsenceKey
    WHERE 
        a.AbsenceType = 'Company Sick Pay'
)
SELECT Distinct
    AbsenceKey, 
    AbsenceID,
    AbsenceStartDate,
    AbsenceEndDate,
    PersonKey,
    CASE 
        WHEN PersonKey = PrevPersonKey AND AbsenceStartDate = DATEADD(DAY, 1, PrevAbsenceEndDate) 
        THEN 1 
        ELSE 0 
    END AS IncorrectAbsence_Flag
INTO #tempFactAbsenceDailyPeekLoad
FROM 
    FactAbsenceDailyPeekLoad;

--IncorrectAbsenceMap:
SELECT Distinct
	AbsenceKey,
	IncorrectAbsence_Flag
INTO #tempIncorrectAbsenceMap
FROM #tempFactAbsenceDailyPeekLoad
Where IncorrectAbsence_Flag=1;

SELECT Distinct
PersonKey, 
PersonID
INTO #TempPersonIdMap
FROM [staging].[mhr_DimPerson]
WHERE CurrentFlag=1;

SELECT Distinct
	1 as FactAbsenceDaily_Flag,
	AbsenceDailyKey, 
	--MakeDate(Left(DateKey,4), Mid(DateKey,5,2) , Right(DateKey,2)) as IndexDate,
	--Month(MakeDate(Left(DateKey,4), Mid(DateKey,5,2) , Right(DateKey,2)) ) & '-' & Year(MakeDate(Left(DateKey,4), Mid(DateKey,5,2) , Right(DateKey,2))) as FactAbsenceMonthYear,
	--num(right(yearname(MakeDate(Left(DateKey,4), Mid(DateKey,5,2) , Right(DateKey,2)),0, 4),4)) as FactAbsenceFiscalYearNumeric2,
    DATEFROMPARTS(
        CAST(SUBSTRING(CAST(DateKey AS VARCHAR(8)), 1, 4) AS INT),  -- Year part
        CAST(SUBSTRING(CAST(DateKey AS VARCHAR(8)), 5, 2) AS INT),  -- Month part
        CAST(SUBSTRING(CAST(DateKey AS VARCHAR(8)), 7, 2) AS INT)   -- Day part
    ) AS IndexDate,
    RIGHT('0' + CAST(MONTH(DATEFROMPARTS(
        CAST(SUBSTRING(CAST(DateKey AS VARCHAR(8)), 1, 4) AS INT),  -- Year part
        CAST(SUBSTRING(CAST(DateKey AS VARCHAR(8)), 5, 2) AS INT),  -- Month part
        CAST(SUBSTRING(CAST(DateKey AS VARCHAR(8)), 7, 2) AS INT)   -- Day part
    )) AS VARCHAR), 2) + '-' + 
    CAST(YEAR(DATEFROMPARTS(
        CAST(SUBSTRING(CAST(DateKey AS VARCHAR(8)), 1, 4) AS INT),  -- Year part
        CAST(SUBSTRING(CAST(DateKey AS VARCHAR(8)), 5, 2) AS INT),  -- Month part
        CAST(SUBSTRING(CAST(DateKey AS VARCHAR(8)), 7, 2) AS INT)   -- Day part
    )) AS VARCHAR) AS FactAbsenceMonthYear,
    --CAST(RIGHT(CAST(YEAR(DATEADD(MONTH, -3, DATEFROMPARTS(
    --    CAST(SUBSTRING(CAST(DateKey AS VARCHAR(8)), 1, 4) AS INT),  -- Year part
    --    CAST(SUBSTRING(CAST(DateKey AS VARCHAR(8)), 5, 2) AS INT),  -- Month part
    --    CAST(SUBSTRING(CAST(DateKey AS VARCHAR(8)), 7, 2) AS INT)   -- Day part
    --))) AS VARCHAR), 4) AS INT) AS FactAbsenceFiscalYearNumeric2,
	DateKey,
	PositionKey, 
	PersonKey, 
	UnitStructureKey, 
	AbsenceKey, 
	AbsenceSchemeKey, 
	NonFTEAbsenceDays, 
	NonFTEAbsenceHours, 
	NonFTEAbsenceOccurrences, 
	NonFTECostOfLeave, 
	NonFTEUnscheduledAbsenceDays, 
	NonFTEUnscheduledAbsenceHours, 
	NonFTEUnscheduledAbsenceOccurrences, 
	NonFTECostOfUnscheduledLeave, 
	NonFTEScheduledAbsenceDays, 
	NonFTEScheduledAbsenceHours, 
	NonFTEScheduledAbsenceOccurrences, 
	NonFTECostOfScheduledLeave, 
	FTEAbsenceDays, 
	FTEAbsenceHours, 
	FTEAbsenceOccurrences, 
	FTECostOfLeave, 
	FTEUnscheduledAbsenceDays, 
	FTEUnscheduledAbsenceHours, 
	FTEUnscheduledAbsenceOccurrences, 
	FTECostOfUnscheduledLeave, 
	FTEScheduledAbsenceDays, 
	FTEScheduledAbsenceHours, 
	FTEScheduledAbsenceOccurrences, 
	FTECostOfScheduledLeave,
	--AutoNumber(RowNo(), AbsenceKey) as AbsenceLengthbyRow
	--AbsenceLengthbyRow as FactAbsenceLengthbyRow,
	--ROW_NUMBER() OVER (PARTITION BY AbsenceKey ORDER BY (SELECT NULL)) AS FactAbsenceLengthbyRow
	0 AS FactAbsenceLengthbyRow, -- Not used
	LoadID as FactAbsenceDailyLoadID, 
	LoadDate as FactAbsenceDailyLoadDate
INTO #TempFactAbsenceDailyFiscal
FROM [staging].[mhr_factabsencedaily] st
Where PersonKey <> '-1'
;

-- Set FactAbsenceFiscalYearNumeric2 based on Dim_CX_Calendar
SELECT Distinct
	fa.*,
	dc.FiscalYearNumeric2 as FactAbsenceFiscalYearNumeric2
INTO #TempFactAbsenceDaily1
FROM #TempFactAbsenceDailyFiscal fa
LEFT JOIN dwh.Dim_CX_Calendar dc ON dc.IndexDate = fa.IndexDate;


SELECT Distinct
	fa.*,
	--ApplyMap('IncorrectAbsenceMap',AbsenceKey,0) as TempAbsenceConsecutive_Flag,
    CASE 
        WHEN IncorrectAbsence_Flag IS NULL OR LEN(IncorrectAbsence_Flag) < 1 THEN 0
        ELSE IncorrectAbsence_Flag
    END AS TempAbsenceConsecutive_Flag
INTO #TempFactAbsenceDaily1a
FROM #TempFactAbsenceDaily1 fa
LEFT JOIN #tempIncorrectAbsenceMap ta ON ta.AbsenceKey = fa.AbsenceKey
;

SELECT Distinct
	tf.*,
	CASE --ApplyMap('PersonIdMap',PersonKey,'No Data') As PersonIdTemp,
		WHEN td.PersonID IS NULL OR LEN(td.PersonID) < 1 THEN 'No Data'
		ELSE td.PersonID
	END AS PersonIdTemp
INTO #TempFactAbsenceDaily2
FROM #TempFactAbsenceDaily1a tf
LEFT JOIN #TempPersonIdMap td ON tf.PersonKey = td.PersonKey
;

SELECT  
	Distinct AbsenceKey, 
	--Max(MakeDate(Left(DateKey,4), Mid(DateKey,5,2) , Right(DateKey,2)))  as AbsenceKeyEndDate
    MAX(DATEFROMPARTS(
        CAST(SUBSTRING(CAST(DateKey AS VARCHAR), 1, 4) AS INT),  -- Year part
        CAST(SUBSTRING(CAST(DateKey AS VARCHAR), 5, 2) AS INT),  -- Month part
        CAST(SUBSTRING(CAST(DateKey AS VARCHAR), 7, 2) AS INT)   -- Day part
    )) AS AbsenceKeyEndDate
INTO #TempMaxAbsenceKeyEndDate
FROM #TempFactAbsenceDaily2
Group by AbsenceKey;

SELECT Distinct
	tf.*,
	td.AbsenceKeyEndDate
INTO #TempFactAbsenceDaily3
FROM #TempFactAbsenceDaily2 tf
LEFT JOIN #TempMaxAbsenceKeyEndDate td ON tf.AbsenceKey = td.AbsenceKey
;

SELECT Distinct
	AbsenceKey,
	AbsenceStartDate,
	AbsenceEndDate
INTO #TempDimAbsenceDates
--FROM dwh.Dim_Absence
FROM [staging].[mhr_DimAbsence]
--Where DimAbsence_Flag = 1
;

SELECT Distinct
	tf.*,
	td.AbsenceStartDate as FactAbsenceStartDate,
	td.AbsenceEndDate as FactAbsenceEndDate
INTO #TempFactAbsenceDaily4
FROM #TempFactAbsenceDaily3 tf
LEFT JOIN #TempDimAbsenceDates td ON tf.AbsenceKey = td.AbsenceKey
;

SELECT Distinct
	Max(IndexDate) as IndexDate,
	FactAbsenceMonthYear,
	AbsenceKey,
	1 as FactAbsenceMonthEnd_Flag
INTO #TempFactAbsenceMonthYear
FROM #TempFactAbsenceDaily4
Group by FactAbsenceMonthYear, AbsenceKey;

SELECT Distinct
	tf.*,
	td.FactAbsenceMonthEnd_Flag
INTO #TempFactAbsenceDaily5
FROM #TempFactAbsenceDaily4 tf
LEFT JOIN #TempFactAbsenceMonthYear td ON tf.AbsenceKey = td.AbsenceKey
;

SELECT Distinct
	Max(IndexDate) as IndexDate,
	FactAbsenceFiscalYearNumeric2,
	AbsenceKey,
	1 as FactAbsenceYearEnd_Flag
INTO #TempFactAbsenceFiscalYearNumeric2
FROM #TempFactAbsenceDaily5
Group by FactAbsenceFiscalYearNumeric2, AbsenceKey;

SELECT Distinct
	tf.*,
	td.FactAbsenceYearEnd_Flag
INTO #TempFactAbsenceDaily6
FROM #TempFactAbsenceDaily5 tf
LEFT JOIN #TempFactAbsenceFiscalYearNumeric2 td ON tf.AbsenceKey = td.AbsenceKey
;

SELECT Distinct
	FactAbsenceMonthYear,
	AbsenceKey,
	Sum(FactAbsenceDaily_Flag) as FactAbsenceLengthMonthEnd,
	sum(NonFTEAbsenceDays) as FactAbsenceNonFTEAbsenceDaysMonthEnd
INTO #TempFactAbsenceSum
FROM #TempFactAbsenceDaily6
Group by FactAbsenceMonthYear, AbsenceKey;

SELECT DISTINCT
    tf.*,
    td.FactAbsenceLengthMonthEnd,
    td.FactAbsenceNonFTEAbsenceDaysMonthEnd
INTO #TempFactAbsenceDaily7
FROM #TempFactAbsenceDaily6 tf
LEFT JOIN #TempFactAbsenceSum td 
    ON CAST(tf.AbsenceKey AS VARCHAR) + tf.FactAbsenceMonthYear = CAST(td.AbsenceKey AS VARCHAR) + td.FactAbsenceMonthYear
;

SELECT Distinct
	FactAbsenceFiscalYearNumeric2,
	AbsenceKey,
	Sum(FactAbsenceDaily_Flag) as FactAbsenceLengthFiscalYearEnd
INTO #TempFactAbsenceLengthFiscalYearEnd
FROM #TempFactAbsenceDaily7
Group by FactAbsenceFiscalYearNumeric2, AbsenceKey;

SELECT DISTINCT
    tf.*,
    td.FactAbsenceLengthFiscalYearEnd
INTO #TempFactAbsenceDaily8
FROM #TempFactAbsenceDaily7 tf
LEFT JOIN #TempFactAbsenceLengthFiscalYearEnd td 
	ON CAST(tf.AbsenceKey AS VARCHAR)  + CAST(tf.FactAbsenceFiscalYearNumeric2 AS VARCHAR)  = CAST(td.AbsenceKey AS VARCHAR)  + CAST(td.FactAbsenceFiscalYearNumeric2 AS VARCHAR) 
;

SELECT DISTINCT
	a.*,
    CASE 
        WHEN FactAbsenceLengthCalculatedByIfStatement <= 20 THEN 'Short' 
        WHEN FactAbsenceLengthCalculatedByIfStatement > 20 THEN 'Long' 
        ELSE 'No Data' 
    END AS FactAbsenceTermCalculatedByIfStatement,
	'Not Used' as FactAbsenceTermCalculatedByDateMax
INTO dwh.Fact_AbsenceDaily
FROM
(
SELECT DISTINCT
    tf.*,
    CASE 
        WHEN DATEDIFF(DAY, FactAbsenceStartDate, IndexDate) + 1 <= 20 THEN 'Short'
        WHEN DATEDIFF(DAY, FactAbsenceStartDate, IndexDate) + 1 > 20 THEN 'Long'
        ELSE 'No Data'
    END AS FactAbsenceTermCalculatedByDate,
    
    CASE 
        WHEN DATEDIFF(DAY, FactAbsenceStartDate, IndexDate) + 1 <= 20 THEN '1'
        WHEN DATEDIFF(DAY, FactAbsenceStartDate, IndexDate) + 1 > 20 THEN '2'
        ELSE '0'
    END AS FactAbsenceTermValueCalculatedByDate,

    DATEDIFF(DAY, FactAbsenceStartDate, IndexDate) + 1 AS FactAbsenceLengthbyDate,

    CASE 
        WHEN DATEDIFF(DAY, FactAbsenceStartDate, AbsenceKeyEndDate) + 1 <= 20 THEN 'Short'
        WHEN DATEDIFF(DAY, FactAbsenceStartDate, AbsenceKeyEndDate) + 1 > 20 THEN 'Long'
        ELSE 'No Data'
    END AS FactAbsenceTermCalculatedByAbsenceKey,

    DATEDIFF(DAY, FactAbsenceStartDate, AbsenceKeyEndDate) + 1 AS FactAbsenceLengthCalculatedByAbsenceKey,

    CASE 
        WHEN LEN(FactAbsenceEndDate) > 0 THEN DATEDIFF(DAY, FactAbsenceStartDate, FactAbsenceEndDate) + 1
        ELSE DATEDIFF(DAY, FactAbsenceStartDate, IndexDate) + 1
    END AS FactAbsenceLengthCalculatedByIfStatement,

    CASE 
        WHEN FactAbsenceLengthbyRow <= 20 THEN 'Short'
        WHEN FactAbsenceLengthbyRow > 20 THEN 'Long'
        ELSE 'No Data'
    END AS FactAbsenceTermCalculatedbyRow
FROM #TempFactAbsenceDaily8 tf
) a ;

END;
dwh	BuildFactAccountsByPeriod	-- =============================================
-- Author:      Ben Reeve
-- Create Date: 14/03/2025
-- Description: Builds Fact data for Accounts by period.
--				25/03/2025 - Ben Reeve - code completely re-written.
-- =============================================
CREATE PROCEDURE [dwh].[BuildFactAccountsByPeriod]
AS
BEGIN
    -- SET NOCOUNT ON added to prevent extra result sets from
    -- interfering with SELECT statements.
    SET NOCOUNT ON

	DROP TABLE IF EXISTS #CalendarPeriods;
	DROP TABLE IF EXISTS #AccountPeriods;
	DROP TABLE IF EXISTS #WriteOff;
	DROP TABLE IF EXISTS #Transaction;
	DROP TABLE IF EXISTS #TransactionWithCalendar;
	DROP TABLE IF EXISTS #TransactionsByPeriod;
	DROP TABLE IF EXISTS #Agreements;
	DROP TABLE IF EXISTS #AccountsByAgreementPeriods;
	DROP TABLE IF EXISTS #AccountPeriodsFinal;
	DROP TABLE IF EXISTS #AgreementsByPeriod;
	DROP TABLE IF EXISTS #TransactionHistory;
	DROP TABLE IF EXISTS #AccountPeriodTotals;
	DROP TABLE IF EXISTS #tempFactAccountsByPeriod;


	--Get calendar data and join to dim calendar.
	SELECT 
		rcy.CalendarId, 
		c.Description,
		rcy.Year, 
		rcp.PeriodNumber, 
		rcp.PeriodStartDate,
		rcp.PeriodEndDate,
		cp.DimCalendarPeriodId,
		CASE
			WHEN GETDATE() BETWEEN rcp.PeriodStartDate AND rcp.PeriodEndDate THEN 1
			ELSE 0
		END AS IsCurrentPeriod

	INTO
		#CalendarPeriods

	FROM 
		staging.cx_rentcalendar c
		
		JOIN staging.cx_rentcalendaryear rcy
		ON c.CalendarId = rcy.CalendarId

		JOIN staging.cx_rentcalendarperiod rcp
		ON rcy.CalenderYearId = rcp.CalendarYearId

		JOIN dwh.Dim_CalendarPeriod cp
		ON rcp.CalendarPeriodId = cp.CalendarPeriodId;


	/*************************
	**************************
	ACCOUNT BALANCE TABLE DATA
	**************************
	**************************/

	--Get dates for the first and last account balance records. This will give the date range for when transactions occured.

	WITH AccountDates --31,791
	AS
	(
		SELECT 
			AccountId, 
			MIN(CAST(BalanceFromDate AS DATE)) AS AccountFrom, 
			MAX(ISNULL(CAST(BalanceToDate AS DATE), CAST(GETDATE() AS DATE))) AS AccountTo

		FROM 
			staging.cx_rentaccountbalance

		GROUP BY 
			AccountId

	),
	--For each account, get the calendar attached to the rent agreement episode.
	AccountDatesWithCalendar
	AS
	(
		SELECT DISTINCT 
			ad.AccountId, 
			ad.AccountFrom, 
			ISNULL(CAST(racc.EffectiveToDate AS DATE), ad.AccountTo) AS AccountToDate,
			rae.CalendarId

		FROM 
			AccountDates ad 
		
			JOIN staging.cx_rentagreementaccount raa
			ON ad.AccountId = raa.AccountId

			JOIN staging.cx_rentagreementepisode rae
			ON raa.AgreementEpisodeId = rae.AgreementEpisodeId

			JOIN staging.cx_rentaccount racc
			ON raa.AccountId = racc.AccountId

		WHERE 
			raa.MainAccount = 1
			AND (rae.EffectiveFromDate < rae.EffectiveToDate OR rae.EffectiveToDate IS NULL)

	)

	--Based on the calendar, get all periods that cover the date range that the account had activity.
	SELECT 
		adwc.AccountId, 
		adwc.AccountFrom, 
		adwc.AccountToDate,
		adwc.CalendarId,
		cp.DimCalendarPeriodId

	INTO #AccountPeriods

	FROM
		AccountDatesWithCalendar adwc

		JOIN #CalendarPeriods cp
		ON adwc.CalendarId = cp.CalendarId
		AND (adwc.AccountFrom BETWEEN cp.PeriodStartDate AND cp.PeriodEndDate --void start date falls inbetween calendar period start and end (calendar periods the void starts)
				OR adwc.AccountToDate BETWEEN cp.PeriodStartDate AND cp.PeriodEndDate --void end date falls inbetween calendar period start and end (calendar periods the void ends)
				OR cp.PeriodStartDate BETWEEN adwc.AccountFrom AND adwc.AccountToDate) --Calendar period start date falls inbetween void start and end date (calendar periods starting during void period)
				--Last OR commented out as believed to be unnecessary.
				--OR cp.PeriodEndDate BETWEEN v.StartDate AND ISNULL(v.EndDate, CAST(GETDATE() AS DATE)) --Calendar period end date f


	/*************************
	**************************
	  TRANSACTION TABLE DATA
	**************************
	**************************/


	--Get transactions of type "write off"
	SELECT DISTINCT 
		rt.TransactionId, 
		rt.PostingDate

	INTO #WriteOff

	FROM 
		staging.cx_renttransactionelement rte 
	
		JOIN staging.cx_rentelement re
		ON rte.ElementId = re.ElementId

		JOIN staging.cx_renttransaction rt
		ON rte.TransactionId = rt.TransactionId

	WHERE 
		WriteOff = 1


	--Get transaction data and link to write off data
	SELECT 
		rt.TransactionId,
		rt.AccountId,
		rt.TransactionTypeId,
		rt.PostingDate,
		rt.TotalValue,
		rt.WrittenOff,
		CASE
			WHEN rt.PaymentTypeId = 18 THEN 1
			ELSE 0
		END AS DirectDebit

	INTO
		#Transaction

	FROM 
		staging.cx_renttransaction rt LEFT JOIN #WriteOff wo
		ON rt.TransactionId = wo.TransactionId

	--Link transactions to rent account episode to get calendar
	--This is needed because calendar in RentTransaction does not always match the calendar for the agreement.

	SELECT DISTINCT
		tr.TransactionId,
		tr.AccountId,
		tr.TransactionTypeId,
		tr.PostingDate,
		tr.TotalValue,
		tr.WrittenOff,
		tr.DirectDebit,
		rae.CalendarId

	INTO 
		#TransactionWithCalendar

	FROM 
		#Transaction tr 

		JOIN staging.cx_rentagreementaccount raa
		ON tr.AccountId = raa.AccountId

		JOIN staging.cx_rentagreementepisode rae
		ON raa.AgreementEpisodeId = rae.AgreementEpisodeId

		--JOIN staging.cx_rentaccount racc
		--ON raa.AccountId = racc.AccountId

	WHERE 
		raa.MainAccount = 1
		AND (rae.EffectiveFromDate < rae.EffectiveToDate OR rae.EffectiveToDate IS NULL);


	--Link transaction data to calendars to get periods
	SELECT
		twc.TransactionId,
		twc.AccountId,
		twc.TransactionTypeId,
		twc.PostingDate,
		twc.TotalValue,
		twc.WrittenOff,
		twc.DirectDebit,
		cp.DimCalendarPeriodId

	INTO
		#TransactionsByPeriod

	FROM
		#TransactionWithCalendar twc

		JOIN #CalendarPeriods cp
		ON twc.CalendarId = cp.CalendarId
		AND twc.PostingDate BETWEEN cp.PeriodStartDate AND cp.PeriodEndDate;



	/*************************
	**************************
		  AGREEMENT DATA
	**************************
	**************************/


	--Get Rent agreements data

	WITH Warrants --CTE to get accounts with warrants
	AS
	(
		SELECT DISTINCT 
			AccountId, 
			WarrantGranted AS HasWarrant

		FROM 
			staging.cx_renteviction

		WHERE 
			WarrantGranted = 1
			AND ISNULL(DisabledEviction, 0) = 0
	)

	--Get agreement data
	SELECT DISTINCT 
		rae.AgreementId,
		--rae.AgreementEpisodeId,
		rass.AssetId,
		rae.CalendarId,
		ra.AccountId,
		rat.Description AS RentAccountType,
		agr.StartDate,
		agr.EndDate,
		CASE
			WHEN agr.EndDate < GETDATE() THEN 0
			ELSE 1
		END AS IsCurrentAccount,
		HasWarrant

		INTO
			#Agreements

	FROM 
		staging.cx_rentagreement agr

		JOIN staging.cx_rentagreementepisode rae 
		ON agr.AgreementId = rae.AgreementId

		JOIN staging.cx_rentagreementasset rass
		ON rae.AgreementId = rass.AgreementId
	
		JOIN staging.cx_rentagreementaccount raa
		ON rae.AgreementEpisodeId = raa.AgreementEpisodeId
		AND raa.MainAccount = 1

		JOIN staging.cx_rentaccount ra
		ON raa.AccountId = ra.AccountId

		JOIN staging.cx_rentaccounttype rat
		ON ra.AccountTypeId = rat.AccountTypeId

		LEFT JOIN Warrants w
		ON ra.AccountId = w.AccountId

	WHERE
		(rae.EffectiveToDate IS NULL
		OR rae.EffectiveToDate > rae.EffectiveFromDate)
	
		AND (agr.EndDate IS NULL
		OR agr.EndDate > agr.StartDate);



	--Get all periods based on agreement dates and agreement calendar
	SELECT 
		ag.AccountId,
		cp.DimCalendarPeriodId

	INTO
		#AccountsByAgreementPeriods

	FROM 
		#Agreements ag 
		
		JOIN #CalendarPeriods cp
		ON ag.CalendarId = cp.CalendarId
		AND (ag.StartDate BETWEEN cp.PeriodStartDate AND cp.PeriodEndDate --void start date falls inbetween calendar period start and end (calendar periods the void starts)
			OR ISNULL(ag.EndDate, CAST(GETDATE() AS DATE)) BETWEEN cp.PeriodStartDate AND cp.PeriodEndDate --void end date falls inbetween calendar period start and end (calendar periods the void ends)
			OR cp.PeriodStartDate BETWEEN ag.StartDate AND ISNULL(ag.EndDate, CAST(GETDATE() AS DATE)) )



	--Link agreement periods with account balance data via full outer join using account id
	--For an account, this will give all periods that the agreement was active for AND all periods where a transaction of some sort occurs
	--Ensuring that there is a full timeline of periods from either when the account started or the first account transaction was made

	SELECT 
		ISNULL(ap.AccountId, aap.AccountId) AS AccountId,
		ISNULL(ap.DimCalendarPeriodId, aap.DimCalendarPeriodId) AS DimCalendarPeriodId

	INTO
		#AccountPeriodsFinal

	FROM
		#AccountPeriods ap 
		
		FULL OUTER JOIN #AccountsByAgreementPeriods aap
		ON ap.AccountId = aap.AccountId
		AND ap.DimCalendarPeriodId = aap.DimCalendarPeriodId;



	--Query to start matching agreements back to all possible periods

	--Get arrangements along with the min and max date from the schedule to define the period the arrangement was active for.
	With ArrangemenetStartEnd
	AS
	(	--Get start and end dates for arrangement
		SELECT 
			rarr.AccountID,
			rarr.ArrangementId, 
			MIN(rarrs.Date) AS StartDate, 
			MAX(rarrs.Date) AS EndDate

		FROM 
			staging.cx_rentarrangement rarr 
			
			JOIN staging.cx_rentarrangementschedule rarrs
			ON rarr.ArrangementId = rarrs.ArrangementID

		WHERE 
			rarr.ArrangementStatus IN (1,2)

		GROUP BY 
			rarr.AccountID,rarr.ArrangementId
	),
	--Get arrangements by possible periods
	AccountArrangmentPeriods
	AS
	(	
		SELECT DISTINCT 
			AccountID, 
			DimCalendarPeriodId, 
			1 AS HasLiveArrangement

		FROM 
			ArrangemenetStartEnd wa 
			
			JOIN #CalendarPeriods cp
			ON wa.StartDate BETWEEN cp.PeriodStartDate AND cp.PeriodEndDate --start date falls inbetween calendar period start and end (calendar periods the void starts)
				OR wa.EndDate BETWEEN cp.PeriodStartDate AND cp.PeriodEndDate --end date falls inbetween calendar period start and end (calendar periods the void ends)
				OR cp.PeriodStartDate BETWEEN wa.StartDate AND wa.EndDate
	),
	CourtPeriods
	AS
	(	--Get court data by possible periods
		SELECT DISTINCT 
			AccountId, 
			1 AS HasCourt, 
			cp.DimCalendarPeriodId

		FROM 
			staging.cx_rentcourt rc 
			
			LEFT JOIN #CalendarPeriods cp
			ON CourtAppDate BETWEEN cp.PeriodStartDate AND cp.PeriodEndDate

		WHERE 
			ISNULL(DisabledCourt, 0) = 0

	)



	--Final query to get agreements by all periods for the linked account
	--This ensures we have every period the agreement was active for regardless of if any financial transactions occurred.
	--Also link to arrangement and court data
	SELECT 
		ag.AgreementId,
		--ag.AgreementEpisodeId,
		ag.AssetId,
		ag.AccountId,
		ag.RentAccountType,
		ag.StartDate,
		ag.EndDate,
		ag.IsCurrentAccount,
		ag.HasWarrant,
		aap.HasLiveArrangement,
		crt.HasCourt,
		cp.CalendarId, 
		cp.Description,
		cp.Year, 
		cp.PeriodNumber, 
		cp.PeriodStartDate,
		cp.PeriodEndDate,
		cp.DimCalendarPeriodId,
		cp.IsCurrentPeriod

	INTO
		#AgreementsByPeriod

		FROM #Agreements ag 
		
		JOIN #AccountPeriodsFinal apf
		ON ag.AccountId = apf.AccountId

		JOIN #CalendarPeriods cp
		ON apf.DimCalendarPeriodId = cp.DimCalendarPeriodId 

		LEFT JOIN AccountArrangmentPeriods aap
		ON ag.AccountId = aap.AccountID
		AND apf.DimCalendarPeriodId = aap.DimCalendarPeriodId

		LEFT JOIN CourtPeriods crt
		ON ag.AccountId = crt.AccountId
		AND apf.DimCalendarPeriodId = crt.DimCalendarPeriodId


	/*************************
	**************************
		 FACT TABLE DATA
	**************************
	**************************/

	--Link agreement data to transactions
	SELECT 
		abp.AgreementId,
		abp.AssetId,
		abp.AccountId,
		abp.RentAccountType,
		abp.StartDate,
		abp.EndDate,
		abp.IsCurrentAccount,
		abp.HasWarrant,
		abp.HasCourt,
		abp.HasLiveArrangement,
		abp.CalendarId, 
		abp.Description,
		abp.Year, 
		abp.PeriodNumber, 
		abp.PeriodStartDate,
		abp.PeriodEndDate,
		abp.DimCalendarPeriodId,
		abp.IsCurrentPeriod,
		tbp.TransactionId,
		tbp.TransactionTypeId,
		CAST(tbp.PostingDate AS DATE) AS PostingDate,
		tbp.TotalValue,
		tbp.WrittenOff,
		tbp.DirectDebit

	INTO
		#TransactionHistory

	FROM
		#AgreementsByPeriod abp 
		
		LEFT JOIN #TransactionsByPeriod tbp
		ON abp.AccountId = tbp.AccountId
		AND abp.DimCalendarPeriodId = tbp.DimCalendarPeriodId



	--Aggregate transaction data
	SELECT 
		AgreementId,
		AssetId,
		AccountId,
		RentAccountType,
		StartDate,
		EndDate,
		IsCurrentAccount,
		HasWarrant,
		HasCourt,
		HasLiveArrangement,
		CalendarId,
		Description,
		Year,
		PeriodNumber,
		PeriodStartDate,
		PeriodEndDate,
		DimCalendarPeriodId,
		IsCurrentPeriod,
		SUM(CASE WHEN TransactionTypeId = 1 THEN TotalValue ELSE 0 END) AS SumCharges,
		SUM(CASE WHEN TransactionTypeId = 2 THEN TotalValue ELSE 0 END) AS SumAdjustments,
		SUM(CASE WHEN TransactionTypeId = 3 THEN TotalValue ELSE 0 END) AS SumPayments,
		SUM(CASE WHEN TransactionTypeId = 4 THEN TotalValue ELSE 0 END) AS SumTransfers,
		SUM(CASE WHEN TransactionTypeId = 5 THEN TotalValue ELSE 0 END) AS SumInvoices,
		SUM(CASE WHEN TransactionTypeId = 6 THEN TotalValue ELSE 0 END) AS SumCredits,
		SUM(ISNULL(TotalValue, 0)) AS SumTotalTransactions,
		SUM(CASE WHEN WrittenOff = 1 THEN TotalValue ELSE 0 END) AS SumWriteOff,
		MAX(ISNULL(DirectDebit, 0)) AS IsDD --Just in case its possible for there to somehow be a direct debit and non-direct debit payment in the same period.

	INTO
		#AccountPeriodTotals

	FROM 
		#TransactionHistory

	GROUP BY
		AgreementId,
		AssetId,
		AccountId,
		RentAccountType,
		StartDate,
		EndDate,
		IsCurrentAccount,
		HasWarrant,
		HasCourt,
		HasLiveArrangement,
		CalendarId,
		Description,
		Year,
		PeriodNumber,
		PeriodStartDate,
		PeriodEndDate,
		DimCalendarPeriodId,
		IsCurrentPeriod


	--Create account balance totals
	SELECT 
		*,
		--SUM via window functions to create rolling totals for balances
		SUM(SumTotalTransactions) OVER (PARTITION BY AccountId ORDER BY AccountId, PeriodStartDate) - SumTotalTransactions AS BalanceBroughtForward, 
		SUM(SumTotalTransactions) OVER (PARTITION BY AccountId ORDER BY AccountId, PeriodStartDate) AS BalanceCarriedForward

	INTO 
		#tempFactAccountsByPeriod

	FROM 
		#AccountPeriodTotals

	ORDER BY 
		AccountId, 
		PeriodStartDate;



	--Truncate Fact table
	TRUNCATE TABLE dwh.Fact_AccountsByPeriod;


	--Final query to build and insert fact data
	--Get latest period to flag in final SELECT
	With LatestAccountPeriod
	AS
	(
		SELECT
			AccountId,
			MAX(PeriodStartDate) AS MaxStartDate

		FROM 
			#AgreementsByPeriod

		GROUP BY
			AccountId
	)

	INSERT INTO dwh.Fact_AccountsByPeriod
	(
		DimCalendarPeriodId,
		FactAgreementId,
		DimAssetId,
		CxAccountId,
		AccountType,
		IsCurrentAccount,
		BalanceBroughtForward,
		DebitBalanceBroughtForward,
		CreditBalanceBroughtForward,
		SumCharges,
		SumAdjustments,
		SumPayments,
		SumTransfers,
		SumInvoices,
		SumCreditNotes,
		SumTotalTransactions,
		SumWriteOff,
		BalanceCarriedForward,
		DebitBalanceCarriedForward,
		CreditBalanceCarriedForward,
		FormerDebtAge,
		HasLiveArrangement,
		HasWarrant,
		HasCourt,
		IsDD,
		IsCurrentPeriod,
		IsLatest,
		CxAgreementId,
		CxAssetId,
		CxCalendarPeriodId,
		IsFormerAccount,
		Stage

	)

	SELECT
		ap.DimCalendarPeriodId,
		agr.FactAgreementId,
		ass.DimAssetId,
		ap.AccountId AS CxAccountId,
		ap.RentAccountType AS AccountType,
		ap.IsCurrentAccount,
		ap.BalanceBroughtForward,
		CASE 
			WHEN ap.BalanceBroughtForward > 0 THEN ap.BalanceBroughtForward
			ELSE 0
		END AS DebitBalanceBroughtForward,
		CASE 
			WHEN ap.BalanceBroughtForward < 0 THEN ap.BalanceBroughtForward
			ELSE 0
		END AS CreditBalanceBroughtForward,
		ap.SumCharges,
		ap.SumAdjustments,
		ap.SumPayments,
		ap.SumTransfers,
		ap.SumInvoices,
		ap.SumCredits AS SumCreditNotes,
		ap.SumTotalTransactions,
		ap.SumWriteOff,
		ap.BalanceCarriedForward,
			CASE 
			WHEN ap.BalanceCarriedForward > 0 THEN ap.BalanceCarriedForward
			ELSE 0
		END AS DebitBalanceCarriedForward,
		CASE 
			WHEN ap.BalanceCarriedForward < 0 THEN ap.BalanceCarriedForward
			ELSE 0
		END AS CreditBalanceCarriedForward,
		CASE
			WHEN ap.EndDate > ap.PeriodStartDate THEN DATEDIFF(dd, ap.PeriodStartDate, ap.EndDate)
			ELSE 0
		END AS FormerDebtAge,
		ap.HasLiveArrangement,
		ap.HasWarrant,
		ap.HasCourt,
		ap.IsDD,
		ap.IsCurrentPeriod,
		CASE
			WHEN lap.MaxStartDate IS NOT NULL THEN 1
			ELSE 0
		END AS IsLatest,
		ap.AgreementId,
		ap.AssetId,
		ap.DimCalendarPeriodId,
		CASE 
			WHEN ap.IsCurrentAccount = 0 then 1 
			ELSE 0 
		END as IsFormerAccount,
		''

	FROM 
		#tempFactAccountsByPeriod ap 
		
		LEFT JOIN dwh.Fact_Agreement agr
		ON ap.AgreementId = agr.FactAgreementId

		LEFT JOIN dwh.Dim_Asset ass
		ON ap.AssetId = ass.CxAssetId

		LEFT JOIN LatestAccountPeriod lap
		ON ap.AccountId = lap.AccountId
		AND ap.PeriodStartDate = lap.MaxStartDate;

	DROP TABLE #CalendarPeriods;
	DROP TABLE #AccountPeriods;
	DROP TABLE #WriteOff;
	DROP TABLE #Transaction;
	DROP TABLE #TransactionWithCalendar;
	DROP TABLE #TransactionsByPeriod;
	DROP TABLE #Agreements;
	DROP TABLE #AccountsByAgreementPeriods;
	DROP TABLE #AccountPeriodsFinal;
	DROP TABLE #AgreementsByPeriod;
	DROP TABLE #TransactionHistory;
	DROP TABLE #AccountPeriodTotals;
	DROP TABLE #tempFactAccountsByPeriod;

END
dwh	BuildFactAgreement	
-- =============================================
-- Author:      Carl Hunter
-- Create Date: 07/03/2025
-- Description: Builds Fact Agreement
-- =============================================



CREATE PROCEDURE [dwh].[BuildFactAgreement]
AS
BEGIN

    SET NOCOUNT ON

    TRUNCATE TABLE dwh.Fact_Agreement

	DROP TABLE IF EXISTS #StartReasonLookup 

	SELECT LookupReference, Description as StartReason
	INTO #StartReasonLookup
	FROM staging.cx_lookup
	WHERE LookupTypeId = 68 --and EffectiveToDate is null

	DROP TABLE IF EXISTS #EndReasonLookup 

	SELECT LookupReference, Description as EndReason
	INTO #EndReasonLookup
	FROM staging.cx_lookup
	WHERE LookupTypeId = 69 --and EffectiveToDate is null

	DROP TABLE IF EXISTS #TerminationReasonLookup 

	SELECT LookupReference, Description as TerminationReason
	INTO #TerminationReasonLookup
	FROM staging.cx_lookup
	WHERE LookupTypeId = 70 --and EffectiveToDate is null
	
	DROP TABLE IF EXISTS #BalanceAtClosing

	;WITH MaxAccountBalanceId as 
	(
		SELECT e.AgreementId as AgreementId, Max(AccountBalanceId) as AccountBalanceId
		FROM staging.cx_rentagreementepisode e 
		LEFT JOIN staging.cx_RentAgreementAccount a on e.AgreementEpisodeId = a.AgreementEpisodeId
		LEFT JOIN staging.cx_rentaccountbalance b on a.AccountId = b.AccountId
		GROUP BY e.AgreementId
	)
	SELECT m.AgreementId, b.*
	INTO #BalanceAtClosing
	FROM staging.cx_rentaccountbalance b
	LEFT JOIN MaxAccountBalanceId m on m.AccountBalanceId = b.AccountBalanceId
	WHERE m.AccountBalanceId = b.AccountBalanceId
	
	
	
	
	DROP TABLE IF EXISTS #MinMaxStatus

	;WITH MinMax as 
	(
		select AgreementId, MIN(AgreementEpisodeId) as FirstEpisodeId, MAX(AgreementEpisodeId) as LastEpisodeId from staging.cx_rentagreementepisode GROUP BY AgreementId
	),
	MinMaxStatus as 
	(
		SELECT m.AgreementId, FirstEpisodeId, first.StartReasonId, LastEpisodeId, last.EndReasonId
		FROM MinMax m
		LEFT JOIN staging.cx_rentagreementepisode first on m.FirstEpisodeId = first.AgreementEpisodeId 
		LEFT JOIN staging.cx_rentagreementepisode last on m.LastEpisodeId = last.AgreementEpisodeId 
	)
	SELECT AgreementId, FirstEpisodeId, StartReasonId, LastEpisodeId, EndReasonId
	INTO #MinMaxStatus
	FROM MinMaxStatus;




	DROP TABLE IF EXISTS #CommunityAlarm

	SELECT DISTINCT 
		ra.AgreementId

	INTO
		#CommunityAlarm
	
	FROM 
		staging.cx_rentagreement ra 
		
		JOIN staging.cx_rentagreementitem rai
		ON ra.AgreementId = rai.AgreementId

		JOIN staging.cx_rentagreementcharge rac
		ON rai.AgreementItemId = rac.AgreementItemId

		JOIN staging.cx_rentagreementchargeelement race
		ON rac.AgreementChargeId = race.AgreementChargeId

		JOIN staging.cx_rentelement re
		ON race.ElementId = re.ElementId

		WHERE re.Description LIKE '%Community Alarm%'
		AND rac.EffectiveToDate IS NULL
	

	DROP TABLE IF EXISTS #EarliestComplaint

	;WITH RankedCases AS (
		SELECT
		a.AgreementId,
		c.CaseId,
		c.CaseCreatedDate,
		ROW_NUMBER() OVER (PARTITION BY a.AgreementId ORDER BY c.CaseCreatedDate) AS rn
		FROM staging.cx_rentagreementepisode a 
		LEFT JOIN staging.cx_contactgroupmember cgm 
		ON a.ContactGroupId = cgm.ContactGroupId
		LEFT JOIN dwh.dim_case c 
		ON cgm.ContactId = c.ContactId
		WHERE c.CaseGenericType IN ('Report a new complaint', 'Log a complaint')
		--AND a.AgreementTenureTypeId = 5
		AND c.CaseCreatedDate >= cgm.EffectiveFromDate
		AND (c.CaseCreatedDate < cgm.EffectiveToDate OR cgm.EffectiveToDate IS NULL)
		AND c.CaseCreatedDate >= a.EffectiveFromDate
		AND (c.CaseCreatedDate < a.EffectiveToDate OR a.EffectiveToDate IS NULL)
	)
	SELECT AgreementId, CaseId, CaseCreatedDate
	INTO #EarliestComplaint
	FROM RankedCases
	WHERE rn = 1;

	DROP TABLE IF EXISTS #FloatingSupport 

	;with FloatingSupportCases as 
	(
		select 
		c.CaseId as CaseId,
		c.CaseCreatedDate as CaseCreatedDate,
		c.ContactId as ContactId
	from dwh.Fact_CaseTask fct 
	join dwh.Fact_Form ff on fct.CxTaskId = ff.ParentEntityId
		and ff.ParentEntityType = 'CRM Task'
	join dwh.Fact_FormAnswers f on ff.FactFormId = f.FactFormId
	join dwh.Dim_Case c on fct.CxCaseId = c.CaseId and CaseGenericType = 'Referral Case'
	where 
		f.answer = 'floating support'
		and f.IsLatest = 1
	),
	FloatingSupportAgreement as
	(
	SELECT
		a.AgreementId,
		c.CaseId,
		c.CaseCreatedDate,
		ROW_NUMBER() OVER (PARTITION BY a.AgreementId ORDER BY c.CaseCreatedDate) AS rn
	FROM staging.cx_rentagreementepisode a 
	LEFT JOIN staging.cx_contactgroupmember cgm 
	ON a.ContactGroupId = cgm.ContactGroupId
	LEFT JOIN FloatingSupportCases c 
	ON cgm.ContactId = c.ContactId
	WHERE
	c.CaseCreatedDate >= cgm.EffectiveFromDate
	AND (c.CaseCreatedDate < cgm.EffectiveToDate OR cgm.EffectiveToDate IS NULL)
	AND c.CaseCreatedDate >= a.EffectiveFromDate
	AND (c.CaseCreatedDate < a.EffectiveToDate OR a.EffectiveToDate IS NULL)
	)
	SELECT AgreementId, CaseId, CaseCreatedDate
	INTO #FloatingSupport
	FROM FloatingSupportAgreement
	WHERE rn = 1;

	--select * from #FloatingSupport


	DROP TABLE IF EXISTS #AgreementTemp 

	
	SELECT 
		ra.AgreementId as CxAgreementId, 
		ra.AgreementReference as AgreementReference, 
		ra.StartDate as StartDate, 
		ra.EndDate as TerminationDate,
		ra.ProposedEndDate as PotentialEndDate, 
		ra.DateNoticeReceived as NoticeReceivedDate, 
		ra.TerminationReasonId,
		t.TerminationReason,
		CASE WHEN (ra.ProposedEndDate < GETDATE() AND ra.EndDate IS NULL) THEN 1 ELSE 0 END as TerminationOverdue,
		raa.AssetId,
		m.FirstEpisodeId,
		m.StartReasonId,
		s.StartReason,
		m.LastEpisodeId,
		m.EndReasonId,
		e.EndReason,
		CASE WHEN ra.EndDate <= GETDATE() THEN bal.ClosingBalance ELSE NULL END as [BalanceOnTermination],
		CASE WHEN DATEDIFF(day,ra.StartDate,ra.EndDate) <= 365 THEN 1 ELSE 0 END as FailedWithin1Year,
		CASE WHEN DATEDIFF(day,ra.StartDate,ra.EndDate) <= 730 THEN 1 ELSE 0 END as FailedWithin2Years,
		CASE WHEN CAST(GETDATE() AS DATE) >= ra.StartDate AND (ra.EndDate IS NULL OR GETDATE() <= ra.EndDate) THEN 1 ELSE 0 END AS IsCurrent,
		CASE WHEN ra.StartDate >= GETDATE() AND raa.EffectiveToDate IS NULL THEN 1 ELSE 0 END AS IsFuture,
		CASE WHEN ra.EndDate <= GETDATE() THEN 1 ELSE 0 END as IsTerminated,
		CASE WHEN ca.AgreementId IS NOT NULL THEN 1 ELSE 0 END AS HasCommunityAlarm,
		ec.CaseId AS [EarliestComplaintCaseId],
		ec.CaseCreatedDate AS [EarliestComplaintDate],
		fs.CaseId as [FloatingSupportCase],
		CASE WHEN fs.CaseId is not null THEN 1 ELSE 0 END as [HadFloatingSupport],
		CASE
			WHEN rae.AgreementEpisodeId = m.FirstEpisodeId THEN 1
			ELSE 0
		END AS FirstLet
	INTO #AgreementTemp 
	FROM staging.cx_rentagreement ra
	LEFT JOIN staging.cx_rentagreementasset raa on ra.AgreementId = raa.AgreementId
	LEFT JOIN #MinMaxStatus m on ra.AgreementId = m.AgreementId
	LEFT JOIN #StartReasonLookup s on m.StartReasonId = s.LookupReference
	LEFT JOIN #EndReasonLookup e on m.EndReasonId = e.LookupReference
	LEFT JOIN #TerminationReasonLookup t on ra.TerminationReasonId = t.LookupReference
	LEFT JOIN #BalanceAtClosing bal on ra.AgreementId = bal.AgreementId
	LEFT JOIN #CommunityAlarm ca ON ra.AgreementId = ca.AgreementId
	LEFT JOIN #EarliestComplaint ec on ra.AgreementId = ec.AgreementId
	LEFT JOIN #FloatingSupport fs on ra.AgreementId = fs.AgreementId
	LEFT JOIN staging.cx_rentagreementepisode rae ON ra.AgreementId = rae.AgreementId AND rae.EffectiveToDate IS NULL AND rae.EffectiveFromDate <= CAST(GETDATE() AS DATE)

	--WHERE FirstEpisodeId <> LastEpisodeId

	--select top 1000 * from #AgreementTemp Where CxAgreementId = 6905


	INSERT INTO [dwh].[Fact_Agreement]
           ([DimAssetId]
           ,[CxAgreementId]
           ,[PreviousCxVoidEpisodeId]
           ,[FollowingCxVoidEpisodeId]
           ,[AgreementReference]
           ,[StartDate]
           ,[PotentialEndDate]
           ,[NoticeReceivedDate]
           ,[TerminationOverdue]
           ,[TerminationDate]
           ,[SatisfactionWithConditionOfNewHome]
           ,[EarliestComplaintDate]
           ,[EpisodeStartReason]
           ,[EpisodeEndReason]
           ,[TerminationReason]
           ,[FailedWithin1Years]
           ,[FailedWithin2Years]
           ,[BalanceOnTermination]
           ,[HasCommunityAlarm]
           ,[HadFloatingSupport]
           ,[IsCurrent]
		   ,IsFuture
           ,[IsTerminated]
		   ,CxAssetId
		   ,FirstLet)
     SELECT 
		AssetId as [DimAssetId],
		CxAgreementId as CxAgreementId, 
		NULL as [PreviousCxVoidEpisodeId],
		NULL as [FollowingCxVoidEpisodeId],
		AgreementReference as AgreementReference, 
		StartDate as StartDate, 
		PotentialEndDate as PotentialEndDate, 
		NoticeReceivedDate as NoticeReceivedDate, 
		TerminationOverdue,
		TerminationDate,
		NULL as [SatisfactionWithConditionOfNewHome],
		[EarliestComplaintDate] as [EarliestComplaintDate],
		StartReason as [EpisodeStartReason],
		EndReason as [EpisodeEndReason],
		TerminationReason as [TerminationReason],
		FailedWithin1Year,
		FailedWithin2Years,
		[BalanceOnTermination] as [BalanceOnTermination],
		HasCommunityAlarm as [HasCommunityAlarm],
		[HadFloatingSupport] as [HadFloatingSupport],
		IsCurrent,
		IsFuture,
		IsTerminated,
		AssetId,
		FirstLet
	FROM #AgreementTemp 


/*
DROP TABLE IF EXISTS #AgreementEpisodeStartEnd
	--Find out the first and last agreement episodes based on the AgreementId and return the reason ids - match these to lookup table.
	;WITH FirstAgreementEpisode as 
	(
		SELECT AgreementId, min(AgreementEpisodeId)as AgreementEpisodeId FROM staging.cx_rentagreementepisode GROUP BY AgreementId
	),
	LastAgreementEpisode as 
	(
		SELECT AgreementId, max(AgreementEpisodeId)as AgreementEpisodeId FROM staging.cx_rentagreementepisode GROUP BY AgreementId
	),
	StartEndReason as
	(
		select fae.AgreementId as AgreementId, rae.StartReasonId as StartReasonId, rae2.EndReasonId as EndReasonId
		--, sr.StartReason as StartReason, er.Description as EndReason
		--INTO #AgreementEpisodeStartEnd
		from FirstAgreementEpisode fae 
		left join LastAgreementEpisode lae on fae.AgreementId = lae.AgreementId 
		left join staging.cx_rentagreementepisode rae on fae.AgreementEpisodeId = rae.AgreementEpisodeId
		left join staging.cx_rentagreementepisode rae2 on lae.AgreementEpisodeId = rae.AgreementEpisodeId
		--left join StartReason sr on rae.StartReasonId = sr.LookupReference 
		--left join EndReason er on rae.StartReasonId = er.LookupReference 
	)
	--Select LookupReference, Description as StartReason from staging.cx_lookup where LookupTypeId = 68 and EffectiveToDate is null --Start Reason

	select AgreementId, StartReasonId, EndReasonId--, s.StartReason, e.EndReason  
	INTO #AgreementEpisodeStartEnd
	from StartEndReason 
	--left join #StartReasonLookup s on StartReasonId = s.LookupReference
	--left join #EndReasonLookup e  on EndReasonId = e.LookupReference
	

	--Select LookupReference, Description as StartReason from staging.cx_lookup where LookupTypeId = 68 and EffectiveToDate is null 
	
	
	--select * from #AgreementEpisodeStartEnd where AgreementId = 21481
	
*/

END
dwh	BuildFactAgreementEpisode	



CREATE PROCEDURE [dwh].[BuildFactAgreementEpisode]
AS
BEGIN

    SET NOCOUNT ON

    TRUNCATE TABLE dwh.Fact_AgreementEpisode

	DROP TABLE IF EXISTS #StartReasonLookup 

	SELECT LookupReference, Description as StartReason
	INTO #StartReasonLookup
	FROM staging.cx_lookup
	WHERE LookupTypeId = 68 and EffectiveToDate is null

	DROP TABLE IF EXISTS #EndReasonLookup 

	SELECT LookupReference, Description as EndReason
	INTO #EndReasonLookup
	FROM staging.cx_lookup
	WHERE LookupTypeId = 69 and EffectiveToDate is null

	
	INSERT INTO [dwh].[Fact_AgreementEpisode]
           ([DimAssetId]
           ,[FactAgreementId]
           ,[CxAgreementEpisodeId]
           ,[ContactGroupId]
           ,[StartDate]
           ,[EndDate]
           ,[EpisodeStartReason]
           ,[EpisodeEndReason]
           ,[IsAssignment]
           ,[IsMEX]
           ,[IsSuccession]
           ,[IsManagementLet]
           ,[IsCurrent]
		   ,CxAgreementId
		   ,CxAssetId)
	SELECT 
		a.AssetId AS DimAssetId, 
		e.AgreementId AS FactAgreementId, 
		e.AgreementEpisodeId AS CxAgreementEpisodeId,
		e.ContactGroupId,
		CAST(e.EffectiveFromDate AS DATE) AS StartDate,
		CAST(e.EffectiveToDate AS DATE) AS EndDate,
		sr.StartReason AS EpisodeStartReason,
		er.EndReason AS EpisodeEndReason,
		CASE WHEN e.EndReasonId IN (3,4,5) THEN 1 ELSE 0 END AS IsAssignment,
		CASE WHEN e.EndReasonId IN (6) THEN 1 ELSE 0 END AS IsMEX,
		CASE WHEN e.EndReasonId IN (2) THEN 1 ELSE 0 END AS IsSuccession,
		CASE WHEN e.EndReasonId IN (9) THEN 1 ELSE 0 END AS IsManagementLet,
		CASE 
			WHEN GETDATE() >= e.EffectiveFromDate 
				 AND (e.EffectiveToDate IS NULL OR GETDATE() <= e.EffectiveToDate) 
			THEN 1 
			ELSE 0 
		END AS IsCurrent,
		a.AgreementId,
		a.AssetId
	FROM
		staging.cx_rentagreementepisode e 
		LEFT JOIN staging.cx_rentagreementasset a ON e.AgreementId = a.AgreementId
		LEFT JOIN #StartReasonLookup sr ON e.StartReasonId = sr.LookupReference
		LEFT JOIN #EndReasonLookup er ON e.EndReasonId = er.LookupReference
	--WHERE 
	--	e.AgreementId = 21481;




END
dwh	BuildFactApplication	-- =============================================
-- Author:      Ben Reeve
-- Create Date: 23/05/2025
-- Description: Builds Fact Application
-- =============================================
CREATE PROCEDURE [dwh].[BuildFactApplication]
AS
BEGIN
    -- SET NOCOUNT ON added to prevent extra result sets from
    -- interfering with SELECT statements.
    SET NOCOUNT ON

	TRUNCATE TABLE dwh.Fact_Application;

	WITH LatestStatus
	AS
	(
		SELECT 
			ApplicationId, 
			MAX(EffectiveFromDate) AS MaxDate

		FROM 
			staging.cx_allocationapplicationstatus

		GROUP BY 
			ApplicationId
	)

	INSERT INTO dwh.Fact_Application
	(
		CxApplicationId,
		DimContactGroupId,
		Reference,
		ApplicationDate,
		Status,
		CxContactGroupId
	)


	SELECT
		aa.ApplicationId AS CxApplicationId,
		dcg.DimContactGroupId,
		aa.Reference,
		aa.ApplicationDate,
		sl110.[Description] AS Status,
		aa.ContactGroupId AS CxContactGroupId

	FROM 
		staging.cx_AllocationApplication aa

		JOIN dwh.Dim_ContactGroup dcg
		ON aa.ContactGroupId = dcg.CxContactGroupId

		JOIN LatestStatus ls
		ON aa.ApplicationId = ls.ApplicationId

		JOIN staging.cx_allocationapplicationstatus aas
		ON ls.ApplicationId = aas.ApplicationId
		AND ls.MaxDate = aas.EffectiveFromDate

		JOIN staging.cx_systemlookup sl110
		ON aas.StatusId = sl110.LookupReference
		AND sl110.LookupTypeId = 110

END
dwh	BuildFactApplicationStatus	-- =============================================
-- Author:      Ben Reeve
-- Create Date: 23/05/2025
-- Description: Builds Fact Application Status
-- =============================================
CREATE PROCEDURE [dwh].[BuildFactApplicationStatus]
AS
BEGIN
    -- SET NOCOUNT ON added to prevent extra result sets from
    -- interfering with SELECT statements.
    SET NOCOUNT ON

	TRUNCATE TABLE dwh.Fact_ApplicationStatus;

	WITH LatestStatus
	AS
	(
		SELECT 
			ApplicationId, 
			MAX(EffectiveFromDate) AS MaxDate

		FROM 
			staging.cx_allocationapplicationstatus

		GROUP BY 
			ApplicationId
	)

	INSERT INTO dwh.Fact_ApplicationStatus
	(
		FactApplicationId,
		CxApplicationId,
		StatusId,
		Status,
		EffectiveFrom,
		EffectiveTo,
		IsCurrent,
		IsLatest
	)

	SELECT
		a.FactApplicationId,
		aa.ApplicationId AS CxApplicationId,
		aas.StatusId,
		sl110.[Description] AS Status,
		aas.EffectiveFromDate AS EffectiveFrom,
		aas.EffectiveToDate AS EffectiveTo,
		CASE
			WHEN aas.EffectiveToDate IS NULL THEN 1
			ELSE 0
		END AS IsCurrent,
		CASE
			WHEN ls.MaxDate IS NOT NULL THEN 1
			ELSE 0
		END AS IsLatest

	FROM 
		staging.cx_AllocationApplication aa

		JOIN staging.cx_allocationapplicationstatus aas
		ON aa.ApplicationId = aas.ApplicationId

		JOIN staging.cx_systemlookup sl110
		ON aas.StatusId = sl110.LookupReference
		AND sl110.LookupTypeId = 110

		LEFT JOIN LatestStatus ls
		ON aas.ApplicationId = ls.ApplicationId
		AND aas.EffectiveFromDate = ls.MaxDate

		JOIN dwh.Fact_Application a
		ON aa.ApplicationId = a.CxApplicationId

END
dwh	BuildFactAsbCase	-- =============================================
-- Author:      Ben Reeve
-- Create Date: 25/03/2025
-- Description: Code for build of Fact_ASBCase
--				07/04/2025 - Ben Reeve - Added Lettings area and Management Area from Asset Characteristic to cover 'Patch' in warehouse spec
-- =============================================
CREATE PROCEDURE [dwh].[BuildFactAsbCase]
AS
BEGIN
    -- SET NOCOUNT ON added to prevent extra result sets from
    -- interfering with SELECT statements.
    SET NOCOUNT ON

	TRUNCATE TABLE dwh.Fact_ASBCase;

	WITH AssetPatch
	AS
	(
		SELECT
			p1.AssetId,
			[Lettings Area],
			[Management Area]

		FROM
			(
				SELECT 
					ac.AssetId, 
					act.[Description] AS CharacteristicDescription, 
					ul.[Description] AS CharacteristicValue

				FROM 
					staging.cx_assetcharacteristic ac 
					
					LEFT JOIN staging.cx_AssetCharacteristicType act
					ON ac.CharacteristicTypeId = act.AssetCharacteristicTypeId

					LEFT JOIN staging.cx_udflookup ul
					ON act.LookupTableId = LookupTypeId
					AND IntValue  = ul.LookupReference

				WHERE 
					act.[Description] IN ('Lettings Area','Management Area')
					AND ac.EffectiveToDate IS NULL
					AND ul.EffectiveToDate IS NULL
			) SubQuery

		PIVOT
		(
			MIN(CharacteristicValue) --MIN does nothing as there won't be more than one value. There just has to be an agg function for a pivot to work.
			FOR CharacteristicDescription IN 
			(
				[Lettings Area],
				[Management Area]
			)
		) p1
	),
	AsbCase
	AS
	(
		SELECT DISTINCT
			sc.CaseId AS CxCaseId,
			sc.CaseReference,
			ap.[Lettings Area],
			ap.[Management Area],
			ISNULL(act.Description, '') AS Description, --needs aggregating into a single string
			sc.ActualStartDate AS DateCreated,
			sc.ActualEndDate AS DateCompleted,
			CASE
				WHEN sc.ActualEndDate IS NOT NULL THEN DATEDIFF(dd, sc.ActualStartDate, sc.ActualEndDate)
				ELSE NULL
			END AS DaysToComplete,
			CASE
				WHEN act.ASBTypeId = 3 THEN 1
				ELSE 0
			END AS IsDV,
			CASE
				WHEN act.ASBTypeId = 6 THEN 1
				ELSE 0
			END AS IsHateCrime, aa.AssetId

		FROM 
			staging.cx_systemcase sc

			LEFT JOIN staging.cx_asbcategory ac
			ON sc.CaseId = ac.CaseId

			LEFT JOIN staging.cx_asbcategorytype act
			ON ac.CategoryTypeId = act.CategoryTypeId

			LEFT JOIN staging.cx_assetaddress aa
			ON sc.ASBPrimaryAddressId = aa.AddressId

			LEFT JOIN AssetPatch ap
			ON aa.AssetId = ap.AssetId

		WHERE
			sc.ClassificationId = 2
	)

	INSERT INTO dwh.Fact_ASBCase
	(
		CxCaseId,
		CaseReference,
		AssetLettingsArea,
		AssetManagementArea,
		Categories,
		DateCreated,
		DateCompleted,
		DaysToComplete,
		IsDV,
		IsHateCrime
	)

	SELECT 
		ac.CxCaseId,
		ac.CaseReference,
		ac.[Lettings Area],
		ac.[Management Area],
		STRING_AGG(ac.Description, '; ') AS Categories,
		ac.DateCreated,
		ac.DateCompleted,
		ac.DaysToComplete,
		MAX(ac.IsDV) AS IsDv,
		MAX(ac.IsHateCrime) AS HateCrime

	FROM
		AsbCase ac

	GROUP BY
		ac.CxCaseId,
		ac.CaseReference,
		ac.[Lettings Area],
		ac.[Management Area],
		ac.DateCreated,
		ac.DateCompleted,
		ac.DaysToComplete
END
dwh	BuildFactAsbCaseStatus	-- =============================================
-- Author:      Ben Reeve
-- Create Date: 27/03/2025
-- Description: Create data for Fact_ASBCaseStatus
-- =============================================
CREATE PROCEDURE dwh.BuildFactAsbCaseStatus
AS
BEGIN
    -- SET NOCOUNT ON added to prevent extra result sets from
    -- interfering with SELECT statements.
    SET NOCOUNT ON

	TRUNCATE TABLE dwh.Fact_ASBCaseStatus;

	INSERT INTO dwh.Fact_ASBCaseStatus
	(
		FactASBCaseId,
		CxCaseId,
		CxCaseStatusId,
		StartDate,
		EndDate,
		Status,
		NoticeCreated,
		CourtCreated,
		EvictionCreated,
		HasLegalAction
	)

	SELECT
		asb.FactASBCaseId,
		asb.CxCaseId,
		scs.CaseStatusId AS CxCaseStatusId,
		StatusDate AS StartDate,
		LEAD(StatusDate) OVER (PARTITION BY FactASBCaseId ORDER BY FactASBCaseId, StatusDate) AS EndDate,
		sl.Description AS Status,
		CASE
			WHEN an.CaseId IS NOT NULL THEN 1
			ELSE 0
		END AS NoticeCreated,
		CASE
			WHEN ac.CaseId IS NOT NULL THEN 1
			ELSE 0
		END  AS CourtCreated,
		CASE
			WHEN ae.CaseId IS NOT NULL THEN 1
			ELSE 0
		END  AS EvictionCreated,
		CASE
			WHEN (an.CaseId IS NOT NULL AND ISNULL(an.DisabledNotice, 0) = 0)
					OR (ac.CaseId IS NOT NULL AND ISNULL(ac.DisabledCourt, 0) = 0)
					OR (ae.CaseId IS NOT NULL AND ISNULL(ae.DisabledEviction, 0) = 0) THEN 1
			ELSE 0
		END AS HasLegalAction

	FROM 
		dwh.Fact_ASBCase asb 
	
		JOIN staging.cx_systemcasestatus scs
		ON asb.CxCaseId = scs.CaseId

		JOIN staging.cx_systemlookup sl
		ON scs.StatusId = sl.LookupReference

		LEFT JOIN staging.cx_asbnotice an
		ON asb.CxCaseId = an.CaseId

		LEFT JOIN staging.cx_asbcourt ac
		ON asb.CxCaseId = ac.CaseId

		LEFT JOIN staging.cx_asbeviction ae
		ON asb.CxCaseId = ae.CaseId

		WHERE sl.LookupTypeId = 137

	ORDER BY 
		FactASBCaseId, StatusDate

END
dwh	BuildFactAssetStatus	




CREATE PROCEDURE [dwh].[BuildFactAssetStatus]
AS
BEGIN

    SET NOCOUNT ON

    TRUNCATE TABLE dwh.Fact_AssetStatus


	DROP TABLE IF EXISTS #Adapted 
	
	SELECT UPRN, 
		COUNT(ComponentID) as CountOfComponenets, 
		coalesce(min(InstallationDate),Min(SurveyDate)) as ComponentDate --get either the earliest installation date or the earliest survey
	INTO #Adapted 
	FROM [staging].[keystone_miview_asset_surveyattributes]
	WHERE ComponentID in (4106866,4106929) -- 4106866 = Adaptations --4106929 = Disabled Adaptations
	GROUP BY UPRN
  
	DROP TABLE IF EXISTS #FactAssetStatusTemp 
	
	;WITH MaxAssetStatus AS
	(
		select AssetId, Max(EffectiveFromDate) as EffectiveFromDate   
		FROM staging.cx_assetstatus
		GROUP BY AssetId
	),
	AssetManagementAgreementType AS
	(
		select AssetId, ame.EffectiveFromDate, ame.EffectiveToDate, ame.ManagementAgreementTypeId, amat.Description, amat.Comments 
		from [staging].[cx_assetmanagementepisode] ame 
		left join [staging].[cx_assetmanagementagreementtype] amat on ame.ManagementAgreementTypeId = amat.ManagementAgreementTypeId 
		where (GETDATE() >= ame.EffectiveFromDate AND (ame.EffectiveToDate IS NULL OR GETDATE() <= ame.EffectiveToDate))
	)
	SELECT 
		a.AssetId as DimAssetId,
		a.AssetId as CxAssetId,
		ast.StatusId as CxStatusId,
		amat.ManagementAgreementTypeId,
		amat.Description as AssetManagementAgreementType,
		ast.StatusCodeId as StatusCodeId,
		ac.StatusCode as StatusDescription,
		ac.MasterStatusCodeId as MasterStatusCodeId,
		amsc.Description as MasterStatusDescription,
		CASE WHEN adapt.CountOfComponenets > 0 THEN 1 ELSE 0 END as [Adapted],
		adapt.ComponentDate as [AdaptedDate],
		CAST(ast.EffectiveFromDate as DATE) as EffectiveFrom,
		CAST(ast.EffectiveToDate as DATE)  as EffectiveTo,
		CASE WHEN ast.EffectiveFromDate = m.EffectiveFromDate THEN 1 else 0 END as IsLatest,
		--null as IsLatest,
		CASE WHEN GETDATE() >= ast.EffectiveFromDate AND (ast.EffectiveToDate IS NULL OR GETDATE() <= ast.EffectiveToDate) THEN 1 ELSE 0 END AS IsCurrent
	INTO #FactAssetStatusTemp 
	FROM staging.cx_assetstatus ast 
	LEFT JOIN staging.cx_AssetStatusCode ac on ast.StatusCodeId = ac.StatusCodeId
	LEFT JOIN staging.cx_AssetMasterStatusCode amsc on ac.MasterStatusCodeId = amsc.MasterStatusCodeId
	LEFT JOIN MaxAssetStatus m on ast.AssetId = m.AssetId
	LEFT JOIN AssetManagementAgreementType amat on ast.assetid = amat.assetid
	LEFT JOIN staging.cx_asset a on ast.AssetId = a.AssetId
	LEFT JOIN #Adapted adapt on a.AssetReference = adapt.UPRN
	order by ast.AssetId, ast.EffectiveFromDate


	INSERT INTO [dwh].[Fact_AssetStatus]
           ([DimAssetId]
           ,[CxStatusId]
           ,[CxAssetId]
           ,[AssetManagementAgreementTypeId]
           ,[AssetManagementAgreementType]
           ,[StatusCodeId]
           ,[StatusDescription]
           ,[MasterStatusCodeId]
           ,[MasterStatusDescription]
           ,[Adapted]
           ,[AdaptedDate]
           ,[EffectiveFrom]
           ,[EffectiveTo]
           ,[IsCurrent]
           ,[IsLive])
     SELECT 
		DimAssetId,
        CxStatusId,
		CxAssetId,
        ManagementAgreementTypeId,
        AssetManagementAgreementType,
        StatusCodeId,
        StatusDescription,
        MasterStatusCodeId,
        MasterStatusDescription,
        [Adapted],
		[AdaptedDate],
        EffectiveFrom,
        EffectiveTo,
		IsCurrent,
        IsLatest
	FROM #FactAssetStatusTemp


END
dwh	BuildFactBreathingSpaceCase	-- =============================================
-- Author:      Ben Reeve
-- Create Date: 11/04/2025
-- Description: Builds Fact Breathing Space Case
-- =============================================
CREATE PROCEDURE [dwh].[BuildFactBreathingSpaceCase]
AS
BEGIN
    -- SET NOCOUNT ON added to prevent extra result sets from
    -- interfering with SELECT statements.
    SET NOCOUNT ON

	TRUNCATE TABLE dwh.Fact_BreathingSpaceCase;

	INSERT INTO dwh.Fact_BreathingSpaceCase
	(
		ContactId,
		StartDate,
		EndDate,
		Is30Days,
		Is60Days,
		Is90Days,
		IsMixedDuration,
		BreathingSpaceInformation
	)


	SELECT 
		cu.ContactId,
		COALESCE(cu.BreathingSpaceThirtyDaysStartDate, cu.BreathingSpaceSixtyDaysStartDate, cu.BreathingSpaceNinetyDaysStartDate) AS StartDate,
		COALESCE(cu.BreathingSpaceThirtyDaysEndDate, cu.BreathingSpaceSixtyDaysEndDate, cu.BreathingSpaceNinetyDaysEndDate) AS EndDate,
		CASE 
			--30 day start and end date are populated
			WHEN cu.BreathingSpaceThirtyDaysStartDate IS NOT NULL AND cu.BreathingSpaceThirtyDaysEndDate IS NOT NULL THEN 1
			--30 day start date is populated and no other end dates populated
			WHEN cu.BreathingSpaceThirtyDaysStartDate IS NOT NULL AND COALESCE(cu.BreathingSpaceSixtyDaysEndDate, cu.BreathingSpaceNinetyDaysEndDate) IS NULL THEN 1
			--30 day end date is populated and no other start dates populated
			WHEN cu.BreathingSpaceThirtyDaysEndDate IS NOT NULL AND COALESCE(cu.BreathingSpaceSixtyDaysStartDate, cu.BreathingSpaceNinetyDaysStartDate) IS NULL THEN 1
			ELSE 0
		END AS Is30Days,
		CASE --Logic as above
			WHEN cu.BreathingSpaceSixtyDaysStartDate IS NOT NULL AND cu.BreathingSpaceSixtyDaysEndDate IS NOT NULL THEN 1
			WHEN cu.BreathingSpaceSixtyDaysStartDate IS NOT NULL AND COALESCE(cu.BreathingSpaceThirtyDaysEndDate, cu.BreathingSpaceNinetyDaysEndDate) IS NULL THEN 1
			WHEN cu.BreathingSpaceSixtyDaysEndDate IS NOT NULL AND COALESCE(cu.BreathingSpaceThirtyDaysStartDate, cu.BreathingSpaceNinetyDaysStartDate) IS NULL THEN 1
			ELSE 0
		END AS Is60Days,
		CASE --Logic as above
			WHEN cu.BreathingSpaceNinetyDaysStartDate IS NOT NULL AND cu.BreathingSpaceNinetyDaysEndDate IS NOT NULL THEN 1
			WHEN cu.BreathingSpaceNinetyDaysStartDate IS NOT NULL AND COALESCE(cu.BreathingSpaceThirtyDaysEndDate, cu.BreathingSpaceSixtyDaysEndDate) IS NULL THEN 1
			WHEN cu.BreathingSpaceNinetyDaysEndDate IS NOT NULL AND COALESCE(cu.BreathingSpaceThirtyDaysStartDate, cu.BreathingSpaceSixtyDaysStartDate) IS NULL THEN 1
			ELSE 0
		END AS Is90Days,
		CASE
			--Covers data errors where start and end date columns or not correctly match duration e.g. 30 day start date with a sixty day end date
			WHEN cu.BreathingSpaceThirtyDaysStartDate IS NOT NULL AND COALESCE(cu.BreathingSpaceSixtyDaysEndDate, cu.BreathingSpaceNinetyDaysEndDate) IS NOT NULL THEN 1
			WHEN cu.BreathingSpaceSixtyDaysStartDate IS NOT NULL AND COALESCE(cu.BreathingSpaceThirtyDaysEndDate, cu.BreathingSpaceNinetyDaysEndDate) IS NOT NULL THEN 1
			WHEN cu.BreathingSpaceNinetyDaysStartDate IS NOT NULL AND COALESCE(cu.BreathingSpaceThirtyDaysEndDate, cu.BreathingSpaceSixtyDaysEndDate) IS NOT NULL THEN 1
			WHEN cu.BreathingSpaceThirtyDaysEndDate IS NOT NULL AND COALESCE(cu.BreathingSpaceSixtyDaysStartDate, cu.BreathingSpaceNinetyDaysStartDate) IS NOT NULL THEN 1
			WHEN cu.BreathingSpaceSixtyDaysEndDate IS NOT NULL AND COALESCE(cu.BreathingSpaceThirtyDaysStartDate, cu.BreathingSpaceNinetyDaysStartDate) IS NOT NULL THEN 1
			WHEN cu.BreathingSpaceNinetyDaysEndDate IS NOT NULL AND COALESCE(cu.BreathingSpaceThirtyDaysStartDate, cu.BreathingSpaceSixtyDaysStartDate) IS NOT NULL THEN 1
			ELSE 0
		END AS IsMixedDuration,
		cu.BreathingSpaceInformation

	FROM 
		staging.cx_contact_user cu 

	WHERE 
		(
			BreathingSpaceThirtyDaysStartDate IS NOT NULL
			OR BreathingSpaceThirtyDaysEndDate IS NOT NULL
			OR BreathingSpaceSixtyDaysStartDate IS NOT NULL
			OR BreathingSpaceSixtyDaysEndDate IS NOT NULL
			OR BreathingSpaceNinetyDaysStartDate IS NOT NULL
			OR BreathingSpaceNinetyDaysEndDate IS NOT NULL
			OR BreathingSpaceInformation IS NOT NULL
		)

END
dwh	BuildFactCase	-- =============================================
-- Author:      Ben Reeve
-- Create Date: 01/04/2025
-- Description: Builds Fact Case. Adapted from script provided by Jim Walker at iStride Ltd.
-- =============================================
CREATE PROCEDURE [dwh].[BuildFactCase]
AS
BEGIN
    -- SET NOCOUNT ON added to prevent extra result sets from
    -- interfering with SELECT statements.
    SET NOCOUNT ON

	TRUNCATE TABLE dwh.Fact_Case;

	With CaseData
	AS
	(
		SELECT 
			--row_number() over (partition by (select null) order by (select null)) AS FactCaseId, 
			sc.CaseId AS CxCaseId, 
			sc.ClassificationId AS ClassificationId, 
			sc.CRMSubjectId AS CRMSubjectId , 
			crms.Description AS CRMSubject, 
			sc.GenericCaseTypeId AS GenericCaseTypeId, 
			gct.Description AS GenericCaseType, 
			sc.ASBOverallPriorityTypeId AS ASBOverallPriorityTypeId, 
			apt.Description AS ASBPriorityType, 
			sc.FeedbackBusinessAreaId AS FeedbackBusinessAreaId, 
			fba.Description AS FeedbackBusinessArea, 
			CASE 
				WHEN sc.ClassificationId = 1 THEN crms.Description
				WHEN sc.ClassificationId = 2 THEN 'ASB'
				WHEN sc.ClassificationId = 3 THEN 'Feedback'
				WHEN sc.ClassificationId = 6 THEN gct.description
				ELSE null
			END AS CaseType,
			sc.StatusId AS StatusId, 
			sl137.Description AS Status, 
			sc.CaseReference AS CaseReference, 
			sc.ActualStartDate AS StartDate, 
			sc.ActualEndDate AS EndDate, 
			CASE
				WHEN sc.RevisedTargetDate is null THEN sc.SLATargetDate
				ELSE sc.RevisedTargetDate
			END AS TargetDate, 
			CONVERT(INT, CONVERT(CHAR(8), sc.ActualStartDate, 112)) AS CaseStartDateKey, 
			CONVERT(INT, CONVERT(CHAR(8), sc.ActualEndDate, 112)) AS CaseEndDateKey, 
			CONVERT(INT, CONVERT(CHAR(8), coalesce(sc.RevisedTargetDate,sc.SLATargetDate), 112)) AS TargetDateDateKey, 
			--0 AS OnTime, 
			--0 AS Late, 
			l97.Description AS LateCompletionReason,
			--0 AS SLAStatus, 
			CASE
				WHEN sc.StatusId = 6 THEN 1
				ELSE 0
			END AS Complete,
			CASE
				WHEN sc.StatusId = 5 THEN 1
				ELSE 0
			END AS Cancelled,
			--0 AS CompleteOnTime
			sc.CompanyId as CompanyId, 
			c.CompanyName as Company

		FROM 
			staging.cx_SystemCase sc

			LEFT JOIN staging.cx_GenericCaseType gct 

			ON sc.GenericCaseTypeId = gct.CaseTypeId

			LEFT JOIN staging.cx_CRMSubject crms 
			ON sc.CRMSubjectId = crms.SubjectId

			LEFT JOIN staging.cx_FeedbackBusinessArea fba 
			ON sc.FeedbackBusinessAreaId = fba.BusinessAreaId

			LEFT JOIN staging.cx_ASBPriorityType apt 
			ON sc.ASBOverallPriorityTypeId = apt.PriorityTypeId

			LEFT JOIN staging.cx_Company c 
			on sc.CompanyId = c.CompanyId

			LEFT JOIN staging.cx_SystemLookup sl137 
			ON sc.StatusId = sl137.LookupReference and sl137.LookupTypeId = 137

			LEFT JOIN staging.cx_Lookup l97 
			ON sc.LateCompletionReasonId = l97.LookupReference and l97.LookupTypeId = 97
	)

	INSERT INTO dwh.Fact_Case
	(
		CxCaseId, 
		ClassificationId, 
		CRMSubjectId , 
		CRMSubject, 
		GenericCaseTypeId, 
		GenericCaseType, 
		ASBOverallPriorityTypeId, 
		ASBPriorityType, 
		FeedbackBusinessAreaId, 
		FeedbackBusinessArea, 
		CaseType,
		StatusId, 
		Status, 
		CompanyId,
		Company,
		CaseReference, 
		StartDate, 
		EndDate, 
		TargetDate, 
		CaseStartDateKey,
		CaseEndDateKey,
		TargetDateDateKey,
		OnTime, 
		Late, 
		LateCompletionReason, 
		SLAStatus, 
		Complete, 
		Cancelled, 
		CompleteOnTime
	)

	SELECT
		CxCaseId, 
		ClassificationId, 
		CRMSubjectId , 
		CRMSubject, 
		GenericCaseTypeId, 
		GenericCaseType, 
		ASBOverallPriorityTypeId, 
		ASBPriorityType, 
		FeedbackBusinessAreaId, 
		FeedbackBusinessArea, 
		CaseType,
		StatusId, 
		Status, 
		CompanyId, 
		Company, 
		CaseReference, 
		StartDate, 
		EndDate, 
		TargetDate, 
		CaseStartDateKey, 
		CaseEndDateKey, 
		TargetDateDateKey, 
		CASE
			WHEN cd.StatusId = 5 THEN 0
			WHEN cd.TargetDate IS NULL THEN 1
			WHEN COALESCE(cd.EndDate, GETDATE()) < cd.TargetDate THEN 1
			ELSE 0
		END AS OnTime, 
		CASE
			WHEN cd.StatusId = 5 THEN 0
			WHEN cd.TargetDate IS NULL THEN 0
			WHEN COALESCE(cd.EndDate, GETDATE()) > cd.TargetDate THEN 1
			ELSE 0
		END AS Late,
		LateCompletionReason,
		CASE
			WHEN cd.StatusId = 5 THEN 'Cancelled'
			WHEN cd.TargetDate IS NOT NULL AND COALESCE(cd.EndDate, GETDATE()) > cd.TargetDate THEN 'Late'
			ELSE 'On Time'
		END AS SLAStatus,
		Complete,
		Cancelled,
		CASE
			WHEN cd.Complete = 1 AND cd.TargetDate IS NOT NULL AND COALESCE(cd.EndDate, GETDATE()) < cd.TargetDate THEN 1
			ELSE 0
		END AS CompleteOnTime

	FROM
		CaseData cd

END
dwh	BuildFactCaseTask	-- =============================================
-- Author:      Ben Reeve
-- Create Date: 01/04/2025
-- Description: Build script for Fact_CaseTask. Script and logic adapted from scripts provided by Jim Walker of iStride Ltd
-- =============================================
CREATE PROCEDURE [dwh].[BuildFactCaseTask]
AS
BEGIN
    -- SET NOCOUNT ON added to prevent extra result sets from
    -- interfering with SELECT statements.
    SET NOCOUNT ON
   
	TRUNCATE TABLE dwh.Fact_CaseTask;

	DROP TABLE IF EXISTS #CaseTask;

	SELECT
		fc.FactCaseId AS FactCaseId,
		sct.CaseId AS CxCaseId, 
		sct.TaskId AS CxTaskId, 
		sctd.TaskDefinitionId AS TaskDefinitionId,
		coalesce(sl241.LookupReference,6) AS TaskTypeId,
		coalesce(sl241.Description,'Task') AS TaskType,
		CASE	
			WHEN sct.CaseDefinitionTaskId IS NOT NULL THEN sctd.Description 
			WHEN sctpvt.TaskTypeId = 6 THEN sctd.Description
			ELSE sctpvt.Name
		END AS TaskDesc,
		sct.StatusId AS StatusId, 
		sl139.Description AS Status,
		sct.ActualStartDate AS StartDate, 
		sct.ActualEndDate AS EndDate, 
		ISNULL(sct.RevisedTargetDate, sct.SLATargetDate) AS TargetDate,
		CASE
			WHEN sct.StatusId = 5 THEN 0
			WHEN ISNULL(sct.RevisedTargetDate, sct.SLATargetDate) IS NULL THEN 1
			WHEN ISNULL(sct.ActualEndDate, GETDATE()) < ISNULL(sct.RevisedTargetDate, sct.SLATargetDate) THEN 1
			ELSE 0
		END AS OnTime, 
		CASE
			WHEN sct.StatusId = 5 THEN 0
			WHEN ISNULL(sct.RevisedTargetDate, sct.SLATargetDate) IS NULL THEN 0
			WHEN ISNULL(sct.ActualEndDate, GETDATE()) > ISNULL(sct.RevisedTargetDate, sct.SLATargetDate) THEN 1
			ELSE 0
		END AS Late, 
		l97.Description AS LateCompletionReason,
		CASE
			WHEN sct.StatusId = 4 THEN 1
			ELSE 0
		END AS Complete,
		CASE
			WHEN sct.StatusId = 5 THEN 1
			ELSE 0
		END AS Cancelled,
		CONVERT(INT, CONVERT(CHAR(8), coalesce(sct.RevisedTargetDate,sct.SLATargetDate), 112)) AS TargetDateDateKey, 
		CONVERT(INT, CONVERT(CHAR(8), sct.ActualStartDate, 112)) AS CaseStartDateKey, 
		CONVERT(INT, CONVERT(CHAR(8), sct.ActualEndDate, 112)) AS CaseEndDateKey

	INTO
		#CaseTask

	FROM 
		staging.cx_SystemCaseTask sct

	LEFT JOIN dwh.Fact_Case fc 
	ON sct.CaseId = fc.CxCaseId

	LEFT JOIN staging.cx_SystemCaseTaskPathVersionTask sctpvt 
	ON sct.CaseTaskPathVersionTaskId = sctpvt.CaseTaskPathVersionTaskId

	LEFT JOIN staging.cx_SystemLookup sl241 
	ON sctpvt.TaskTypeId = sl241.LookupReference 
	and sl241.LookupTypeId = 241

	LEFT JOIN staging.cx_SystemCaseDefinitionTask scdt 
	ON sct.CaseDefinitionTaskId = scdt.CaseDefinitionTaskId

	LEFT JOIN staging.cx_SystemCaseTaskDefinition sctd 
	ON scdt.TaskDefinitionId = sctd.TaskDefinitionId 
		OR sctpvt.TaskDefinitionId = sctd.TaskDefinitionId

	LEFT JOIN staging.cx_SystemLookup sl139 
	ON sct.StatusId = sl139.LookupReference 
	AND sl139.LookupTypeId = 139  

	LEFT JOIN staging.cx_Lookup l97 
	ON sct.LateCompletionReasonId = l97.LookupReference 
	AND l97.LookupTypeId = 97;

	WITH RankedTasks
	AS
	(
		SELECT 
			CxTaskId,
			ROW_NUMBER() OVER (PARTITION BY CxCaseId, TaskDefinitionId ORDER BY CxTaskId DESC) AS rn

		FROM 
			#CaseTask
	)

	INSERT INTO dwh.Fact_CaseTask
	(
		FactCaseId,
		CxCaseId, 
		CxTaskId, 
		TaskDefinitionId,
		TaskTypeId, 
		TaskType,
		TaskDesc,
		StatusId, 
		Status,
		StartDate, 
		EndDate, 
		TargetDate, 
		OnTime, 
		Late, 
		LateCompletionReason,
		SLAStatus,
		Complete, 
		Cancelled, 
		CompleteOnTime, 
		IsLatest,
		TargetDateDateKey,
		CaseStartDateKey,
		CaseEndDateKey
	)


	SELECT 
		ct.FactCaseId,
		ct.CxCaseId, 
		ct.CxTaskId, 
		ct.TaskDefinitionId,
		ct.TaskTypeId,
		ct.TaskType,
		ct.TaskDesc,
		ct.StatusId, 
		ct.Status,
		ct.StartDate, 
		ct.EndDate, 
		ct.TargetDate,
		ct.OnTime, 
		ct.Late, 
		ct.LateCompletionReason,
		CASE
			WHEN ct.StatusId = 5 THEN 'Cancelled'
			WHEN ct.Late = 1 THEN 'Late'
			ELSE 'On Time'
		END AS SLAStatus, 
		ct.Complete,
		ct.Cancelled, 
		CASE
			WHEN ct.Complete = 1 AND ct.OnTime = 1 THEN 1
			ELSE 0
		END AS CompleteOnTime, 
		CASE
			WHEN rt.rn = 1 THEN 1
			ELSE 0
		END AS IsLatest,
		TargetDateDateKey,
		CaseStartDateKey,
		CaseEndDateKey


	FROM 
		#CaseTask ct JOIN RankedTasks rt
		ON ct.CxTaskId = rt.CxTaskId

END
dwh	BuildFactCaseTaskInformationField	-- =============================================
-- Author:      Ben Reeve
-- Create Date: 01/04/2025
-- Description: Build script for Fact_CaseTaskInformationField. Script and logic adapted from scripts provided by Jim Walker of iStride Ltd
-- =============================================
CREATE PROCEDURE [dwh].[BuildFactCaseTaskInformationField]
AS
BEGIN
    -- SET NOCOUNT ON added to prevent extra result sets from
    -- interfering with SELECT statements.
    SET NOCOUNT ON
   
	TRUNCATE TABLE dwh.Fact_CaseTaskInformationField;

	INSERT INTO dwh.Fact_CaseTaskInformationField
	(
		CxCaseId,
		CxTaskId,
		TaskDefinitionInformationFieldId,
		FieldDescription,
		TaskInformationFieldResponseId,
		Response,
		IntegerResponse,
		DecimalResponse, 
		TextResponse,
		LookupIdResponse,
		FieldLookupIdResponse,
		DatetimeResponse, 
		BoolResponse
	)

	SELECT  
		sct.CaseId AS CxCaseId,
		sct.TaskId AS CxTaskId,
		sctdif.TaskDefinitionInformationFieldId AS TaskDefinitionInformationFieldId,
		sctdif.Description AS FieldDescription,
		sctifr.TaskInformationFieldResponseId AS TaskInformationFieldResponseId,
		CASE sctdif.DataTypeId 
			WHEN 1  THEN cast(sctifr.IntegerResponse AS nvarchar(max))						
			WHEN 2  THEN cast(sctifr.DecimalResponse AS nvarchar(max))						 
			WHEN 3  THEN cast(sctifr.TextResponse AS nvarchar(max))							 
			WHEN 4  THEN cast(l.Description AS nvarchar(max))								 
			WHEN 5  THEN format(sctifr.DatetimeResponse, 'dd/MM/yyyy HH:mm')				 
			WHEN 6  THEN format(sctifr.DatetimeResponse, 'dd/MM/yyyy')						 
			WHEN 7  THEN format(sctifr.DatetimeResponse, 'HH:mm') 							 
			WHEN 8  THEN cast(sctifr.BooleanResponse AS nvarchar(max))						 
			WHEN 9  THEN cast(sl.Description AS nvarchar(max))								
			WHEN 10 THEN
				CASE 
					WHEN sctdif.LookupTableName = 'SecurityUser' THEN su.FullName
				    ELSE NULL
				END
			WHEN 11 THEN cast(ul.Description AS nvarchar(max))								 
			WHEN 12 THEN cast(sctdifl.Description AS nvarchar(max))							 
			ELSE NULL
		END AS Response,
		sctifr.IntegerResponse AS IntegerResponse,
		sctifr.DecimalResponse AS DecimalResponse, 
		sctifr.TextResponse AS TextResponse, 
		sctifr.LookupIdResponse AS LookupIdResponse,
		sctifr.FieldLookupIdResponse AS FieldLookupIdResponse, 
		sctifr.DatetimeResponse AS DatetimeResponse,
		sctifr.BooleanResponse AS BooleanResponse

	FROM 
        staging.cx_SystemCaseTask sct

        JOIN staging.cx_SystemCaseTaskInformationFieldResponse sctifr 
        ON sct.TaskId = sctifr.TaskId

        JOIN staging.cx_SystemCaseTaskDefinitionInformationField sctdif 
        ON sctifr.TaskDefinitionInformationFieldId = sctdif.TaskDefinitionInformationFieldId

        LEFT JOIN staging.cx_SystemCaseTaskDefinitionInformationFieldLookup sctdifl 
        ON sctifr.FieldLookupIdResponse = sctdifl.TaskDefinitionInformationFieldLookupId

        LEFT JOIN staging.cx_Lookup l 
        ON sctdif.LookupTypeId = l.LookupTypeId 
        AND sctifr.LookupIdResponse = l.LookupReference

        LEFT JOIN staging.cx_SystemLookup sl 
        ON sctdif.LookupTypeId = sl.LookupTypeId 
        AND sctifr.LookupIdResponse = sl.LookupReference

        LEFT JOIN staging.cx_UDFLookup ul 
        ON sctdif.LookupTypeId = ul.LookupTypeId 
        AND sctifr.LookupIdResponse = ul.LookupReference	

        LEFT JOIN staging.cx_SecurityUser su 
        ON sctifr.LookupIdResponse = su.UserId

END
dwh	BuildFactCommunication	-- =============================================
-- Author:      Ben Reeve
-- Create Date: 22/05/2025
-- Description: Builds Fact Communication
-- =============================================
CREATE PROCEDURE [dwh].[BuildFactCommunication]
AS
BEGIN
    -- SET NOCOUNT ON added to prevent extra result sets from
    -- interfering with SELECT statements.
    SET NOCOUNT ON

	TRUNCATE TABLE dwh.Fact_Communication

	INSERT INTO dwh.Fact_Communication
	(
		DimContactId, 
		DimContactGroupId,
		CreatedDate,
		Status,
		Method,
		CommunicationName,
		CxCommunicationId,
		CxContactGroupId,
		CxContactId
	)

	SELECT 
		dc.DimContactId,
		dcg.DimContactGroupId,
		CreatedDate,
		sl65.[Description] AS Status,
		sl27.[Description] AS Method,
		cd.CommunicationName,
		c.CommunicationId AS CxCommunicationId,
		dcg.CxContactGroupId,
		dc.CxContactId

	FROM 
		staging.cx_communication c

		LEFT JOIN staging.cx_systemlookup sl65
		ON c.StatusId = sl65.LookupReference
		AND sl65.LookupTypeId = 65

		JOIN dwh.Dim_Contact dc
		ON  c.ContactId = dc.CxContactId

		LEFT JOIN dwh.Dim_ContactGroup dcg
		ON c.ContactGroupId = dcg.CxContactGroupId

		LEFT JOIN staging.cx_communicationqueue cq
		ON c.QueueId = cq.QueueId

		LEFT JOIN staging.cx_systemlookup sl27
		ON cq.CommunicationMethodId = sl27.LookupReference
		AND sl27.LookupTypeId = 27

		LEFT JOIN staging.cx_communicationdefinition cd
		ON c.CommunicationDefinitionId = cd.DefinitionId

END
dwh	BuildFactComplaint	CREATE   PROCEDURE [dwh].[BuildFactComplaint]
AS
BEGIN
    SET NOCOUNT ON;

    TRUNCATE TABLE dwh.Fact_Complaint;

	DROP TABLE IF EXISTS #CaseUDF;

	SELECT 
		sc.caseid AS CaseId, 
		ll.Description AS ComplaintLessonsLearned, 
		lt.Description AS ComplaintLearningType,
		cc.Description AS ComplaintComplaintCategory,
		sca.Description AS ComplaintSubCategory,
		ce.Description AS ComplaintCaseExtended, 
		co.Description AS ComplaintCaseOutcome, 
		fa.Description AS ComplaintFollowOnActions, 
		FollowOnActionDetails ComplaintFollowOnActionsDetails,
		ct.Description AS ComplaintClosedInTargetOrExtendedTarget, 
		ai.Description AS ComplaintAcknowledgedInTarget, 
		ss.Description AS ComplaintSendSatisfactionSurvey,
		sc.CaseClosureDate as ComplaintCaseClosureDate, 
		sc.WhatWentWrong as ComplaintWhatWentWrong,
		sc.WhatNeedsToBeImproved as ComplaintWhatNeedsToBeImproved
	INTO #CaseUDF
	FROM 
		staging.cx_systemcase_user sc
		LEFT JOIN [staging].[cx_udflookup] ll ON sc.LessonsLearned = ll.LookupReference AND ll.LookUpTypeId = 57
		LEFT JOIN [staging].[cx_udflookup] lt ON sc.LearningType = lt.LookupReference AND lt.LookUpTypeId = 58
		LEFT JOIN [staging].[cx_udflookup] cc ON sc.ComplaintCategory = cc.LookupReference AND cc.LookUpTypeId = 102
		LEFT JOIN [staging].[cx_udflookup] sca ON sc.SubCategory = sca.LookupReference AND sca.LookUpTypeId = 148
		LEFT JOIN [staging].[cx_udflookup] ce ON sc.CaseExtended = ce.LookupReference AND ce.LookUpTypeId = 149
		LEFT JOIN [staging].[cx_udflookup] co ON sc.CaseOutcome = co.LookupReference AND co.LookUpTypeId = 150
		LEFT JOIN [staging].[cx_udflookup] fa ON sc.FollowOnActions = fa.LookupReference AND fa.LookUpTypeId = 151
		LEFT JOIN [staging].[cx_udflookup] ct ON sc.ClosedInTargetOrExtendedTarget = ct.LookupReference AND ct.LookUpTypeId = 152
		LEFT JOIN [staging].[cx_udflookup] ai ON sc.AcknowledgedInTarget = ai.LookupReference AND ai.LookUpTypeId = 156
		LEFT JOIN [staging].[cx_udflookup] ss ON sc.SendSatisfactionSurvey = ss.LookupReference AND ss.LookUpTypeId = 169;



    WITH MaxStage AS
    ( 
        SELECT CaseId, MAX(FeedbackStageId) AS FeedbackStageId
        FROM staging.cx_feedbackstage
        GROUP BY CaseId
    ),
    MaxStatus AS 
    (
        SELECT CaseId, MAX(CaseStatusId) AS CaseStatusId 
        FROM staging.cx_systemcasestatus
        GROUP BY CaseId
    ),
    FeedbackCaseCost AS 
    (
        SELECT CaseId, SUM(Value) AS Value
        FROM staging.cx_systemcasecost
        WHERE FeedbackCostTypeId IS NOT NULL
        GROUP BY CaseId
    )

    INSERT INTO dwh.Fact_Complaint
    (
        CxCaseId, 
		CaseClassification, 
		BusinessArea, 
		Stage, 
		Status, 
		StartDate, 
		EndDate, 
		CreatedDate, 
        EntityType, 
		EntityId, 
		CaseType, 
		CaseReference, 
		ContactId, 
		ContactGroupId, 
		AgreementId, 
        SLATargetDate, 
		ClosureReason, 
		ValueOfCompensationAwarded,
		IsCompensationAwarded,
		IsExtensionAdded,
		IsFollowOnActions,
		FollowOnActionsDetail,
		CaseOutcome,
		ComplaintCategory,
		ComplaintSubCategory,
		CxAgreementId,
		DateRecieved

    )
    SELECT DISTINCT
        c.CaseId,
        classification.Description,
        fba.Description,
        CASE WHEN c.CRMSubjectId = 157 THEN 'Triage' ELSE fst.Description END,
        status.Description,
        c.ActualStartDate,
        c.ActualEndDate,
        c.CreatedDate,
        entitytype.Description,
        c.EntityId,
        feedbacktype.Description,
        c.CaseReference,
        contact.contactid,
        cgm.ContactGroupId,
        ae.AgreementId,
        c.SLATargetDate,
        closurereason.Description,
        FeedbackCaseCost.Value,
		case when FeedbackCaseCost.Value > 0 then 1 else 0 end  as IsCompensationAwarded,
		case 
			when udf.ComplaintCaseExtended = 'Yes' then 1 
			when udf.ComplaintCaseExtended = 'No' then 0 
			else 0 
		end as IsExtensionAdded,
		case 
			when udf.ComplaintFollowOnActions = 'Yes' then 1 
			when udf.ComplaintFollowOnActions = 'No' then 0 
			else 0 
		end as ComplaintFollowOnActions,
		udf.ComplaintFollowOnActionsDetails,
		udf.ComplaintCaseOutcome,
		udf.ComplaintComplaintCategory,
		udf.ComplaintSubCategory,
		ae.AgreementId,
		c.ActualStartDate
    FROM staging.cx_systemcase c
    LEFT JOIN staging.cx_systemlookup classification 
        ON c.ClassificationId = classification.LookupReference AND classification.LookupTypeId = 159
    LEFT JOIN staging.cx_lookup businessarea 
        ON c.FeedbackBusinessAreaId = businessarea.LookupReference AND businessarea.LookupTypeId = 110
    LEFT JOIN staging.cx_systemlookup status 
        ON c.StatusId = status.LookupReference AND status.LookupTypeId = 137
    LEFT JOIN staging.cx_systemlookup entitytype 
        ON c.EntityTypeId = entitytype.LookupReference AND entitytype.LookupTypeId = 150
    LEFT JOIN staging.cx_systemlookup feedbacktype 
        ON c.FeedbackTypeId = feedbacktype.LookupReference AND feedbacktype.LookupTypeId = 169
    LEFT JOIN MaxStage 
        ON c.CaseId = MaxStage.CaseId
    LEFT JOIN staging.cx_feedbackstage fs 
        ON MaxStage.FeedbackStageId = fs.FeedbackStageId
    LEFT JOIN staging.cx_FeedbackStageType fst 
        ON fs.StageTypeId = fst.StageTypeId
    LEFT JOIN staging.cx_FeedbackBusinessArea fba 
        ON c.FeedbackBusinessAreaId = fba.BusinessAreaId
    LEFT JOIN staging.cx_systemcasecontact contact 
        ON c.caseid = contact.caseid AND contact.primecontact = 1
    LEFT JOIN staging.cx_contactgroupmember cgm 
        ON contact.contactid = cgm.contactid 
           AND (c.ActualStartDate >= cgm.EffectiveFromDate AND (c.ActualStartDate < cgm.EffectiveToDate OR cgm.EffectiveToDate IS NULL))
    INNER JOIN staging.cx_rentagreementepisode ae --only return contactgroup where there is an agreement, left join cause duplication
        ON cgm.ContactGroupId = ae.ContactGroupId 
           AND (c.ActualStartDate >= ae.EffectiveFromDate AND (c.ActualStartDate < ae.EffectiveToDate OR ae.EffectiveToDate IS NULL))
    LEFT JOIN MaxStatus 
        ON c.CaseId = MaxStatus.CaseId
    LEFT JOIN staging.cx_systemcasestatus scs 
        ON MaxStatus.CaseStatusId = scs.CaseStatusId AND scs.FeedbackClosureReasonId IS NOT NULL
    LEFT JOIN staging.cx_lookup closurereason 
        ON scs.FeedbackClosureReasonId = closurereason.LookupReference AND closurereason.LookupTypeId = 149
    LEFT JOIN FeedbackCaseCost 
        ON c.CaseId = FeedbackCaseCost.CaseId
	LEFT JOIN #CaseUDF udf 
		ON c.CaseId = udf.CaseId
    WHERE 
        (c.ClassificationId = 3 
        AND c.FeedbackTypeId IN (2, 3))
		OR c.CRMSubjectId = 157
        --AND c.CaseId IN ('6', '84712', '94322', '99916', '84936', '84583');
END;



dwh	BuildFactCompliance	CREATE PROC [dwh].[BuildFactCompliance]
AS
    DECLARE @Today AS DATE
    SET @Today = CAST(GETDATE() AS DATE)

    TRUNCATE TABLE dwh.Fact_Compliance;

    WITH ComplianceData
    AS
    (

        SELECT DISTINCT
            a.[AssetID] as [AssetID],
            --e.[AssetTypeID] as [AssetTypeID],
            CASE
                WHEN ct.ComplianceType IN ('Annual Gas Service', 'Legionella L8') THEN NULL
                ELSE [EquipmentID] 
            END AS EquipmentId,
            --e.EquipmentType as EquipmentType,
            e.DateDecommissioned, --as EquipmentDateDecommissioned, 
            --e.DateInstalled as EquipmentDateInstalled,
            --[MakeModelID],
            --[Notes],
            [LastOutcome],
            [LastVisitID],
            cast([LastDateActual] as date) as LastDateActual,
            cast([NextDue] as date) as [NextDue],
            e.[ServiceType],
            -- CASE 
            --     WHEN [LastDateActual] <= getDate() then 1 
            --     when [LastDateActual] is null then 1
            --     else  0 
            -- END AS ComplianceCheckOverdue_Flag,
            -- '' as ComplianceCheckComplete_Flag,
            DATEDIFF(DAY, GETDATE(), NextDue) as NumberOfDaysUntilDue,
            CASE 
                WHEN DATEDIFF(MONTH, GETDATE(), NextDue) <= 3 THEN '1'
                    else '0' 
            END AS ComplianceCheckDueWithin3Months_Flag,
            ct.ComplianceType,
            s.ServicerID, 'Keystone' AS Source
            -- CASE 
            --     WHEN DATEDIFF(DAY, GETDATE(), NextDue) > 0 
            --         AND DATEDIFF(DAY, GETDATE(), NextDue) <= 30 THEN '1-30 Days'
            --     WHEN DATEDIFF(DAY, GETDATE(), NextDue) > 30 
            --         AND DATEDIFF(DAY, GETDATE(), NextDue) <= 60 THEN '31-60 Days'
            --     WHEN DATEDIFF(DAY, GETDATE(), NextDue) > 60 
            --         AND DATEDIFF(DAY, GETDATE(), NextDue) <= 90 THEN '61-90 Days'
            --     WHEN DATEDIFF(DAY, GETDATE(), NextDue) > 90 THEN '90+ Days'
            -- END as OverdueDays
            
        FROM 
            staging.keystone_miview_ksi_equipment e 
            
            JOIN staging.mapping_ComplianceType ct
            ON (e.EquipmentTypeID = ct.EquipmentTypeId AND ct.ServiceType IS NULL)
                OR (e.EquipmentTypeID = ct.EquipmentTypeId AND e.ServiceType = ct.ServiceType)
                OR (e.ServiceType = ct.ServiceType AND ct.EquipmentType IS NULL)

            LEFT JOIN staging.cx_asset a 
            ON e.UPRN = a.AssetReference 

            LEFT JOIN dwh.Dim_Servicer s
            ON e.Servicer = s.Servicer

        WHERE (DateDecommissioned is null or DateDecommissioned > getdate())--e.equipmentid = '90909'

    ),
    ComplianceUnion
    AS 
    (
        SELECT 
            cd.AssetID, 
            cd.equipmentid, 
            cd.ComplianceType, 
            cd.ServiceType, 
            cd.LastOutcome,
            cd.ServicerID,
            MIN(cd.NextDue) AS NextDue, 
            MAX(cd.LastDateActual) AS LastDateActual, 
            MAX(cd.LastVisitId) AS LastVisitId,
            Source,
            NULL AS ClientActionId,
            NULL AS ComplianceCheckCompleted,
            NULL AS ComplianceCheckDueBeforeToday,
            NULL AS Notes 
        

        FROM 
            ComplianceData cd
        GROUP BY 
            cd.AssetID, 
            cd.equipmentid, 
            ComplianceType, 
            ServiceType,
            cd.LastOutcome,
            cd.ServicerID,
            Source

        UNION ALL

        SELECT 
            [AssetID],
            [EquipmentId],
            [ComplianceType],
            NULL AS ServiceType,
            [LastOutcome],
            NULL AS ServicerId,
            [NextDue],
            [LastDateActual],
            [LastVisitID],
            'RiskHub' AS Source,
            ClientActionId,
            ComplianceCheckCompleted,
            ComplianceCheckDueBeforeToday,
            Notes

        FROM 
            [staging].[StagingComplianceRiskHub]

    ),
    ComplianceDataAdditionalFields
    AS
    (
        SELECT 
            AssetID, 
            equipmentid, 
            ComplianceType, 
            ServiceType, 
            LastOutcome,
            ServicerID,
            NextDue, 
            LastDateActual, 
            LastVisitId,
            Source,
            ClientActionId,
            ComplianceCheckCompleted,
            ComplianceCheckDueBeforeToday,
            Notes, 
            CASE
                WHEN NextDue is null OR NextDue = '01/01/1900' THEN 1
                ELSE 0
            END AS ComplianceCheckBlank_Flag,
            CASE
                WHEN NextDue IS NULL OR NextDue = '01/01/1900' THEN 1
                WHEN NextDue < @Today THEN 1
                ELSE 0
            END AS ComplianceCheckOverdue_Flag,
            CASE
                WHEN NextDue < DATEADD(MONTH, 3, @Today) and NextDue is not null and NextDue <> '01/01/1900' THEN 1
                ELSE 0
            END AS ComplianceCheckDueWithinThreeMonths_Flag,
            CASE--condition should match ComplianceCheckOverdue_Flag
                WHEN NextDue < @Today AND NextDue IS NOT NULL AND NextDue <> '01/01/1900' THEN DATEDIFF(DAY, NextDue, @Today) 
                ELSE NULL
            END AS OverdueDays,
            CASE--condition should be the inverse of ComplianceCheckOverdue_Flag
                WHEN NOT(NextDue < @Today AND NextDue IS NOT NULL AND NextDue <> '01/01/1900') THEN DATEDIFF(DAY, @Today, NextDue ) 
                ELSE NULL
            END AS CountdownDays

        FROM 
            ComplianceUnion
    )

    INSERT INTO [dwh].[Fact_Compliance]
    (
        [AssetID],
        EquipmentId, 
        ComplianceType, 
        ServiceType, 
        LastOutcome, 
        ServicerId, 
        NextComplianceCheckDate,
        ComplianceCheckDate, 
        LastVisitID,
        Source,
        FRAClientActionId,
        ComplianceCheckComplete_Flag,
        ComplianceCheckDueBeforeToday_Flag,
        Comments,
        ComplianceCheckBlank_Flag,
        ComplianceCheckOverdue_Flag,
        ComplianceCheckDueWithinThreeMonths_Flag,
        OverdueDays,
        CountdownDays,
        OverdueDaysBanding,
        CountdownDaysBanding,
        AgreementId
    )

    SELECT
        comp.AssetID, 
        comp.equipmentid, 
        comp.ComplianceType, 
        comp.ServiceType, 
        comp.LastOutcome,
        comp.ServicerID,
        comp.NextDue, 
        comp.LastDateActual, 
        comp.LastVisitId,
        comp.Source,
        comp.ClientActionId,
        comp.ComplianceCheckCompleted,
        comp.ComplianceCheckDueBeforeToday,
        comp.Notes, 
        comp.ComplianceCheckBlank_Flag,
        comp.ComplianceCheckOverdue_Flag,
        comp.ComplianceCheckDueWithinThreeMonths_Flag,
        comp.OverdueDays,
        comp.CountdownDays,
        CASE 
            WHEN comp.OverdueDays >= 0 AND  comp.OverdueDays <= 30 THEN '1-30 Days'
            WHEN comp.OverdueDays > 30 AND comp.OverdueDays <= 60 THEN '31-60 Days'
            WHEN comp.OverdueDays > 60 AND comp.OverdueDays <= 90 THEN '61-90 Days'
            WHEN comp.OverdueDays > 90 THEN '90+ Days'
            ELSE null
        END AS OverdueDaysBanding,
        CASE 
            WHEN comp.CountdownDays >= 0 AND  comp.CountdownDays <= 30 THEN '1-30 Days'
            WHEN comp.CountdownDays > 30 AND comp.CountdownDays <= 60 THEN '31-60 Days'
            WHEN comp.CountdownDays > 60 AND comp.CountdownDays <= 90 THEN '61-90 Days'
            WHEN comp.CountdownDays > 90 THEN '90+ Days'
            ELSE null
        END AS CountdownDaysBanding,
        r.AgreementId

    FROM
        ComplianceDataAdditionalFields comp 
        
        LEFT join staging.cx_rentagreementasset r
        ON comp.AssetId = r.AssetId
        AND comp.LastDateActual >= r.EffectiveFromDate AND comp.LastDateActual <= ISNULL(r.EffectiveToDate, '2200-01-01')
dwh	BuildFactComplianceSnapshot	
CREATE PROCEDURE [dwh].[BuildFactComplianceSnapshot]
    @InputDate datetime = null

AS
BEGIN

    --delete any snapshots already created for todays date
    delete from dwh.Fact_Compliance_Snapshot where SnapshotDate = @InputDate
    
    --get snapshot data from external table pointing at data lake and insert into lake. This should only be done on 6th working day of the month. This is controlled by ADF.
    INSERT INTO [dwh].[Fact_Compliance_Snapshot]
    (
    SnapshotDate,
    ComplianceId,
    AssetId,
    FRAClientActionId,
    ComplianceTypeId,
    ComplianceCheckDate,
    NextComplianceCheckDate,
    ComplianceCheckComplete_Flag,
    ComplianceCheckOverdue_Flag,
    ComplianceCheckDueBeforeToday_Flag,
    ComplianceCheckBlank_Flag,
    ComplianceCheckDueWithinThreeMonths_Flag,
    AgreementId,
    AssetTypeId,
    MakeModelId,
    Notes,
    LastOutcome,
    LastVisitId,
    LastDateActual,
    NextDue,
    ServiceType,
    EquipmentId,
    ComplianceType,
    OverdueDays,
    OverdueDaysBanding,
    CountdownDays,
    CountdownDaysBanding,
    SnapshotYear,
    SnapshotMonth,
    SnapshotDay,
    SnapshotWorkingDay
    )
    SELECT 
    DATEFROMPARTS(SnapshotYear,SnapshotMonth,SnapshotDay) as SnapshotDate,
    ComplianceId,
    AssetId,
    FRAClientActionId,
    ComplianceTypeId,
    ComplianceCheckDate,
    NextComplianceCheckDate,
    ComplianceCheckComplete_Flag,
    ComplianceCheckOverdue_Flag,
    ComplianceCheckDueBeforeToday_Flag,
    ComplianceCheckBlank_Flag,
    ComplianceCheckDueWithinThreeMonths_Flag,
    AgreementId,
    AssetTypeId,
    MakeModelId,
    Notes,
    LastOutcome,
    LastVisitId,
    LastDateActual,
    NextDue,
    ServiceType,
    EquipmentId,
    ComplianceType,
    OverdueDays,
    OverdueDaysBanding,
    CountdownDays,
    CountdownDaysBanding,
    SnapshotYear,
    SnapshotMonth,
    SnapshotDay,
    SnapshotWorkingDay
    FROM [ldw].[compliance_snapshot_external_table] where SnapshotYear = Year(@InputDate) and SnapshotMonth = Month(@InputDate) and SnapshotDay = Day(@InputDate) --SnapshotDateTime = @InputDate

END
dwh	BuildFactComplianceSnapshotTVP	
CREATE PROCEDURE [dwh].[BuildFactComplianceSnapshotTVP]
    (
		@InputDate datetime,
		@Snapshot [dbo].[UDT_Fact_Compliance_Snapshot] readonly 
	)
AS
BEGIN

    --delete any snapshots already created for todays date
    delete from dwh.Fact_Compliance_Snapshot where SnapshotDate = @InputDate
    
	DROP TABLE IF EXISTS #TEMPSNAPSHOT

	SELECT 
    [SnapshotDateTime] as SnapshotDate,
    ComplianceId,
    AssetId,
    FRAClientActionId,
    ComplianceTypeId,
    ComplianceCheckDate,
    NextComplianceCheckDate,
    ComplianceCheckComplete_Flag,
    ComplianceCheckOverdue_Flag,
    ComplianceCheckDueBeforeToday_Flag,
    ComplianceCheckBlank_Flag,
    ComplianceCheckDueWithinThreeMonths_Flag,
    AgreementId,
    --AssetTypeId,
    --MakeModelId,
    Notes,
    LastOutcome,
    LastVisitId,
    --LastDateActual,
    --NextDue,
    ServiceType,
    EquipmentId,
    ComplianceType,
    OverdueDays,
    OverdueDaysBanding,
    CountdownDays,
    CountdownDaysBanding,
    Year([SnapshotDateTime]) as SnapshotYear,
    Month([SnapshotDateTime]) as SnapshotMonth,
    Day([SnapshotDateTime]) as SnapshotDay,
    SnapshotWorkingDay,
	ServicerId
	INTO #TEMPSNAPSHOT
	FROM @Snapshot


    --get snapshot data from external table pointing at data lake and insert into lake. This should only be done on 6th working day of the month. This is controlled by ADF.
    INSERT INTO [dwh].[Fact_Compliance_Snapshot]
    (
    SnapshotDate,
    ComplianceId,
    AssetId,
    FRAClientActionId,
    ComplianceTypeId,
    ComplianceCheckDate,
    NextComplianceCheckDate,
    ComplianceCheckComplete_Flag,
    ComplianceCheckOverdue_Flag,
    ComplianceCheckDueBeforeToday_Flag,
    ComplianceCheckBlank_Flag,
    ComplianceCheckDueWithinThreeMonths_Flag,
    AgreementId,
    --AssetTypeId,
    --MakeModelId,
    Notes,
    LastOutcome,
    LastVisitId,
    --LastDateActual,
    --NextDue,
    ServiceType,
    EquipmentId,
    ComplianceType,
    OverdueDays,
    OverdueDaysBanding,
    CountdownDays,
    CountdownDaysBanding,
    SnapshotYear,
    SnapshotMonth,
    SnapshotDay,
    SnapshotWorkingDay,
	ServicerId
    )
    SELECT 
    SnapshotDate,
    ComplianceId,
    AssetId,
    FRAClientActionId,
    ComplianceTypeId,
    ComplianceCheckDate,
    NextComplianceCheckDate,
    ComplianceCheckComplete_Flag,
    ComplianceCheckOverdue_Flag,
    ComplianceCheckDueBeforeToday_Flag,
    ComplianceCheckBlank_Flag,
    ComplianceCheckDueWithinThreeMonths_Flag,
    AgreementId,
    --AssetTypeId,
    --MakeModelId,
    Notes,
    LastOutcome,
    LastVisitId,
    --LastDateActual,
    --NextDue,
    ServiceType,
    EquipmentId,
    ComplianceType,
    OverdueDays,
    OverdueDaysBanding,
    CountdownDays,
    CountdownDaysBanding,
    SnapshotYear,
    SnapshotMonth,
    SnapshotDay,
    SnapshotWorkingDay,
	ServicerId
	FROM #TEMPSNAPSHOT
	--[ldw].[compliance_snapshot_external_table] where SnapshotYear = Year(@InputDate) and SnapshotMonth = Month(@InputDate) and SnapshotDay = Day(@InputDate) --SnapshotDateTime = @InputDate

END
dwh	BuildFactCompliment	-- =============================================
-- Author:      Ben Reeve
-- Create Date: 27/03/2025
-- Description: Builds Fact_Compliment from systemcase data
-- =============================================
CREATE PROCEDURE dwh.BuildFactCompliment
AS
BEGIN
    -- SET NOCOUNT ON added to prevent extra result sets from
    -- interfering with SELECT statements.
    SET NOCOUNT ON

	TRUNCATE TABLE dwh.Fact_Compliment;

	INSERT INTO dwh.Fact_Compliment
	(
		CxStage1CaseId,
		CaseReference,
		StartDate,
		EndDate
	)

	SELECT
		sc.CaseId AS CxStage1CaseId,
		sc.CaseReference AS CaseReference,
		sc.ActualStartDate AS StartDate,
		sc.ActualEndDate AS EndDate

	FROM 
		staging.cx_systemcase sc

	WHERE 
		sc.ClassificationId = 3
		AND sc.FeedbackTypeId = 1

END
dwh	BuildFactContactAlertReview	-- =============================================
-- Author:      Ben Reeve
-- Create Date: 23/05/2025
-- Description: Builds Fact Contact Alert Review
-- =============================================
CREATE PROCEDURE [dwh].[BuildFactContactAlertReview]
AS
BEGIN
    -- SET NOCOUNT ON added to prevent extra result sets from
    -- interfering with SELECT statements.
    SET NOCOUNT ON

	TRUNCATE TABLE dwh.Fact_ContactAlertReview

	INSERT INTO dwh.Fact_ContactAlertReview
	(
		DimContactId,
		CxContactId,
		CxContactAlertId,
		DateCompleted,
		CompletedBy
	)

	SELECT
		c.DimContactId,
		ca.ContactId AS CxContactId,
		car.ContactAlertId AS CxContactAlertId,
		car.ReviewCompletionDate AS DateCompleted,
		su.FullName AS CompletedBy

	FROM 
		staging.cx_contactalertreview car

		JOIN staging.cx_ContactAlert ca
		ON car.ContactAlertId = ca.ContactAlertId

		JOIN dwh.Dim_Contact c
		ON ca.ContactId = c.CxContactId

		LEFT JOIN staging.cx_securityuser su
		ON car.CompletedBy = su.UserId

END
dwh	BuildFactCRMCommunication	-- =============================================
-- Author:      Ben Reeve
-- Create Date: 22/05/2025
-- Description: Builds Fact CRMCommunication
-- =============================================
CREATE PROCEDURE [dwh].[BuildFactCRMCommunication]
AS
BEGIN
    -- SET NOCOUNT ON added to prevent extra result sets from
    -- interfering with SELECT statements.
    SET NOCOUNT ON

	TRUNCATE TABLE dwh.Fact_CRMCommunication

	INSERT INTO dwh.Fact_CRMCommunication
	(
		CxCRMCommunicationId, 
		DimContactId,
		DimContactGroupId,
		StartDate,
		EndDate,
		Status,
		Method,
		CxContactGroupId,
    	CxContactId
	)

	SELECT 
		cc.CommunicationId AS CxCRMCommunicationId, 
		dc.DimContactId,
		dcg.DimContactGroupId,
		cc.ActualStartDate AS StartDate,
		cc.ActualEndDate AS EndDate,
		sl138.[Description] AS Status,
		ccm.[Description] AS Method,
		ccc.ContactGroupId AS CxContactGroupId,
		ccc.ContactId AS CxContactId

	FROM 
		staging.cx_crmcommunication cc

		LEFT JOIN staging.cx_crmcommunicationcontact ccc
		ON cc.CommunicationId = ccc.CommunicationId

		JOIN dwh.Dim_Contact dc
		ON  ccc.ContactId = dc.CxContactId

		LEFT JOIN dwh.Dim_ContactGroup dcg
		ON ccc.ContactGroupId = dcg.CxContactGroupId

		LEFT JOIN staging.cx_systemlookup sl138
		ON cc.StatusId = sl138.LookupReference
		AND sl138.LookupTypeId = 138

		LEFT JOIN staging.cx_crmcommunicationmethod ccm
		ON cc.CommunicationMethodId = ccm.CommunicationMethodId

END
dwh	BuildFactCustomerContacts	


CREATE PROCEDURE [dwh].[BuildFactCustomerContacts]
AS
BEGIN
    SET NOCOUNT ON;

	-- Drop the target Fact Table
	DROP TABLE [dwh].[Fact_CustomerContacts];

    -- Insert into the transform table from the staging table
    SELECT 
        [ID],
        [dnis] AS [DNIS],
        [aaDestination] AS [AA Destination],
        [callId] AS [Call Id],
        [startTimeUTC] AS [Start Time UTC],
        [startTime] AS [Start Time],
		CAST([startTime] AS DATE) AS [Start Date],
        [connectTimeUTC] AS [Connect Time UTC],
        [connectTime] AS [Connect Time],
        [disconnectedTimeUTC] AS [Disconnected Time UTC],
        [disconnectedTime] AS [Disconnected Time],
		CAST([disconnectedTime] AS DATE) AS [Disconnected Date],
        [talkTimeMS] AS [Talk Time MS],
        [talkTime] AS [Talk Time],
        [caller] AS [Caller],
        [callerName] AS [Caller Name],
        [callee] AS [Callee],
        [calleeName] AS [Callee Name],
        [direction] AS [Direction],
        [callerId] AS [Caller Id],
        [missed] AS [Missed],
        [abandoned] AS [Abandoned],
        [answered] AS [Answered],
        [answeredTime] AS [Answered Time],
        [calleeDisconnectOnHold] AS [Callee Disconnect On Hold],
        [callerDisconnectOnHold] AS [Caller Disconnect On Hold],
        [pbxId] AS [Pbx Id],
        [sipCallId] AS [Sip Call Id],
        [lastLegDisposition] AS [Last Leg Disposition],
        [callLegCount] AS [Call Leg Count],
        [callTime] AS [Call Time],
        [ringDuration] AS [Ring Duration],
        [abandonedTime] AS [Abandoned Time],
        [calleeHoldDurationMS] AS [Callee Hold Duration MS],
        [calleeHoldDuration] AS [Callee Hold Duration],
        [waitTimeMS] AS [Wait Time MS],
        [waitTime] AS [Wait Time],
        [departments] AS [Departments],
        [branches] AS [Branches],
        [ControlID] AS [Control ID]
    INTO [dwh].[Fact_CustomerContacts]
    FROM [staging].[eightbyeight]
	WHERE 1=1
	--AND [ControlID] = (SELECT MAX([ControlID]) FROM [staging].[eightbyeight])
	;

END
dwh	BuildFactCustomerContactsDetailedReport	

CREATE   PROCEDURE [dwh].[BuildFactCustomerContactsDetailedReport]

-- =============================================
-- Author:      Amit Kakkad
-- Create Date: April / May 2024
-- Description: Transforms Staging Data to Fact Customer Contacts Data
-- =============================================

AS
BEGIN
    SET NOCOUNT ON;

    -- Insert data into the detailed report table
    DECLARE @RecordsInserted INT;
    
    INSERT INTO dwh.Fact_CustomerContacts_Detailed_Report (
        [Interaction Date],
        [Finished Date],
        [recordId],
        [scheduleHours],
        [participantGroupName],
        [originalInteractionId],
        [participantWrapUpEndTime],
        [consultationsEstablished],
        [wrapUpCodeList],
        [campaignName],
        [transactionId],
        [destination],
        [participantWrapUpDuration],
        [customerJourneyDuration],
        [interactionDuration],
        [outboundPhoneCodeText],
        [chatType],
        [channelName],
        [creationTime],
        [wrapUpCode],
        [wrapUpShortCode],
        [blindTransferToQueue],
        [timeToAbandon],
        [state],
        [participantOfferActionTime],
        [outboundPhoneCodeListId],
        [transfers],
        [participantGroupId],
        [participantMute],
        [caseNumber],
        [participantHandlingEndTime],
        [facebookId],
        [participantOfferTime],
        [caseFollowUp],
        [ivrTreatmentDuration],
        [time],
        [customerName],
        [participantOfferDuration],
        [warmTransfersCompleted],
        [participantLongestHoldDuration],
        [origination],
        [participantLongestMuteDuration],
        [wrapUpCodeId],
        [outboundPhoneCodeId],
        [channelId],
        [participantOfferAction],
        [outboundPhoneCodeList],
        [wrapUpCodeListId],
        [participantName],
        [terminatedBy],
        [recordingFileNames],
        [dispositionAction],
        [mediaType],
        [interactionLabels],
        [interactionType],
        [participantHoldDuration],
        [queueWaitDuration],
        [originalTransactionId],
        [externalTransactionData],
        [twitterId],
        [participantHandlingDuration],
        [outcome],
        [campaignId],
        [outboundPhoneCode],
        [queueTime],
        [participantAssignNumber],
        [participantHold],
        [blindTransferToAgent],
        [participantMuteDuration],
        [direction],
        [agentNotes],
        [wrapUpCodeText],
        [participantType],
        [participantId],
        [conferencesEstablished],
        [queueId],
        [participantBusyDuration],
        [finishedTime],
        [participantProcessingDuration],
        [interactionId],
        [outboundPhoneShortCode],
        [queueName],
        [External Transaction Email Address],
        [queueWaitDuration_HHMMSS],
        [participantWrapUpDuration_HHMMSS],
        [customerJourneyDuration_HHMMSS],
        [interactionDuration_HHMMSS],
        [ivrTreatmentDuration_HHMMSS],
        [participantOfferDuration_HHMMSS],
        [participantLongestHoldDuration_HHMMSS],
        [participantLongestMuteDuration_HHMMSS],
        [participantHoldDuration_HHMMSS],
        [participantHandlingDuration_HHMMS],
        [participantMuteDuration_HHMMSS],
        [participantBusyDuration_HHMMSS],
        [participantProcessingDuration_HHMMSS]
    )
SELECT     
    TRY_CAST(time AS DATE) AS [Interaction Date],
    TRY_CAST(finishedTime AS DATE) AS [Finished Date],
    recordId,
    scheduleHours,
    participantGroupName,
    originalInteractionId,
    participantWrapUpEndTime,
    consultationsEstablished,
    wrapUpCodeList,
    campaignName,
    transactionId,
    destination,
    participantWrapUpDuration,
    customerJourneyDuration,
    interactionDuration,
    outboundPhoneCodeText,
    chatType,
    channelName,
    creationTime,
    wrapUpCode,
    wrapUpShortCode,
    blindTransferToQueue,
    timeToAbandon,
    state,
    participantOfferActionTime,
    outboundPhoneCodeListId,
    transfers,
    participantGroupId,
    participantMute,
    caseNumber,
    participantHandlingEndTime,
    facebookId,
    participantOfferTime,
    caseFollowUp,
    ivrTreatmentDuration,
    time,
    customerName,
    participantOfferDuration,
    warmTransfersCompleted,
    participantLongestHoldDuration,
    origination,
    participantLongestMuteDuration,
    wrapUpCodeId,
    outboundPhoneCodeId,
    channelId,
    participantOfferAction,
    outboundPhoneCodeList,
    wrapUpCodeListId,
    participantName,
    terminatedBy,
    recordingFileNames,
    dispositionAction,
    mediaType,
    interactionLabels,
    interactionType,
    participantHoldDuration,
    queueWaitDuration,
    originalTransactionId,
    externalTransactionData,
    twitterId,
    participantHandlingDuration,
    outcome,
    campaignId,
    outboundPhoneCode,
    queueTime,
    participantAssignNumber,
    participantHold,
    blindTransferToAgent,
    participantMuteDuration,
    direction,
    agentNotes,
    wrapUpCodeText,
    participantType,
    participantId,
    conferencesEstablished,
    queueId,
    participantBusyDuration,
    finishedTime,
    participantProcessingDuration,
    interactionId,
    outboundPhoneShortCode,
    queueName,
    CASE 
        WHEN externalTransactionData IS NOT NULL AND mediaType = 'CHAT' THEN
            SUBSTRING(
                externalTransactionData, 
                CHARINDEX('[E-mail|', externalTransactionData) + LEN('[E-mail|'), 
                CHARINDEX(']', externalTransactionData, CHARINDEX('[E-mail|', externalTransactionData)) - CHARINDEX('[E-mail|', externalTransactionData) - LEN('[E-mail|')
            )
        ELSE NULL
    END AS [External Transaction Email Address],
    CONVERT(varchar, DATEADD(SECOND, CEILING(CONVERT(bigint, queueWaitDuration) / 1000.0), 0), 108) AS queueWaitDuration_HHMMSS,
    CONVERT(varchar, DATEADD(SECOND, CEILING(CONVERT(bigint, participantWrapUpDuration) / 1000.0), 0), 108) AS participantWrapUpDuration_HHMMSS,
    CONVERT(varchar, DATEADD(SECOND, CEILING(CONVERT(bigint, customerJourneyDuration) / 1000.0), 0), 108) AS customerJourneyDuration_HHMMSS,
    CONVERT(varchar, DATEADD(SECOND, CONVERT(bigint, interactionDuration) / 1000, 0), 108) AS interactionDuration_HHMMSS,
    CONVERT(varchar, DATEADD(SECOND, CEILING(CONVERT(bigint, ivrTreatmentDuration) / 1000.0), 0), 108) AS ivrTreatmentDuration_HHMMSS,
    CONVERT(varchar, DATEADD(SECOND, CEILING(CONVERT(bigint, participantOfferDuration) / 1000.0), 0), 108) AS participantOfferDuration_HHMMSS,
    CONVERT(varchar, DATEADD(SECOND, CEILING(CONVERT(bigint, participantLongestHoldDuration) / 1000.0), 0), 108) AS participantLongestHoldDuration_HHMMSS,
    CONVERT(varchar, DATEADD(SECOND, CEILING(CONVERT(bigint, participantLongestMuteDuration) / 1000.0), 0), 108) AS participantLongestMuteDuration_HHMMSS,
    CONVERT(varchar, DATEADD(SECOND, CEILING(CONVERT(bigint, participantHoldDuration) / 1000.0), 0), 108) AS participantHoldDuration_HHMMSS,
    CONVERT(varchar, DATEADD(SECOND, CEILING(CONVERT(bigint, participantHandlingDuration) / 1000.0), 0), 108) AS participantHandlingDuration_HHMMS,
    CONVERT(varchar, DATEADD(SECOND, CEILING(CONVERT(bigint, participantMuteDuration) / 1000.0), 0), 108) AS participantMuteDuration_HHMMSS,
    CONVERT(varchar, DATEADD(SECOND, CONVERT(bigint, participantBusyDuration) / 1000, 0), 108) AS participantBusyDuration_HHMMSS,
    CONVERT(varchar, DATEADD(SECOND, CEILING(CONVERT(bigint, participantProcessingDuration) / 1000.0), 0), 108) AS participantProcessingDuration_HHMMSS
FROM [staging].[json_detailed_report_data];


    -- Get the number of records inserted
    SET @RecordsInserted = @@ROWCOUNT;

    -- Insert details into the control table
    INSERT INTO staging.ControlTableFactCustomerContactsDetailedReport (TableName, InsertDateTime, RecordsInserted)
    VALUES ('Fact_CustomerContacts_Detailed_Report', GETDATE(), @RecordsInserted);
END;
dwh	BuildFactDebtReliefOrder	-- =============================================
-- Author:      Ben Reeve
-- Create Date: 11/03/2025
-- Description: Builds table Fact_DebtReliefOrder. Only loads in DRO data for accounts where AccountTypeId = 9
-- =============================================
CREATE PROCEDURE [dwh].[BuildFactDebtReliefOrder]
AS
BEGIN
    -- SET NOCOUNT ON added to prevent extra result sets from
    -- interfering with SELECT statements.
    SET NOCOUNT ON

	TRUNCATE TABLE dwh.Fact_DebtReliefOrder;

	WITH DebtReliefOrder
    AS
    (
        SELECT --51
            rau.AccountId AS CxAccountId,
            ra.AccountReference,
            rau.DateDROGranted AS DateGranted,
            rau.DateDROCompleted AS DateCompleted,
            rau.DROReference,
            CAST(TRIM(REPLACE(REPLACE(rau.AmountRecordedonDRO, '£', ''), ',', '')) AS NUMERIC(8,2)) AS AmountRecordedOnDRO,
            CAST(TRIM(REPLACE(REPLACE(rau.AmountAdjustedonDRO, '£', ''), ',', '')) AS NUMERIC(8,2)) AS AmountAdjustedOnDRO,
            MAX(raa.AgreementEpisodeId) AS AgreementEpisodeId
        FROM 
            staging.cx_RentAccount_User rau 
        
            JOIN staging.cx_RentAccount ra
            ON rau.AccountId = ra.AccountId

            JOIN staging.cx_rentagreementaccount raa
            ON ra.AccountId = raa.AccountId

        WHERE 
            AccountTypeId = 9

        GROUP BY 
            rau.AccountId,
            ra.AccountReference,
            rau.DateDROGranted,
            rau.DateDROCompleted,
            rau.DROReference,
            CAST(TRIM(REPLACE(REPLACE(rau.AmountRecordedonDRO, '£', ''), ',', '')) AS NUMERIC(8,2)),
            CAST(TRIM(REPLACE(REPLACE(rau.AmountAdjustedonDRO, '£', ''), ',', '')) AS NUMERIC(8,2))
    )

	INSERT INTO dwh.Fact_DebtReliefOrder
	(
		CxAccountId,
		AccountReference,
		DateGranted,
		DateCompleted,
		DROReference,
		AmountRecordedOnDRO,
		AmoundAdjustedOnDRO,
        FactAgreementId

	)

    SELECT
        CxAccountId,
        AccountReference,
        DateGranted,
        DateCompleted,
        DROReference,
        AmountRecordedOnDRO,
        AmountAdjustedOnDRO,
        fa.FactAgreementId

    FROM
        DebtReliefOrder dro

        JOIN staging.cx_rentagreementepisode rae
        ON dro.AgreementEpisodeId = rae.AgreementEpisodeId

        JOIN dwh.Fact_Agreement fa
        ON rae.AgreementId = fa.CxAgreementId

	-- SELECT
	-- 	rau.AccountId AS CxAccountId,
	-- 	ra.AccountReference,
	-- 	rau.DateDROGranted AS DateGranted,
	-- 	rau.DateDROCompleted AS DateCompleted,
	-- 	rau.DROReference,
	-- 	CAST(TRIM(REPLACE(REPLACE(rau.AmountRecordedonDRO, '£', ''), ',', '')) AS NUMERIC(8,2)) AS AmountRecordedOnDRO,
	-- 	CAST(TRIM(REPLACE(REPLACE(rau.AmountAdjustedonDRO, '£', ''), ',', '')) AS NUMERIC(8,2)) AS AmountAdjustedOnDRO
	
	-- FROM 
	-- 	staging.cx_RentAccount_User rau 
	
	-- 	JOIN staging.cx_RentAccount ra
	-- 	ON rau.AccountId = ra.AccountId

	-- WHERE 
	-- 	AccountTypeId = 9
END
dwh	BuildFactDecant	-- =============================================
-- Author:      Ben Reeve
-- Create Date: 01/04/2025
-- Description: Builds Fact Decant based on rent agreement episodes where start reason code is 13 for Decant and tenure type = 5 for Licence
-- =============================================
CREATE PROCEDURE [dwh].[BuildFactDecant]
AS
BEGIN
    -- SET NOCOUNT ON added to prevent extra result sets from
    -- interfering with SELECT statements.
    SET NOCOUNT ON

	TRUNCATE TABLE dwh.Fact_Decant;

	INSERT INTO dwh.Fact_Decant
	(
		DimAssetId,
		FactAgreementId,
		StartDate,
		EndDate,
		IsCurrent,
		CxAssetId
	)

	SELECT
		ass.DimAssetId,
		agr.FactAgreementId AS FactAgreementId,
		rae.EffectiveFromDate AS StartDate,
		rae.EffectiveToDate AS EndDate,
		CASE
			WHEN rae.EffectiveFromDate <= GETDATE() AND (rae.EffectiveToDate IS NULL OR rae.EffectiveToDate > GETDATE()) THEN 1
			ELSE 0
		END AS IsCurrent,
		ass.AssetId


	FROM 
		staging.cx_rentagreementepisode rae 

		LEFT JOIN staging.cx_rentagreementtenuretype ratt
		ON rae.AgreementTenureTypeId = ratt.AgreementTenureTypeID

		JOIN staging.cx_rentagreementasset raa
		ON rae.AgreementId = raa.AgreementId

		JOIN dwh.Dim_Asset ass
		ON raa.AssetId = ass.CxAssetId

		JOIN dwh.Fact_Agreement agr
		ON rae.AgreementId = agr.CxAgreementId

	WHERE 
		rae.StartReasonId = 13
		AND ratt.TenureTypeID = 5 -- (5 = Licence, from Lookup where LookupTypeId = 37)
		AND (rae.EffectiveToDate IS NULL OR rae.EffectiveToDate > rae.EffectiveFromDate)

END
dwh	BuildFactDecentHomesAssessment	-- =============================================
-- Author:      Ben Reeve
-- Create Date: 10/03/2025
-- Description: Builds Fact_DcentHomesAssessment
-- =============================================
CREATE PROCEDURE [dwh].[BuildFactDecentHomesAssessment]
AS
BEGIN
    -- SET NOCOUNT ON added to prevent extra result sets from
    -- interfering with SELECT statements.
    SET NOCOUNT ON

	TRUNCATE TABLE dwh.Fact_DecentHomesAssessment;

	WITH LatestResult
	AS
	(
		SELECT
			intAssetId,
			MAX(dteDateUpdated) AS LatestDate

		FROM
			staging.keystone_tblDHAssetResult ar

		GROUP BY
			intAssetId
	)


	INSERT INTO dwh.Fact_DecentHomesAssessment
	(
		DimAssetId,
		DateCompleted,
		TenantRefusal,
		--TenantRefusalDetails, Column source not clear from spec
		ResultId,
		Result,
		IsLatest,
		CxAssetId,
		PotentiallyNonDecentYear,
		NonDecentYear
	)

	SELECT 
		dass.DimAssetId,
		ar.dteDateUpdated AS DateCompleted,
		ar.bitTenantRefusalOverride AS TenantRefusal,
		--TenantRefusalDetails, Column source not clear from spec
		ar.intResultID AS ResultId,
		vr.vchResultDesc AS Result,
		CASE
			WHEN ar.dteDateUpdated = lr.LatestDate THEN 1
			ELSE 0
		END AS IsLatest,
		dass.AssetId,
		ar.intPNDYear AS PotentiallyNonDecentYear,
		ar.intNDYear AS NonDecentYear

	FROM 
		staging.keystone_tblDHAssetResult ar

		LEFT JOIN staging.keystone_tblasset kass
		ON ar.intAssetId = kass.intAssetID

		JOIN staging.cx_asset cass
		ON kass.vchUPRN = cass.AssetReference

		JOIN dwh.Dim_Asset dass
		ON cass.AssetId = dass.CxAssetId

		LEFT JOIN staging.keystone_tblDHValidResult vr
		ON ar.intResultID = vr.intResultID

		LEFT JOIN LatestResult lr
		ON ar.intAssetId = lr.intAssetId
		AND ar.dteDateUpdated = lr.LatestDate
END
dwh	BuildFactEightByEight	

CREATE PROCEDURE [dwh].[BuildFactEightByEight]
AS
BEGIN
    SET NOCOUNT ON;

	-- Drop the target Fact Table
	DROP TABLE [dwh].[Fact_EightByEight];

    -- Insert into the transform table from the staging table
    SELECT 
        [ID],
        [dnis] AS [DNIS],
        [aaDestination] AS [AA Destination],
        [callId] AS [Call Id],
        [startTimeUTC] AS [Start Time UTC],
        [startTime] AS [Start Time],
		CAST([startTime] AS DATE) AS [Start Date],
        [connectTimeUTC] AS [Connect Time UTC],
        [connectTime] AS [Connect Time],
        [disconnectedTimeUTC] AS [Disconnected Time UTC],
        [disconnectedTime] AS [Disconnected Time],
		CAST([disconnectedTime] AS DATE) AS [Disconnected Date],
        [talkTimeMS] AS [Talk Time MS],
        [talkTime] AS [Talk Time],
        [caller] AS [Caller],
        [callerName] AS [Caller Name],
        [callee] AS [Callee],
        [calleeName] AS [Callee Name],
        [direction] AS [Direction],
        [callerId] AS [Caller Id],
        [missed] AS [Missed],
        [abandoned] AS [Abandoned],
        [answered] AS [Answered],
        [answeredTime] AS [Answered Time],
        [calleeDisconnectOnHold] AS [Callee Disconnect On Hold],
        [callerDisconnectOnHold] AS [Caller Disconnect On Hold],
        [pbxId] AS [Pbx Id],
        [sipCallId] AS [Sip Call Id],
        [lastLegDisposition] AS [Last Leg Disposition],
        [callLegCount] AS [Call Leg Count],
        [callTime] AS [Call Time],
        [ringDuration] AS [Ring Duration],
        [abandonedTime] AS [Abandoned Time],
        [calleeHoldDurationMS] AS [Callee Hold Duration MS],
        [calleeHoldDuration] AS [Callee Hold Duration],
        [waitTimeMS] AS [Wait Time MS],
        [waitTime] AS [Wait Time],
        [departments] AS [Departments],
        [branches] AS [Branches],
        [ControlID] AS [Control ID]
    INTO [dwh].[Fact_EightByEight]
    FROM [staging].[eightbyeight]
	WHERE 1=1
	--AND [ControlID] = (SELECT MAX([ControlID]) FROM [staging].[eightbyeight])
	;

END
dwh	BuildFactElecticalGasNoAccess	CREATE PROCEDURE [dwh].[BuildFactElecticalGasNoAccess]
AS

    TRUNCATE TABLE dwh.Fact_GasElectricalNoAccess

    DROP TABLE IF EXISTS #Electrical

    select
       KIR_JM_JOB_ATTRIBUTES."JJA_VALUE" AS "JobNumber",
       JJH_JJS_CODE as JobJJSCode,
       case  at2.JJA_VALUE  WHEN 'NO ACCESS' THEN  'NO ACCESS' ELSE 'JOB_DONE' END as JobJJRCode,
       jjh_datetime as  JobDateTime,
       a1."KJLIA_VALUE" AS JobAppliance,
       a2."KJLIA_VALUE" AS JobApplianceId,
       a3."KJLIA_VALUE" AS JobApplianceLocation,
       a4."KJLIA_VALUE" AS JobApplianceReference,
       a5."KJLIA_VALUE" AS JobAppliancecode,
       'Electrical Periodic Test' AS JobTestType    
    INTO #Electrical
    from Staging.JobManager_KIR_JM_JOB_HISTORY KIR_JM_JOB_HISTORY
    INNER JOIN Staging.JobManager_KIR_JM_JOB KIR_JM_JOB
    ON KIR_JM_JOB."JJB_ORG_ID" = KIR_JM_JOB_HISTORY."JJH_ORG_ID" AND
    KIR_JM_JOB."JJB_ID" = KIR_JM_JOB_HISTORY."JJH_JJB_ID"
    INNER JOIN Staging.JobManager_KIR_JM_JOB_LINE_INSTANCE KIR_JM_JOB_LINE_INSTANCE
    ON KIR_JM_JOB_LINE_INSTANCE."KJLI_JJB_ID" = KIR_JM_JOB."JJB_ID"
    INNER JOIN Staging.JobManager_KIR_JM_JOB_ATTRIBUTES KIR_JM_JOB_ATTRIBUTES
    ON KIR_JM_JOB_ATTRIBUTES."JJA_ORG_ID" = KIR_JM_JOB."JJB_ORG_ID"
    AND KIR_JM_JOB_ATTRIBUTES."JJA_JBB_ID" = KIR_JM_JOB."JJB_ID"
    AND KIR_JM_JOB_ATTRIBUTES."JJA_ATR_NAME" = 'DRS_PRIMARY_ORDER_NO'
    LEFT OUTER  JOIN Staging.JobManager_KIR_JM_JOB_LINE_INST_ATTRIB a1
    ON a1."KJLIA_ORG_ID" = KIR_JM_JOB."JJB_ORG_ID"
    AND a1."KJLIA_KJLI_ID" = KIR_JM_JOB_LINE_INSTANCE."KJLI_ID"
    AND a1."KJLIA_JAT_NAME" = 'JM_REPAIR_CP12_APP_DESC'
    LEFT OUTER  JOIN Staging.JobManager_KIR_JM_JOB_LINE_INST_ATTRIB a2
    ON a2."KJLIA_ORG_ID" = KIR_JM_JOB."JJB_ORG_ID"
    AND a2."KJLIA_KJLI_ID" = KIR_JM_JOB_LINE_INSTANCE."KJLI_ID"
    AND a2."KJLIA_JAT_NAME" = 'JM_REPAIR_CP12_APP_ID'
    LEFT OUTER  JOIN Staging.JobManager_KIR_JM_JOB_LINE_INST_ATTRIB a3
    ON a3."KJLIA_ORG_ID" = KIR_JM_JOB."JJB_ORG_ID"
    AND a3."KJLIA_KJLI_ID" = KIR_JM_JOB_LINE_INSTANCE."KJLI_ID"
    AND a3."KJLIA_JAT_NAME" = 'JM_REPAIR_APP_LOCATION'
    LEFT OUTER JOIN Staging.JobManager_KIR_JM_JOB_LINE_INST_ATTRIB a4
    ON a4."KJLIA_ORG_ID" = KIR_JM_JOB."JJB_ORG_ID"
    AND a4."KJLIA_KJLI_ID" = KIR_JM_JOB_LINE_INSTANCE."KJLI_ID"
    AND a4."KJLIA_JAT_NAME" = 'JM_REPAIR_APP_REF'
    LEFT OUTER JOIN Staging.JobManager_KIR_JM_JOB_LINE_INST_ATTRIB a5
    ON a5."KJLIA_ORG_ID" = KIR_JM_JOB."JJB_ORG_ID"
    AND a5."KJLIA_KJLI_ID" = KIR_JM_JOB_LINE_INSTANCE."KJLI_ID"
    AND a5."KJLIA_JAT_NAME" = 'JM_REPAIR_CP12_APP_CODE'
    INNER JOIN Staging.JobManager_KIR_JM_JOB_LINE_INST_ATTRIB a6
    ON a6."KJLIA_ORG_ID" = KIR_JM_JOB."JJB_ORG_ID"
    AND a6."KJLIA_KJLI_ID" = KIR_JM_JOB_LINE_INSTANCE."KJLI_ID"
    AND a6."KJLIA_JAT_NAME" = 'JM_REPAIR_SOR_CODE'
    AND a6."KJLIA_VALUE" = '895001PD'
    LEFT OUTER JOIN Staging.JobManager_KIR_JM_JOB_ATTRIBUTES at2
    ON at2."JJA_ORG_ID" = KIR_JM_JOB."JJB_ORG_ID"
    AND at2."JJA_JBB_ID" = KIR_JM_JOB."JJB_ID"
    AND at2."JJA_ATR_NAME" = 'PD_JOB_OUTCOME_PD_RR_ABORTED'
    LEFT OUTER JOIN Staging.JobManager_KIR_JM_JOB_ATTRIBUTES at3
    ON at3."JJA_ORG_ID" = KIR_JM_JOB."JJB_ORG_ID"
    AND at3."JJA_JBB_ID" = KIR_JM_JOB."JJB_ID"
    AND at3."JJA_ATR_NAME" = 'PD_JOB_OUTCOME_PD_RR_COMPLETED'
    where JJH_ORG_ID = 1
    AND (jjh_datetime) > ('01/04/2021')
    AND JJH_JJS_CODE = 'COMPLETED'
    AND (( at3.JJA_VALUE IS NULL AND
            at2.JJA_VALUE = 'NO ACCESS')  OR
            ( at3.JJA_VALUE = 'COMPLETED' AND
            at2.JJA_VALUE IS NULL)  )
    AND JJB_JJT_CODE <> 'PD_GAS_SERVICE'
    AND KIR_JM_JOB_LINE_INSTANCE."KJLI_JLT_CODE" <> 'JM_REPAIR_APPLIANCE_GAS';
    
    INSERT INTO dwh.Fact_GasElectricalNoAccess ([JobNumber]
      ,[JobJJRCode]
      ,[JobDate]
      ,[JobNoAccessFlag]
      ,[JobTestType]
      ,[JobNoAccessFlagLastThreeYears]
      ,[AgreementId]
      ,[ContactGroupId]
      ,[AssetId])
    SELECT DISTINCT 
    e.JobNumber, 
    e.JobJJRCode, 
    CAST(e.JobDateTime as Date) as JobDate, 
    1 as JobNoAccessFlag, 
    e.JobTestType,
    case when dateadd(year,-3,getdate()) <= CAST(e.JobDateTime as Date) then 1 else 0 end as JobNoAccessFlagLastThreeYears,
    r.AgreementId,
    r.ContactGroupId,
    r.AssetId
    FROM #Electrical e  
    left join dwh.dim_repair r on e.JobNumber = r.JobNumber 
    WHERE e.JobJJRCode = 'NO ACCESS' 
    

    DROP TABLE IF EXISTS #Gas

    select DISTINCT
       KIR_JM_JOB_ATTRIBUTES."JJA_VALUE" AS "JobNumber",
       JJH_JJS_CODE as JobJJSCode,
       at4.JJA_VALUE,
       case   at4.JJA_VALUE  WHEN 'COMPLETED' THEN  'JOB_DONE' ELSE 'NO ACCESS' END  as JobJJRCode,
       jjh_datetime as  JobDateTime,
       a1."KJLIA_VALUE" AS JobAppliance,
       a2."KJLIA_VALUE" AS JobApplianceId,
       a3."KJLIA_VALUE" AS JobApplianceLocation,
       a4."KJLIA_VALUE" AS JobApplianceReference,
       a5."KJLIA_VALUE" AS JobAppliancecode,
       'Annual Gas Service' AS JobTestType,  
       CASE WHEN a6."KJLIA_VALUE" = 'N' THEN 'True' ELSE 'False' END AS JobApplianceLandlords    
    INTO #Gas
from staging.jobmanager_kir_jm_job_history as KIR_JM_JOB_HISTORY 
INNER JOIN staging.jobmanager_kir_jm_job as KIR_JM_JOB 
ON KIR_JM_JOB."JJB_ORG_ID" = KIR_JM_JOB_HISTORY."JJH_ORG_ID" AND
   KIR_JM_JOB."JJB_ID" = KIR_JM_JOB_HISTORY."JJH_JJB_ID"
LEFT OUTER JOIN staging.jobmanager_kir_jm_job_line_instance as JLI1
ON JLI1."KJLI_JJB_ID" = KIR_JM_JOB."JJB_ID" 
AND JLI1."KJLI_JLT_CODE" = 'JM_REPAIR_APPLIANCE_GAS'
LEFT OUTER JOIN staging.jobmanager_kir_jm_job_line_instance as JLI2
ON JLI2."KJLI_JJB_ID" = KIR_JM_JOB."JJB_ID"
AND JLI2."KJLI_JLT_CODE" = 'JM_REPAIR_SOR'
INNER JOIN staging.jobmanager_kir_jm_job_attributes as KIR_JM_JOB_ATTRIBUTES
ON KIR_JM_JOB_ATTRIBUTES."JJA_ORG_ID" = KIR_JM_JOB."JJB_ORG_ID"
AND KIR_JM_JOB_ATTRIBUTES."JJA_JBB_ID" = KIR_JM_JOB."JJB_ID"
AND KIR_JM_JOB_ATTRIBUTES."JJA_ATR_NAME" = 'DRS_PRIMARY_ORDER_NO'
LEFT OUTER JOIN staging.jobmanager_kir_jm_job_line_inst_attrib a1
ON a1."KJLIA_ORG_ID" = KIR_JM_JOB."JJB_ORG_ID"
AND a1."KJLIA_KJLI_ID" = JLI1."KJLI_ID"
AND a1."KJLIA_JAT_NAME" = 'JM_REPAIR_CP12_APP_DESC'
LEFT OUTER  JOIN staging.jobmanager_kir_jm_job_line_inst_attrib a2
ON a2."KJLIA_ORG_ID" = KIR_JM_JOB."JJB_ORG_ID"
AND a2."KJLIA_KJLI_ID" = JLI1."KJLI_ID"
AND a2."KJLIA_JAT_NAME" = 'JM_REPAIR_CP12_APP_ID'
LEFT OUTER  JOIN staging.jobmanager_kir_jm_job_line_inst_attrib a3
ON a3."KJLIA_ORG_ID" = KIR_JM_JOB."JJB_ORG_ID"
AND a3."KJLIA_KJLI_ID" = JLI1."KJLI_ID"
AND a3."KJLIA_JAT_NAME" = 'JM_REPAIR_APP_LOCATION'
LEFT OUTER JOIN staging.jobmanager_kir_jm_job_line_inst_attrib a4
ON a4."KJLIA_ORG_ID" = KIR_JM_JOB."JJB_ORG_ID"
AND a4."KJLIA_KJLI_ID" = JLI1."KJLI_ID"
AND a4."KJLIA_JAT_NAME" = 'JM_REPAIR_APP_REF'
LEFT OUTER JOIN staging.jobmanager_kir_jm_job_line_inst_attrib a5
ON a5."KJLIA_ORG_ID" = KIR_JM_JOB."JJB_ORG_ID"
AND a5."KJLIA_KJLI_ID" = JLI1."KJLI_ID"
AND a5."KJLIA_JAT_NAME" = 'JM_REPAIR_CP12_APP_CODE'
LEFT OUTER JOIN staging.jobmanager_kir_jm_job_line_inst_attrib a6
ON a6."KJLIA_ORG_ID" = KIR_JM_JOB."JJB_ORG_ID"
AND a6."KJLIA_KJLI_ID" = JLI1."KJLI_ID"
AND a6."KJLIA_JAT_NAME" = 'JM_REPAIR_APP_LANDLORDS'
INNER JOIN staging.jobmanager_kir_jm_job_line_inst_attrib a7
ON a7."KJLIA_ORG_ID" = KIR_JM_JOB."JJB_ORG_ID"
AND a7."KJLIA_KJLI_ID" = JLI2."KJLI_ID"
AND a7."KJLIA_JAT_NAME" = 'JM_REPAIR_SOR_CODE'
AND a7."KJLIA_VALUE" = '999998PD'
LEFT OUTER JOIN staging.jobmanager_kir_jm_job_attributes at2
ON at2."JJA_ORG_ID" = KIR_JM_JOB."JJB_ORG_ID"
AND at2."JJA_JBB_ID" = KIR_JM_JOB."JJB_ID"
AND at2."JJA_ATR_NAME" = 'PD_JOB_OUTCOME_PD_RR_ABORTED'
LEFT OUTER JOIN staging.jobmanager_kir_jm_job_attributes at3
ON at3."JJA_ORG_ID" = KIR_JM_JOB."JJB_ORG_ID"
AND at3."JJA_JBB_ID" = KIR_JM_JOB."JJB_ID"
AND at3."JJA_ATR_NAME" = 'PD_JOB_OUTCOME_PD_RR_COMPLETED'
LEFT OUTER JOIN staging.jobmanager_kir_jm_job_attributes at4
ON at4."JJA_ORG_ID" = KIR_JM_JOB."JJB_ORG_ID"
AND at4."JJA_JBB_ID" = KIR_JM_JOB."JJB_ID"
AND at4."JJA_ATR_NAME" = 'JOB_OUTCOME_PD_RR'
where JJH_ORG_ID = 1
AND (jjh_datetime) > '01/04/2021'
AND (at4.JJA_VALUE = 'COMPLETED' OR
         at4.JJA_VALUE = 'FO-Planned' OR
         at4.JJA_VALUE = 'NO ACCESS')
AND JJB_JJT_CODE = 'PD_GAS_SERVICE';
    

--select top 100 * from #Gas where JobNumber = '12111652'


    INSERT INTO dwh.Fact_GasElectricalNoAccess ([JobNumber]
      ,[JobJJRCode]
      ,[JobDate]
      ,[JobNoAccessFlag]
      ,[JobTestType]
      ,[JobNoAccessFlagLastThreeYears]
      ,[AgreementId]
      ,[ContactGroupId]
      ,[AssetId])
    SELECT DISTINCT 
    g.JobNumber, 
    g.JobJJRCode, 
    CAST(g.JobDateTime as Date) as JobDate, 
    1 as JobNoAccessFlag, 
    g.JobTestType,
    case when dateadd(year,-3,getdate()) <= CAST(g.JobDateTime as Date) then 1 else 0 end as JobNoAccessFlagLastThreeYears,
    r.AgreementId,
    r.ContactGroupId,
    r.AssetId
    FROM #Gas g  
    left join dwh.dim_repair r on g.JobNumber = r.JobNumber 
    WHERE g.JobJJRCode = 'NO ACCESS' 


dwh	BuildFactEviction	-- =============================================
-- Author:      Ben Reeve
-- Create Date: 20/03/2025
-- Description: Build table Fact_Eviction based up agreement termination reason in the rentagreement table where codes used are related to eviction.
-- =============================================
CREATE PROCEDURE [dwh].[BuildFactEviction]
AS
BEGIN
    -- SET NOCOUNT ON added to prevent extra result sets from
    -- interfering with SELECT statements.
    SET NOCOUNT ON

	TRUNCATE TABLE dwh.Fact_Eviction;

	WITH AgreementAccount
	AS
	(
		SELECT DISTINCT 
			rae.AgreementId, 
			raa.AccountId

		FROM 
			staging.cx_rentagreementepisode rae 
	
			JOIN staging.cx_rentagreementaccount raa
			ON rae.AgreementEpisodeId = raa.AgreementEpisodeId

			WHERE raa.MainAccount = 1
	)

	INSERT INTO dwh.Fact_Eviction
	(
		DimAssetId,
		DimAgreementId,
		CxAccountId,
		EvictionDate,
		IsASB,
		IsArrears,
		IsOther,
		Reason,
		CxAssetId,
		CxAgreementId
	)

	SELECT DISTINCT 
		ass.DimAssetId,
		agr.FactAgreementId,
		aa.AccountId AS CxAccountId,
		ra.EndDate AS EvictionDate,
		CASE
			WHEN lu.LookupReference = 28 THEN 1
			ELSE 0
		END AS IsASB,
		CASE
			WHEN lu.LookupReference = 13 THEN 1
			ELSE 0
		END AS IsArrears,
		CASE
			WHEN lu.LookupReference NOT IN (13, 28) THEN 1
			ELSE 0
		END AS IsOther,
		lu.Description AS Reason,
		ass.AssetId,
		agr.CxAgreementId

	FROM 
		staging.cx_rentagreement ra 
	
		JOIN staging.cx_lookup lu
		ON ra.TerminationReasonId = lu.LookupReference
		AND lu.LookupTypeId = 70
		AND Description LIKE '%eviction%'
		AND ra.StartDate < ra.EndDate

		JOIN staging.cx_rentagreementasset raa
		ON ra.AgreementId = raa.AgreementId

		JOIN dwh.Dim_Asset ass
		ON raa.AssetId = ass.CxAssetId

		JOIN dwh.Fact_Agreement agr
		ON ra.AgreementId = agr.CxAgreementId

		JOIN AgreementAccount aa
		ON ra.AgreementId = aa.AgreementId
END
dwh	BuildFactFloatingSupport	-- =============================================
-- Author:      Ben Reeve
-- Create Date: 14/04/2025
-- Description: Builds Fact Floating Support
-- =============================================

CREATE PROCEDURE [dwh].[BuildFactFloatingSupport]
AS
BEGIN

	TRUNCATE TABLE dwh.Fact_FloatingSupport
    
    INSERT INTO dwh.Fact_FloatingSupport
    (
        CxCaseId,
        DateCreated,
        DateCompleted,
        DaysToComplete
    )


--Logic from Jim to identify cases
    SELECT DISTINCT
        c.CxCaseId,
        c.StartDate AS DateCreated,
        --DateAssignedToSupportWork - not yet known
        c.EndDate AS DateCompleted,
        --DaysAssigned to SupportWorker - not yet known
        DATEDIFF(dd, c.StartDate, c.EndDate) AS DaysToComplete

    FROM 
         dwh.Fact_Case c

        JOIN dwh.Fact_CaseTask fct 
        on c.FactCaseId = fct.FactCaseId

        JOIN dwh.Fact_Form ff 
        ON fct.CxTaskId = ff.ParentEntityId
        AND ff.ParentEntityType = 'CRM Task'

        JOIN dwh.Fact_FormAnswers f 
        ON ff.FactFormId = f.FactFormId

    WHERE 
        f.answer = 'Floating Support'
        AND f.IsLatest = 1
        AND c.CRMSubjectId = 190


	--Maybe this was Carls code? Will keep just in case.

	/*TRUNCATE TABLE dwh.Fact_FloatingSupport;

	DROP TABLE IF EXISTS #FloatingSupportTemp;

	;with FloatingSupportCases as 
	(
		select 
		c.CaseId as CaseId,
		c.CaseCreatedDate as CaseCreatedDate,
		c.CaseEndDate as CaseCompletedDate,
		c.ContactId as ContactId,
		fct.Status
	from dwh.Fact_CaseTask fct 
	join dwh.Fact_Form ff on fct.CxTaskId = ff.ParentEntityId
		and ff.ParentEntityType = 'CRM Task'
	join dwh.Fact_FormAnswers f on ff.FactFormId = f.FactFormId
	join dwh.Dim_Case c on fct.CxCaseId = c.CaseId and CaseGenericType = 'Referral Case'
	where 
		f.answer = 'floating support'
		and f.IsLatest = 1
	),
	FloatingSupportAgreement as
	(
	SELECT
		a.AgreementId,
		c.CaseId,
		cgm.ContactGroupId,
		c.CaseCreatedDate,
		c.CaseCompletedDate,
		c.Status,
		ROW_NUMBER() OVER (PARTITION BY a.AgreementId ORDER BY c.CaseCreatedDate) AS rn
	FROM staging.cx_rentagreementepisode a 
	LEFT JOIN staging.cx_contactgroupmember cgm 
	ON a.ContactGroupId = cgm.ContactGroupId
	LEFT JOIN FloatingSupportCases c 
	ON cgm.ContactId = c.ContactId
	WHERE
	c.CaseCreatedDate >= cgm.EffectiveFromDate
	AND (c.CaseCreatedDate < cgm.EffectiveToDate OR cgm.EffectiveToDate IS NULL)
	AND c.CaseCreatedDate >= a.EffectiveFromDate
	AND (c.CaseCreatedDate < a.EffectiveToDate OR a.EffectiveToDate IS NULL)
	)
	SELECT AgreementId, ContactGroupId, CaseId, CaseCreatedDate, CaseCompletedDate, Status, 		
	DATEDIFF(DD,CaseCreatedDate,CaseCompletedDate) as DaysToComplete

	INTO #FloatingSupportTemp
	FROM FloatingSupportAgreement
	WHERE rn = 1;


    INSERT INTO dwh.Fact_FloatingSupport (
        [FactFloatingSupportCaseId],
		[CxCaseId],
		[DateCreated],
		DateAssignedToSupportWorker,
		[DateCompleted],
		DaysToAssignToSupportWorker,
		[DaysToComplete]
    )
    SELECT
        CaseId,
        CaseId,
        CaseCreatedDate,
        null as DateAssignedToSupportWorker,
		CaseCompletedDate,
        null as DaysToAssignToSupportWorker,
        DaysToComplete
    FROM #FloatingSupportTemp;*/


END;
dwh	BuildFactFloatingSupportCase	
CREATE PROCEDURE [dwh].[BuildFactFloatingSupportCase]
AS
BEGIN

	TRUNCATE TABLE dwh.Fact_FloatingSupport;

	DROP TABLE IF EXISTS #FloatingSupportTemp;

	;with FloatingSupportCases as 
	(
		select 
		c.CaseId as CaseId,
		c.CaseCreatedDate as CaseCreatedDate,
		c.CaseEndDate as CaseCompletedDate,
		c.ContactId as ContactId,
		fct.Status
	from dwh.Fact_CaseTask fct 
	join dwh.Fact_Form ff on fct.CxTaskId = ff.ParentEntityId
		and ff.ParentEntityType = 'CRM Task'
	join dwh.Fact_FormAnswers f on ff.FactFormId = f.FactFormId
	join dwh.Dim_Case c on fct.CxCaseId = c.CaseId and CaseGenericType = 'Referral Case'
	where 
		f.answer = 'floating support'
		and f.IsLatest = 1
	),
	FloatingSupportAgreement as
	(
	SELECT
		a.AgreementId,
		c.CaseId,
		cgm.ContactGroupId,
		c.CaseCreatedDate,
		c.CaseCompletedDate,
		c.Status,
		ROW_NUMBER() OVER (PARTITION BY a.AgreementId ORDER BY c.CaseCreatedDate) AS rn
	FROM staging.cx_rentagreementepisode a 
	LEFT JOIN staging.cx_contactgroupmember cgm 
	ON a.ContactGroupId = cgm.ContactGroupId
	LEFT JOIN FloatingSupportCases c 
	ON cgm.ContactId = c.ContactId
	WHERE
	c.CaseCreatedDate >= cgm.EffectiveFromDate
	AND (c.CaseCreatedDate < cgm.EffectiveToDate OR cgm.EffectiveToDate IS NULL)
	AND c.CaseCreatedDate >= a.EffectiveFromDate
	AND (c.CaseCreatedDate < a.EffectiveToDate OR a.EffectiveToDate IS NULL)
	)
	SELECT AgreementId, ContactGroupId, CaseId, CaseCreatedDate, CaseCompletedDate, Status, 		
	DATEDIFF(DD,CaseCreatedDate,CaseCompletedDate) as DaysToComplete

	INTO #FloatingSupportTemp
	FROM FloatingSupportAgreement
	WHERE rn = 1;


    INSERT INTO dwh.Fact_FloatingSupport (
        [FactFloatingSupportCaseId],
		[CxCaseId],
		[DateCreated],
		DateAssignedToSupportWorker,
		[DateCompleted],
		DaysToAssignToSupportWorker,
		[DaysToComplete]
    )
    SELECT
        CaseId,
        CaseId,
        CaseCreatedDate,
        null as DateAssignedToSupportWorker,
		CaseCompletedDate,
        null as DaysToAssignToSupportWorker,
        DaysToComplete
    FROM #FloatingSupportTemp;


END;
dwh	BuildFactForm	-- =============================================
-- Author:      Ben Reeve
-- Create Date: 02/04/2025
-- Description: Builds Fact Form. Adapted from script provided by Jim Walker at iStride Ltd.
-- =============================================
CREATE PROCEDURE [dwh].[BuildFactForm]
AS
BEGIN
    -- SET NOCOUNT ON added to prevent extra result sets from
    -- interfering with SELECT statements.
    SET NOCOUNT ON

	TRUNCATE TABLE dwh.Fact_Form;

	INSERT INTO dwh.Fact_Form
	(
			CxFormInstanceId, 
			FormReference, 
			StatusId,
			Status,
			CreatedDate,
			ParentEntityType,
			ParentEntityId 
	)

	SELECT 
		fi.FormInstanceId AS FormInstanceId,
		fi.FormReference AS Reference,
		fi.StatusId AS StatusId,
		fsc.Description AS Status,
		fi.CreatedDate AS CreatedDate,
		sl24.Description AS ParentEntityType,
		fi.ParentEntityID

	FROM 
		staging.cx_FormInstance fi

		JOIN staging.cx_FormStatus fs 
		ON fi.StatusId = fs.FormStatusId

		JOIN staging.cx_FormStatusCode fsc 
		ON fs.FormStatusCodeId = fsc.FormStatusCodeId

		JOIN staging.cx_SystemLookup sl24 
		ON fi.ParentEntityTypeID = sl24.LookupReference 
		AND sl24.LookupTypeId = 24

END
dwh	BuildFactFormAnswers	-- =============================================
-- Author:      Ben Reeve
-- Create Date: 02/04/2025
-- Description: Builds Fact FormAnswers. Adapted from script provided by Jim Walker at iStride Ltd.
-- =============================================
CREATE PROCEDURE [dwh].[BuildFactFormAnswers]
AS
BEGIN
    -- SET NOCOUNT ON added to prevent extra result sets from
    -- interfering with SELECT statements.
    SET NOCOUNT ON

	TRUNCATE TABLE dwh.Fact_FormAnswers;

	WITH FormJson
	AS
	(
		SELECT 
			fdv.FormDefinitionId,
			fdv.FormDefinitionVersionID, 
			fdv.FormTemplateValue 
			
		FROM 
			staging.cx_FormDefinitionVersion fdv 
			
		WHERE
			ISJSON(fdv.FormTemplateValue) = 1
	)

	SELECT
		fj.FormDefinitionId,
		fj.FormDefinitionVersionID,
		QuestionOrder,
		FieldPath as QuestionPath, 
		FieldId,
		MAX(CASE WHEN Property = 'name' THEN Value END) AS FieldName,
		MAX(CASE WHEN Property = 'type' THEN Value END) AS Type,
		MAX(CASE WHEN Property = 'label' THEN Value END) AS Label

	INTO
		#FormDefinition

	FROM 
		FormJson fj

		CROSS APPLY dwh.fn_FlattenJSONFormDefinition(fj.FormTemplateValue)
	WHERE 
		Property in ('label','name','type')

	GROUP BY 
		fj.FormDefinitionId,
		fj.FormDefinitionVersionID,
		QuestionOrder,
		FieldPath,
		FieldId

	HAVING
		MAX(CASE WHEN Property = 'type' THEN Value END) NOT IN ('object','page','section','text','label','group','SignatureCaptureField')


	SELECT
		ff.FactFormId,
		ROW_NUMBER() OVER (PARTITION BY fiv.FormInstanceVersionID ORDER BY (SELECT NULL)) AS FactFormAnswerId,
		fiv.FormInstanceID,
		fiv.FormInstanceVersionID,
		fdv.FormDefinitionId as FormDefinitionId,
		fi.FormDefinitionVersionID as FormDefinitionVersionID,
		fiv.Version,
		fiv.CreatedDate,
		fjson.KeyPath AS AnswerPath,
		fjson.FieldId,
		fjson.AnswerOrder,
		TRY_CAST(fjson.Value AS NVARCHAR(MAX)) AS Answer

	INTO
		#FormAnswers

	FROM 
		staging.cx_FormInstanceVersion fiv

		JOIN staging.cx_FormInstance fi 
		ON fiv.FormInstanceID = fi.FormInstanceID

		JOIN staging.cx_FormDefinitionVersion fdv 
		ON fi.FormDefinitionVersionID = fdv.FormDefinitionVersionID

		LEFT JOIN dwh.Fact_Form ff 
		ON fiv.FormInstanceID = ff.CxFormInstanceId

		CROSS APPLY dwh.fn_FlattenJson(fiv.FormInstanceValues) AS fjson;

	WITH MaxFormInstances 
	AS 
	(
		SELECT 
			FormInstanceID,
			max(Version) as [MaxVersion]

		FROM 
			#FormAnswers

		GROUP BY
			FormInstanceID
	)

	INSERT INTO [dwh].[Fact_FormAnswers] 
	(
		FactFormId,
		FactFormAnswerId,
		CxFormInstanceId,
		CxFormInstanceVersionId,
		CxFormDefinitionId,
		CxFormDefinitionVersionID,
		Version,
		CompletedDate,
		QuestionOrder,
		QuestionPath,
		AnswerPath,
		FieldId,
		Question,
		QuestionDataType,
		AnswerOrder,
		Answer,
		IsLatest
	)

	SELECT
		f.FactFormId,
		f.FactFormAnswerId,
		f.FormInstanceID,
		f.FormInstanceVersionID,
		f.FormDefinitionId, 
		f.FormDefinitionVersionID,
		f.Version,
		f.CreatedDate,
		isnull(d.QuestionOrder,0),
		d.QuestionPath,
		f.AnswerPath,
		f.FieldId,
		d.label as Question,
		d.Type as QuestionDataType, 
		f.AnswerOrder,
		f.Answer,
		CASE
			WHEN mfi.MaxVersion IS NOT NULL THEN 1
			ELSE 0
		END AS IsLatest

	FROM 
		#FormAnswers f

		LEFT JOIN #FormDefinition d 
		ON f.FormDefinitionVersionId = d.FormDefinitionVersionID
		AND f.FieldId = d.FieldId

		LEFT JOIN MaxFormInstances mfi
		ON f.FormInstanceID = mfi.FormInstanceID
		AND f.[Version] = mfi.MaxVersion

END
dwh	BuildFactHHSRSAssessment	-- =============================================
-- Author:      Ben Reeve
-- Create Date: 09/04/2025
-- Description: Creates data for table Fact_HHSRSAssessment. Note that the view vwcx_surveyattribute from Keystone used by this proc was not created by
--				by TSG and is assumed to be correct.
-- =============================================
CREATE PROCEDURE [dwh].[BuildFactHHSRSAssessment]
AS
BEGIN
    -- SET NOCOUNT ON added to prevent extra result sets from
    -- interfering with SELECT statements.
    SET NOCOUNT ON

    TRUNCATE TABLE dwh.Fact_HHSRSAssessment;

	WITH FailureIssues
	AS
	(
		--Get failed component for each attribute and aggregate into a single ; delimited string
		SELECT 
			UPRN, 
			SurveyDate, 
			'Slight:' + STRING_AGG(Component, '; ') WITHIN GROUP (ORDER BY Component ASC) AS Issues

		FROM 
			staging.keystone_vwcx_surveyattribute
		WHERE 
			Attribute = 'Slight'

		GROUP BY 
			UPRN, 
			SurveyDate

		UNION

		SELECT 
			UPRN, 
			SurveyDate, 
			'Moderate:' + STRING_AGG(Component, '; ') WITHIN GROUP (ORDER BY Component ASC)

		FROM 
			staging.keystone_vwcx_surveyattribute

		WHERE 
			Attribute = 'Moderate'

		GROUP BY 
			UPRN, 
			SurveyDate

		UNION

		SELECT 
			UPRN, 
			SurveyDate, 
			'Severe:' + STRING_AGG(Component, '; ') WITHIN GROUP (ORDER BY Component ASC)

		FROM 
			staging.keystone_vwcx_surveyattribute

		WHERE 
			Attribute = 'Severe'
		
		GROUP BY 
			UPRN, 
			SurveyDate

	),
	/*Aggregate the above strings into a single row for each asset survey separated by a carriage return and line feed.
	This should render each set of issues (Slight, Moderate, Severe) to start on a new line.*/
	FailureSummary
	AS
	(
		SELECT
			UPRN,
			SurveyDate,
			STRING_AGG(Issues, CHAR(13) + CHAR(10)) AS FailureSummary

		FROM
			FailureIssues

		GROUP BY
			UPRN,
			SurveyDate
	),
	/*Get number of issues per Asset Survey via a pivot. Attribute 'None' is included in the subquery but not returned by the pivot. We don't need a count of
	None, but it ensures that asset surveys with no issues are still returned as an be flagged as not failed in a later query.*/
	NumberOfIssuesPivot
	AS
	(
		SELECT
			UPRN,
			SurveyDate,
			Slight,
			Moderate,
			Severe

		FROM
		(
			SELECT 
				UPRN, 
				SurveyDate, 
				Attribute, 
				AttributeID

			FROM 
				staging.keystone_vwcx_surveyattribute

			WHERE 
				Attribute IN ('Slight', 'Moderate', 'Severe', 'None')

		) SubQuery

		PIVOT
		(
			COUNT(AttributeID)
			FOR Attribute IN ([Slight], [Moderate], [Severe])
		) AS PivotTable
	)

	--Combine issue numbers with text summary of the issues and insert into fact table

	INSERT INTO dwh.Fact_HHSRSAssessment
	(
		DimAssetId,
		SurveyDate,
		Slight,
		Moderate,
		Severe,
		Failed,
		HasCat1Failures,
		HasCat2Failures,
		HasCat3Failures,
		FailureSummary,
		CxAssetId
	)

	SELECT
		ass.DimAssetId,
		piv.SurveyDate,
		piv.Slight,
		piv.Moderate,
		piv.Severe,
		CASE
			WHEN piv.Slight + piv.Moderate + piv.Severe > 0 THEN 1
			ELSE 0
		END AS Failed,
		CASE
			WHEN piv.Severe > 0 THEN 1 ELSE 0
		END AS HasCat1Failures,
		CASE
			WHEN  Moderate >0 THEN 1 ELSE 0
		END AS HasCat2Failures,
		CASE
			WHEN Slight >0 THEN 1 ELSE 0
		END AS HasCat3Failures,
		fs.FailureSummary,
		ass.AssetId

	FROM 
		NumberOfIssuesPivot piv 
		
		LEFT JOIN FailureSummary fs
		ON piv.UPRN = fs.UPRN
		AND piv.SurveyDate = fs.SurveyDate

		JOIN dwh.Dim_Asset ass
		ON piv.UPRN = ass.AssetReference
END
dwh	BuildFactLOLER	
-- =============================================
-- Author:      TSG
-- Create Date: 2024
-- Description: Original version - Creates the FactLOLER Data
-- =============================================

-- =============================================
-- Author:      Amit Kakkad
-- Create Date: 16th Oct 2024
-- Description: Fix issues with [Date Completed] and [Date Completedq]
-- =============================================

CREATE PROC [dwh].[BuildFactLOLER]
AS
	TRUNCATE TABLE dwh.Fact_LOLER;

	WITH LollerData
	AS
	(
		SELECT [UPRN]
			  ,[Site Address]
			  ,[Site Postcode]
			  ,[Equipment]
			  ,[Equipment Location]
			  ,[LOLER Inspection date]
			  ,[Inspection Outcome]
			  ,[Service Contractor]
			  ,[Issued to contractor]
			  ,[PD PO]
			  ,[Date required by]
			  ,[Date Completedq]
			  ,[Quotation No]
			  ,[Costs]
			  ,[Comments]
		FROM [staging].[sharepoint_runways_trolleys_lifting_points]

		WHERE UPRN IS NOT NULL

		UNION ALL

		SELECT [UPRN]
			  ,[Site Address]
			  ,[Site Postcode]
			  ,[Equipment]
			  ,[Equipment Location]
			  ,[LOLER Inspection date]
			  ,[Inspection Outcome]
			  ,[Service Contractor]
			  ,[Issued to contractor]
			  ,[PD PO]
			  ,[Date required by]
			  ,[Date Completedq]
			  ,[Quotation No]
			  ,[Costs]
			  ,[Comments]
		FROM [staging].[sharepoint_stairlifts_tfls_homelifts]

		WHERE UPRN IS NOT NULL

		UNION ALL

		SELECT [UPRN]
			  ,[Site Address]
			  ,[Site Postcode]
			  ,[Equipment]
			  ,[Equipment Location]
			  ,[LOLER Inspection date]
			  ,[Inspection Outcome]
			  ,[Service Contractor]
			  ,[Issued to contractor]
			  ,[PD PO]
			  ,[Date required by]
			  ,[Date Completedq]
			  ,[Quotation No]
			  ,[Costs]
			  ,[Comments]
		FROM [staging].[sharepoint_pressure_and_mechanical]

		WHERE UPRN IS NOT NULL

		UNION ALL

		SELECT [UPRN]
			  ,[Site Address2]
			  ,[Site Postcode]
			  ,[Equipment]
			  ,[Equipment Location]
			  ,[LOLER Inspection date]
			  ,[Inspection Outcome]
			  ,[Service Contractor]
			  ,[Issued to contractor/PO]
			  ,[PD PO]
			  ,[Date required by]
			  ,[Date Completedq] as [Date Completedq] -- Fixed by Amit Kakkad - 16/10/2024
			  ,[Quotation No.]
			  ,[Costs]
			  ,[Comments]
		FROM [staging].[sharepoint_passenger_lifts]

		WHERE UPRN IS NOT NULL

		UNION ALL

		SELECT [UPRN]
			  ,[Site Address2]
			  ,[Site Postcode]
			  ,[Equipment]
			  ,[Equipment Location]
			  ,[LOLER Inspection date]
			  ,[Inspection Outcome]
			  ,[Service Contractor]
			  ,[FW Issued to contractor]
			  ,[PD PO]
			  ,[Date required by]
			  ,[Date Completedq] as [Date Completedq] -- Fixed by Amit Kakkad - 16/10/2024
			  ,[Quotation No]
			  ,[Costs]
			  ,[Column1]
		FROM [staging].[sharepoint_hoists_adaptive_bath]

		WHERE UPRN IS NOT NULL
	)
	INSERT INTO dwh.Fact_LOLER
	(
		ID,
		UPRN,
		[Site Address],
		[Site Postcode],
		Equipment,
		[Equipment Location],
		[LOLER Inspection date],
		[Inspection Outcome],
		[Service Contractor],
		[Issued to contractor],
		[PD PO],
		[Date required by],
		[Date Completedq],
		[Quotation No],
		Costs,
		Comments
	)
	SELECT 
		ROW_NUMBER() OVER(ORDER BY Equipment, UPRN, [LOLER Inspection date]),
		UPRN,
		[Site Address],
		[Site Postcode],
		Equipment,
		[Equipment Location],
		[LOLER Inspection date],
		[Inspection Outcome],
		[Service Contractor],
		[Issued to contractor],
		[PD PO],
		[Date required by],
		[Date Completedq],
		[Quotation No],
		Costs,
		Comments
	FROM LollerData
dwh	BuildFactLRA	CREATE PROC dwh.BuildFactLRA
AS

	TRUNCATE TABLE dwh.Fact_LRA

	INSERT INTO dwh.Fact_LRA

	SELECT [UPRN]
		  ,[Site ]
		  ,[Date of LRA]
		  ,[Remedial / Recommendation ]
		  ,[Risk Rating ]
		  ,[Due Date]
		  ,[Cost (exc. VAT)]
		  ,[Notes]
		  ,[DUE BY]
		  ,[Complete]
	  FROM [staging].[sharepoint_lra]

	  WHERE UPRN IS NOT NULL
dwh	BuildFactNumberOfHomes	-- =============================================
-- Author:      Ben Reeve
-- Create Date: 22/04/2025
-- Description: Build table Fact_NumberOfHomes by exploding asset status records into individual rows for each day the asset status was effective.
-- =============================================
CREATE PROCEDURE [dwh].[BuildFactNumberOfHomes]
AS
BEGIN
    -- SET NOCOUNT ON added to prevent extra result sets from
    -- interfering with SELECT statements.
    SET NOCOUNT ON

	TRUNCATE TABLE dwh.Fact_NumberOfHomes;

	DROP TABLE IF EXISTS #AssetStatusByDay;
	DROP TABLE IF EXISTS #AssetAgreementByDay

	DECLARE @Date DATETIME
	--Want to get data for the past 5 financial years plus the current year, so find the start of the current financial year and then minus 5 years

	IF MONTH(GETDATE()) >3
		SET @Date = CONCAT(YEAR(GETDATE()), '04', '01')

	ELSE
	SET @Date = CONCAT(YEAR(GETDATE()) -1, '04', '01') 

	SET @Date = DATEADD(YEAR, -5, @Date);

	PRINT @Date;

	--To get day by day asset status data we need to "explode" AssetStatus records into a row for each day that falls between the status effective from and effective to dates.
	--A Recursive CTE would do this, but its extremly slow. Instead we make use of a simple sequence table by joining it to the below CTE.
	With AssetDays
	AS
	(
		--Get the number of days each status was active for.
		SELECT 
			AssetId,
			StatusId, 
			--Chanfe effective from date to @date if the status period started outside of 5 year window we want to capture
			CASE
				WHEN EffectiveFromDate < @Date THEN @Date
				ELSE EffectiveFromDate
			END AS EffectiveFromDate, 
			--Use todays date if effective to date is null
			ISNULL(EffectiveToDate, GETDATE()) AS EffectiveToDate, 
			--DATEDIFF to get number of days. Replacing effective from date and effective to date where needed using the same logic as above.
			DATEDIFF(dd, CASE WHEN EffectiveFromDate < @Date THEN @Date ELSE EffectiveFromDate END, ISNULL(EffectiveToDate, GETDATE())) AS NumberOfDays

		FROM 
			staging.cx_assetstatus 

		WHERE 
			--Filter status periods that were active during the past 5 years.
			(EffectiveFromDate >= @Date OR EffectiveToDate >= @Date OR EffectiveToDate IS NULL)

	)

	/*
	JOIN CTE to sequence table to "explode" the data.
	mapping_sequence is a table of one column which contains 10,001 rows and holds the numbers 0 to 10,000. By joining to this table using >=
	we explode the data from a date range to a row for each day. For example, in the previous CTE if an asset status was active for 100 days, we'd be
	joining to mapping_sequence where 100 >= SequenceNumber, which retrieves 101 rows for the rows 0 to 100. We now have 101 rows for our date range and we transform these
	rows to represent individual dates by adding the sequence number to the date as shown below.

	-------------------------------------------------------------------------------------------
	| AssetStatus | EffectiveFrom | EffectiveTo | Sequence | Date (effective from + sequence) |
	-------------------------------------------------------------------------------------------
	| 123456      | 01/01/2024    | 10/04/2024  | 0        | 01/01/2024                       |
	| 123456      | 01/01/2024    | 10/04/2024  | 1        | 02/01/2024                       |
	| 123456      | 01/01/2024    | 10/04/2024  | 2        | 03/01/2024                       |
	| 123456      | 01/01/2024    | 10/04/2024  | 3        | 04/01/2024                       |
	| 123456      | 01/01/2024    | 10/04/2024  | 4        | 05/01/2024                       |
	...
	| 123456      | 01/01/2024    | 10/04/2024  | 100      | 10/04/2024                       |
	-------------------------------------------------------------------------------------------
	*/

	SELECT 
		*, 
		DATEADD(dd, s.SequenceNumber, EffectiveFromDate) AS Date

	INTO 
		#AssetStatusByDay
	FROM 
		AssetDays ad 

		JOIN staging.mapping_sequence s
		ON ad.NumberOfDays >= s.SequenceNumber;


	INSERT INTO dwh.Fact_NumberOfHomes
	(
		DimAssetId,
		CxStatusId,
		[Date],
		AssetLet,
		CxAssetId
	)

	SELECT
		dass.DimAssetId,
		asd.StatusId,
		asd.date,
	--Check RentAgreementAsset to see if there is an active agreement in place
	CASE 
		WHEN EXISTS(
						SELECT 
							1 
						
						FROM 
							staging.cx_rentagreementasset raa 
							
						WHERE 
							asd.AssetId = raa.AssetId 
							AND asd.[Date] BETWEEN raa.EffectiveFromDate AND ISNULL(raa.EffectiveToDate, GETDATE())
					) THEN 1 
		ELSE 0 END AS AssetLet,
		dass.AssetId

	FROM 
		#AssetStatusByDay asd 

		LEFT JOIN dwh.Dim_Asset dass
		ON asd.AssetId = dass.CxAssetId

END
dwh	BuildFactOffer	-- =============================================
-- Author:      Ben Reeve
-- Create Date: 28/05/2025
-- Description: Builds Fact Offer
-- =============================================
CREATE PROCEDURE [dwh].[BuildFactOffer]
AS
BEGIN
    -- SET NOCOUNT ON added to prevent extra result sets from
    -- interfering with SELECT statements.
    SET NOCOUNT ON

	TRUNCATE TABLE dwh.Fact_Offer

	INSERT INTO dwh.Fact_Offer
	(
		CxOfferId ,
		DimContactGroupId,
		CxContactGroupId,
		CxAssetId,
		OfferDate,
		StatusId,
		Status
	)

	SELECT
		ao.OfferId AS CxOfferId,
		dcg.DimContactGroupId,
		aa.ContactGroupId AS CxContactGroupId,
		aml.AssetId AS CxAssetId,
		ao.OfferDate,
		ao.OfferStatusId AS StatusId,
		sl120.[Description] AS Status

	FROM 
		staging.cx_allocationoffer ao

		LEFT JOIN staging.cx_systemlookup sl120
		ON ao.OfferStatusId = sl120.LookupReference
		AND sl120.LookupTypeId = 120

		LEFT JOIN staging.cx_allocationmatchlistapplication amla
		ON ao.MatchListApplicationId = amla.MatchListApplicationId

		LEFT JOIN staging.cx_allocationapplication aa
		ON amla.ApplicationId = aa.ApplicationId

		LEFT JOIN dwh.Dim_ContactGroup dcg
		ON aa.ContactGroupId = dcg.CxContactGroupId

		LEFT JOIN staging.cx_allocationmatchlist aml
		ON amla.MatchListId = aml.MatchListId

END
dwh	BuildFactPayment	-- =============================================
-- Author:      Ben Reeve
-- Create Date: 05/03/2025
-- Description: Build script for Fact_Payment
--				19/03/2025 - Ben Reeve - Added links to Fact_Agreement
-- =============================================
CREATE PROCEDURE [dwh].[BuildFactPayment]
AS
BEGIN
    -- SET NOCOUNT ON added to prevent extra result sets from
    -- interfering with SELECT statements.
    SET NOCOUNT ON

    -- Insert statements for procedure here
    
	--Temp table used instead of CTE for better performance when joining with staging.cx_renttransaction
	DROP TABLE IF EXISTS #PeriodMap

	CREATE TABLE #PeriodMap
	(
		CalendarId INT, 
		Year INT, 
		PeriodNumber INT, 
		DimCalendarPeriodId INT
	)

	INSERT INTO #PeriodMap

	SELECT 
		rcy.CalendarId, 
		rcy.Year, 
		rcp.PeriodNumber, 
		cp.DimCalendarPeriodId

	FROM 
		staging.cx_rentcalendaryear rcy

		JOIN staging.cx_rentcalendarperiod rcp
		ON rcy.CalenderYearId = rcp.CalendarYearId

		JOIN dwh.Dim_CalendarPeriod cp
		ON rcp.CalendarPeriodId = cp.CalendarPeriodId;


	TRUNCATE TABLE dwh.Fact_Payment;

	WITH AccountAgreement AS
	(
		SELECT DISTINCT
		AccountId,
		AgreementId

		FROM
			staging.cx_rentagreementaccount raa LEFT JOIN staging.cx_rentagreementepisode rae
			ON raa.AgreementEpisodeId = rae.AgreementEpisodeId

			WHERE rae.EffectiveToDate > rae.EffectiveFromDate OR rae.EffectiveToDate IS NULL
	)

	INSERT INTO dwh.Fact_Payment
	(
		TransactionId,
		DimCalendarPeriodId,
		FactAgreementId, 
		CxAccountId,
		Description,
		Amount,
		CxAgreementId,
		PaymentType
	)
	SELECT 
		rt.TransactionId,
		pm.DimCalendarPeriodId,
		agr.FactAgreementId,
		rt.AccountId,
		rpt.Description,
		rt.TotalValue AS Amount,
		agr.CxAgreementId,
		rpt.PaymentTypeID


	FROM staging.cx_renttransaction rt 

	LEFT JOIN staging.cx_RentPaymentType rpt
	ON rt.PaymentTypeId = rpt.PaymentTypeID

	LEFT JOIN #PeriodMap pm
	ON rt.CalendarId = pm.CalendarId
	AND rt.Year = pm.Year
	AND rt.PeriodNumber = pm.PeriodNumber

	LEFT JOIN AccountAgreement aa
	ON rt.AccountId = aa.AccountId

	LEFT JOIN dwh.Fact_Agreement agr
	ON aa.AgreementId = agr.CxAgreementId

	WHERE rt.TransactionTypeId IN (3,4)

	ORDER BY rt.TransactionId;

	DROP TABLE #PeriodMap
END
dwh	BuildFactPersonHeadcountDaily	

-- =============================================
-- Author:      Amit Kakkad
-- Create Date: 15th May 2024
-- Description: Transforms FactPersonHeadcountDaily Data
-- =============================================

CREATE PROCEDURE [dwh].[BuildFactPersonHeadcountDaily] 
AS
BEGIN

    -- SET NOCOUNT ON added to prevent extra result sets from
    -- interfering with SELECT statements.
    SET NOCOUNT ON

-- Check if the Dim_CX_Calendar table exists
IF OBJECT_ID('dwh.Fact_PersonHeadcountDaily') IS NOT NULL
BEGIN
    DROP TABLE dwh.Fact_PersonHeadcountDaily;
END;

Print '#Temp_DimPersonAge';
-- FactPersonAgeMap
SELECT 
    DISTINCT
	PersonKey,
    Age,
	CAST(StartingDate AS DATE) AS FactPersonHeadcountDailyStartingDate,
	CAST(LeavingDate AS DATE) AS FactPersonHeadcountDailyLeavingDate
INTO #Temp_DimPersonAge
FROM dwh.Dim_Person
WHERE 1=1
--AND PersonCurrent_Flag = 1
AND ISNULL(StartingDate, '') != ''
;

Print '#Temp_FactWorkforceDaily';
SELECT 
	DISTINCT
	PositionKey, 
	PersonKey, 
	UnitStructureKey,
	DateKey,
		CONCAT
			(	
			DATEFROMPARTS(LEFT(CONVERT(VARCHAR, DateKey), 4), SUBSTRING(CONVERT(VARCHAR, DateKey), 5, 2), RIGHT(CONVERT(VARCHAR, DateKey), 2)),	' - ', 	CAST(PersonKey AS VARCHAR)
			) AS DatePersonKey
INTO #Temp_FactWorkforceDaily
FROM [staging].[mhr_FactWorkforceDaily] 
Where 1=1
--AND PersonKey IN (58604)
;

Print '#Temp_FactPersonHeadcountDaily1';
SELECT Distinct
	DATEFROMPARTS(LEFT(CONVERT(VARCHAR, DateKey), 4), SUBSTRING(CONVERT(VARCHAR, DateKey), 5, 2), RIGHT(CONVERT(VARCHAR, DateKey), 2)) AS IndexDate,
	CONCAT
		(	
		DATEFROMPARTS(LEFT(CONVERT(VARCHAR, DateKey), 4), SUBSTRING(CONVERT(VARCHAR, DateKey), 5, 2), RIGHT(CONVERT(VARCHAR, DateKey), 2)),	' - ', 	CAST(PersonKey AS VARCHAR)
		) AS DatePersonKey,
	1 as FactPersonHeadcountDaily_Flag, 
	DateKey,
	PersonKey,
	PersonHeadcount, 
	Age,
	Joiner as NewStarter_Flag, 
	Leaver as Leaver_Flag, 
	FTE as FPHDL_FTE,
	LoadID as FactPersonHeadcountDailyLoadId, 
	LoadDate as FactPersonHeadcountDailyLoadDate
INTO #Temp_FactPersonHeadcountDaily1
FROM [staging].[mhr_FactPersonHeadcountDaily] sf
Where 1=1
--AND PersonKey IN (58604)
AND PersonKey <> '-1';

Print '#Temp_FactPersonHeadcountDaily2';
Select 
	t1.*,
	t1.Age as FactPersonHeadcountDailyAge,
	CASE 
		WHEN t1.Age = 0 OR LEN(t1.Age) < 1 THEN 'No FactPersonHeadcountDailyAge'
		WHEN t1.Age BETWEEN 1 AND 20 THEN 'Under 21'
		WHEN t1.Age BETWEEN 21 AND 30 THEN '21-30'
		WHEN t1.Age BETWEEN 31 AND 40 THEN '31-40'
		WHEN t1.Age BETWEEN 41 AND 50 THEN '41-50'
		WHEN t1.Age BETWEEN 51 AND 60 THEN '51-60'
		WHEN t1.Age >= 61 THEN 'Over 60'
		ELSE 'Error'
	END AS FactPersonHeadcountDailyAgeBands,
	td.FactPersonHeadcountDailyStartingDate as FactPersonHeadcountDailyStartingDate,
	td.FactPersonHeadcountDailyLeavingDate as FactPersonHeadcountDailyLeavingDate
INTO #Temp_FactPersonHeadcountDaily2
FROM #Temp_FactPersonHeadcountDaily1 t1
LEFT JOIN #Temp_DimPersonAge td ON td.PersonKey = t1.PersonKey;

Print '#Temp_FactPersonHeadcountDaily3';
Select 
	t2.*,
	DATEDIFF(DAY, FactPersonHeadcountDailyStartingDate, IndexDate) AS FactPersonHeadcountDailyLengthofServiceDays,
	td.PositionKey as PositionKey,
	td.UnitStructureKey as UnitStructureKey
INTO #Temp_FactPersonHeadcountDaily3
FROM #Temp_FactPersonHeadcountDaily2 t2
LEFT JOIN #Temp_FactWorkforceDaily td ON td.DatePersonKey = t2.DatePersonKey
;

--Print 'dwh.Fact_PersonHeadcountDaily';
-- FactPersonHeadcountDailyFinal
Select 
	*
INTO dwh.Fact_PersonHeadcountDaily
FROM #Temp_FactPersonHeadcountDaily3
Where PersonKey <> '-1';

END;
dwh	BuildFactRecruitmentDaily	





-- =============================================
-- Author:      Amit Kakkad
-- Create Date: 28th May 2024
-- Description: Transforms FactRecruitmentDaily Data
-- =============================================

-- =============================================
-- Author:      Amit Kakkad
-- Create Date: 23rd Sept 2024
-- Description: Updates to FactRecruitmentDailyReportingStage_Flag and FactRecruitmentDailyReportingStage https://freedcamp.com/view/2728536/tasks/60981634
-- =============================================

CREATE PROCEDURE [dwh].[BuildFactRecruitmentDaily] 
AS
BEGIN

    -- SET NOCOUNT ON added to prevent extra result sets from
    -- interfering with SELECT statements.
    SET NOCOUNT ON

-- Check if the Fact_RecruitmentDaily table exists
IF OBJECT_ID('dwh.Fact_RecruitmentDaily') IS NOT NULL
BEGIN
    DROP TABLE dwh.Fact_RecruitmentDaily;
END;

SELECT 
    1 as FactRecruitmentDaily_Flag,
    frd.RecruitmentDailyKey, 
    frd.ApplicantKey, 
    frd.PositionKey, 
    frd.RequisitionKey, 
    DATEFROMPARTS(
        CAST(SUBSTRING(CAST(frd.DateKey AS VARCHAR(8)), 1, 4) AS INT),  -- Year part
        CAST(SUBSTRING(CAST(frd.DateKey AS VARCHAR(8)), 5, 2) AS INT),  -- Month part
        CAST(SUBSTRING(CAST(frd.DateKey AS VARCHAR(8)), 7, 2) AS INT)   -- Day part
    ) AS FactRecruitmentDailyDateKey,
    frd.StageKey, 
    frd.NewRequisitions, 
    frd.EndRequisitions, 
    frd.OfferedApplicants, 
    frd.RejectedApplicants, 
    frd.NewApplicants, 
    frd.AppointedApplicants,
    CONCAT(CAST(frd.ApplicantKey AS VARCHAR), ' - ', CAST(frd.RequisitionKey AS VARCHAR)) AS FactRecruitmentDailyApplicantRequisitionKey,
    CASE 
        WHEN red.RequisitionEndDate IS NULL OR LEN(red.RequisitionEndDate) < 1 THEN 'Requisition Open'
        ELSE ISNULL(CONVERT(VARCHAR, TRY_CAST(red.RequisitionEndDate AS DATE), 120), 'Requisition Open')
    END AS RequisitionEndDate,
    CASE
        WHEN red.RequisitionEndDate = 'Requisition Open' THEN 0
        ELSE 1
    END AS FactRecruitmentDailyRequisitionEnd_Flag
INTO #TempFactRecruitmentDailyLoad1
FROM [staging].[mhr_factrecruitmentdaily] frd
LEFT JOIN (
    SELECT 
        RequisitionKey,
        CASE 
            WHEN RequisitionEndDate IS NULL OR LEN(RequisitionEndDate) < 1 THEN 'Requisition Open'
            ELSE ISNULL(CONVERT(VARCHAR, TRY_CAST(RequisitionEndDate AS DATE), 120), 'Requisition Open')
        END AS RequisitionEndDate
    FROM dwh.Dim_Requisition
) red
ON frd.RequisitionKey = red.RequisitionKey
WHERE frd.ApplicantKey <> '-1';

SELECT 
    StageKey, 
    StageName, 
    StageGroup,
    CASE 
        --WHEN StageName IN ('0.3 Shortlisting', '0.1 Web applicant', '0.2 Manual Applicant', '3.0 Appointed') THEN 1 
		WHEN StageName IN ('0.1 Web applicant','0.2 Manual Applicant','1.0 First Interview','3.0 Appointed') THEN 1		 -- Added 23-Sept-2024
        ELSE 0 
    END AS FactRecruitmentDailyReportingStage_Flag,
    CASE 
        WHEN StageName = '0.3 Shortlisting' THEN 'Shortlisting'
		WHEN StageName = '0.4 Reject after Shortlisting' THEN 'Reject after Shortlisting'		-- Added 23-Sept-2024
		WHEN StageName = '1.0 First Interview' THEN 'First Interview'							-- Added 23-Sept-2024
        WHEN StageName IN ('0.1 Web applicant', '0.2 Manual Applicant') THEN 'Application'
        WHEN StageName = '3.0 Appointed' THEN 'Appointment'
        ELSE NULL
    END AS FactRecruitmentDailyReportingStage
INTO #TempDimRecruitmentStage
FROM [staging].[mhr_dimrecruitmentstage];

SELECT 
	tf1.*,
	--tf1.RequisitionEndDate as IndexDate,
	--CAST(CAST(tf1.RequisitionEndDate AS DATETIME) AS FLOAT) + 2 AS IndexDate, --The +2 ensures the returned value matches Qlik which uses 30/12/1899 as its calendar start. SQL Server uses 01/01/1900.
	--CAST(CAST(DATEADD(DAY, 2, CAST(tf1.RequisitionEndDate AS DATETIME)) AS FLOAT) AS FLOAT) AS IndexDate,
	TRY_CONVERT(DATE, tf1.RequisitionEndDate) AS IndexDate,
	tdrs.StageName,
	tdrs.StageGroup,
	tdrs.FactRecruitmentDailyReportingStage_Flag,
	tdrs.FactRecruitmentDailyReportingStage
INTO #TempFactRecruitmentDailyLoad2
--INTO dwh.Fact_RecruitmentDaily
FROM #TempFactRecruitmentDailyLoad1 tf1
LEFT JOIN #TempDimRecruitmentStage tdrs ON tf1.StageKey = tdrs.StageKey
;

SELECT 
    ApplicantKey, 
    PersonID
INTO #TempDimApplicant
FROM [staging].[mhr_dimapplicant];


SELECT 
	tf2.*,
	tda.PersonID
INTO #TempFactRecruitmentDailyLoad3
--INTO dwh.Fact_RecruitmentDaily
FROM #TempFactRecruitmentDailyLoad2 tf2
LEFT JOIN #TempDimApplicant tda ON tf2.ApplicantKey = tda.ApplicantKey
;

SELECT 
	PersonKey, 
	PersonID, 
	CAST(FromDate AS DATE) AS FromDate,
	CASE 
	WHEN CONVERT(VARCHAR, TRY_CAST(ToDate AS DATE), 120) = '9999-12-31' OR ToDate IS NULL THEN DATEADD(MONTH, 1, GETDATE())
	ELSE CONVERT(DATE, TRY_CAST(ToDate AS DATE))
	END AS ToDate,
	BirthDate
INTO #TempDimPerson
FROM [staging].[mhr_dimperson]
WHERE CurrentFlag=1;

SELECT Distinct
	tf3.*,
	tdp.PersonKey,
	tdp.FromDate,
	tdp.ToDate,
	tdp.BirthDate
INTO #TempFactRecruitmentDailyLoad4
FROM #TempFactRecruitmentDailyLoad3 tf3
LEFT JOIN #TempDimPerson tdp ON tf3.PersonID = tdp.PersonID
;

SELECT 
	a.*,
	CASE 
		WHEN FactRecruitmentDailyAge = 'No Age' THEN 'No Age'
		WHEN FactRecruitmentDailyAge < 21 THEN 'Under 21'
		WHEN FactRecruitmentDailyAge BETWEEN 21 AND 30 THEN '21-30'
		WHEN FactRecruitmentDailyAge BETWEEN 31 AND 40 THEN '31-40'
		WHEN FactRecruitmentDailyAge BETWEEN 41 AND 50 THEN '41-50'
		WHEN FactRecruitmentDailyAge BETWEEN 51 AND 60 THEN '51-60'
		WHEN FactRecruitmentDailyAge > 60 THEN 'Over 60'
	END AS FactRecruitmentDailyAgeBand
INTO #TempFactRecruitmentDailyLoad5
FROM
(
SELECT
	tf4.*,
	CONCAT(PersonID, ' - ', RequisitionKey) AS FactRecruitmentDailyPersonIDRequisitionKey,
	CASE 
		WHEN LEN(BirthDate) < 1 THEN 'No Age' 
		ELSE CAST(DATEDIFF(YEAR, BirthDate, FactRecruitmentDailyDateKey) AS VARCHAR(10))
	END AS FactRecruitmentDailyAge
FROM #TempFactRecruitmentDailyLoad4 tf4 
) a;

SELECT
	PersonKey,
	CASE 
		WHEN LEN(Religion) < 1 THEN 'No Data'
		ELSE Religion
	END AS FactRecruitmentDailyReligion,
	CASE 
		WHEN LEN(Gender) < 1 THEN 'No Data'
		ELSE Gender
	END AS FactRecruitmentDailyGender,
	CASE 
		WHEN LEN(ConsideredDisabled) < 1 THEN 'No Data'
		ELSE ConsideredDisabled
	END AS FactRecruitmentDailyConsideredDisabled,
	CASE 
		WHEN LEN(Nationality) < 1 THEN 'No Data'
		ELSE Nationality
	END AS FactRecruitmentDailyNationality,
	CASE 
		WHEN LEN(SexualOrientation) < 1 THEN 'No Data'
		ELSE SexualOrientation
	END AS FactRecruitmentDailySexualOrientation,
	CASE 
		WHEN LEN(EthnicOrigin) < 1 THEN 'No Data'
		ELSE EthnicOrigin
	END AS FactRecruitmentDailyEthnicOrigin
INTO #TempDWHDimPerson
FROM dwh.Dim_Person
WHERE PersonCurrent_Flag=1;

SELECT Distinct
	tf5.*,
	tdp.FactRecruitmentDailyReligion,
	tdp.FactRecruitmentDailyGender,
	tdp.FactRecruitmentDailyConsideredDisabled,
	tdp.FactRecruitmentDailyNationality,
	tdp.FactRecruitmentDailySexualOrientation,
	tdp.FactRecruitmentDailyEthnicOrigin
INTO #TempFactRecruitmentDailyLoad6
FROM #TempFactRecruitmentDailyLoad5 tf5
LEFT JOIN #TempDWHDimPerson tdp ON tf5.PersonKey = tdp.PersonKey
;

SELECT 
	Max(RecruitmentDailyKey) as RecruitmentDailyKey,
	StageKey,
	ApplicantKey,
	RequisitionKey,
	1 as FactRecruitmentDailyApplicantStageMostRecent_Flag
INTO #TempApplicantStageMostRecent
FROM #TempFactRecruitmentDailyLoad6
Group by StageKey, ApplicantKey, RequisitionKey;

SELECT Distinct
	tf6.*,
	ta.FactRecruitmentDailyApplicantStageMostRecent_Flag
INTO dwh.Fact_RecruitmentDaily
FROM #TempFactRecruitmentDailyLoad6 tf6
LEFT JOIN #TempApplicantStageMostRecent ta ON tf6.RecruitmentDailyKey = ta.RecruitmentDailyKey
;

END;
dwh	BuildFactRepairAppointment	CREATE PROCEDURE [dwh].[BuildFactRepairAppointment]
AS

    TRUNCATE TABLE dwh.Fact_RepairAppointment

    DROP TABLE IF EXISTS #JobVisitTeams

    SELECT 
        PARENTID AS JobVisitId,
        STRING_AGG(ASSIGNEDWORKERID, '-') WITHIN GROUP (ORDER BY ASSIGNEDWORKERID) AS JobVisitTeam

    INTO
        #JobVisitTeams

    FROM 
        staging.drs_c_scheduleitem

    WHERE 
        ASSIGNEDWORKERID IS NOT NULL

    GROUP BY 
        PARENTID

    DROP TABLE IF EXISTS #SMV;
    SELECT 
        PARENT_ID, 
        sum(STANDARDMINUTEVALUE) as [SMVTOTAL]
    INTO #SMV
    FROM [staging].[drs_c_sorcode]
    GROUP BY PARENT_ID;

    DROP TABLE IF EXISTS #JobOnTime;

    --Get the min job start date
    WITH JobStartEnd
    AS
    (
        SELECT 
            j.NAME, 
            MIN(j.CURRENTASSIGNMENT_START) AS JobMinStartDateTime , 
            INITIALTIMEWINDOW_END

        FROM 
            staging.drs_c_job j
            
            LEFT JOIN staging.drs_c_serviceorder so
            ON j.NAME = so.NAME

        GROUP BY 
            j.NAME, 
            so.INITIALTIMEWINDOW_END
    )

    --Flag if job started on time and store to temp table
    SELECT
        NAME,
        CASE
            WHEN JobMinStartDateTime <= INITIALTIMEWINDOW_END THEN 1
            ELSE 0
        END AS JobVisitOnTime

    INTO
    #JobOnTime

    FROM
        JobStartEnd

    /*
    --Calculcate which Agreement and Contact Group the repair is linked to, based on when the repair was logged and which agreement was active against the asset at that time
    DROP TABLE IF EXISTS #JobAgreementContactGroup;

    SELECT 
        --j.[DATE-LOGGED],
        j.[JOB-NO] as JobNo,
        j.[PLACE-REF] as PlaceRef, 
        ra.AssetId as Asset, 
        a.AgreementId as Agreement, 
        /*a.EffectiveFromDate as 'Agreement Effective From', a.EffectiveToDate  as 'Agreement Effective To',*/  
        rae.ContactGroupId as ContactGroup
        /*rae.EffectiveFromDate as 'Contact Group Effective From', rae.EffectiveToDate as 'Contact Group Effective To'*/

    INTO #JobAgreementContactGroup

    FROM [staging].[opencontractor_rm-job] j
    join [staging].[cx_assetreference] ra 
    on j.[place-ref] = ra.Reference
    and ra.AssetReferenceTypeId = 1
    join [staging].[cx_rentagreementasset] a 
    on ra.assetid = a.assetid 
    and cast(j.[date-logged] as date) between cast(a.EffectiveFromDate as date) and cast(COALESCE(a.EffectiveToDate,'9999-12-31') as date)
    join [staging].[cx_rentagreementepisode] rae on a.AgreementId = rae.AgreementId
    and cast(j.[date-logged] as date) between cast(rae.EffectiveFromDate as date) and cast(COALESCE(rae.EffectiveToDate,'9999-12-31') as date)
    */

        INSERT INTO dwh.Fact_RepairAppointment
    (
        JobVisitId,
        [JobNumber],
        JobVistDuration,
        JobVisitDate,
        JobVisitStartDate,
        JobVisitEndDate,
        [JobVisitAppointmentKeptCount],
        [JobVisitOnTimeCount],
        [JobVisitCompletedCount],
        [JobVisitNoAccessCount],
        JobVisitNoAccessTenantRefusedCount,
        [JobVisitOperativeDeclinedCount],
        [JobVisitFollowupCount],
        [JobVisitNotRequiredCount],
        [JobVisitTeamWorkCount],
        [JobVisitInspectionRequiredCount],
        [JobVisitOpenVisitPreTodayCount],
        [JobVisitNewStatusCount],
        JobVisitTeam,
        [JobVisitOrderReference],
        [JobVisitTotalSMV]
    )


    SELECT
        DrsJob.USERID as JobVisitId,
        ocjob.[JOB-NO] as JobNumber, 
        --DrsJob.[STATUS] as JobVisitStatus,
        --Get date difference in seconds, divide by 3600 to get hours. Get date difference in seconds, modulus 3600 (returns the remainer of /3600, so we get the minutes left after full hours have
        --been accounted for), divide by 60 to convert seconds to minutes.
        CONCAT(DATEDIFF(ss, DrsJob.CURRENTASSIGNMENT_START, DrsJob.CURRENTASSIGNMENT_END)/3600, ':', RIGHT(CONCAT('0', DATEDIFF(ss, DrsJob.CURRENTASSIGNMENT_START, DrsJob.CURRENTASSIGNMENT_END)%3600 / 60), 2)) AS JobVistDuration,
        CAST(DrsJob.CURRENTASSIGNMENT_START as DATE) as JobVisitDate,
        DrsJob.CURRENTASSIGNMENT_START as JobVisitStartDate, 
        DrsJob.CURRENTASSIGNMENT_END	as JobVisitEndDate,
        --DrsJob.GLOBALCURRENTTIMEWINDOW_START as JobVisitTimeWindowStart,
        --DrsJob.GLOBALCURRENTTIMEWINDOW_END as JobVisitTimeWindowEnd,
        CASE 
            WHEN DrsJob.CURRENTASSIGNMENT_START BETWEEN DrsJob.GLOBALCURRENTTIMEWINDOW_START AND DrsJob.GLOBALCURRENTTIMEWINDOW_END THEN 1 
            Else 0 
        end as JobVisitAppointmentKept,
        jot.JobVisitOnTime,
        CASE
            WHEN csc.Category = 'Completed' THEN 1
            ELSE 0
        END AS JobVisitCompleted,
        CASE
            WHEN csc.Category = 'No Access' THEN 1
            ELSE 0
        END AS JobVisitNoAccess,
        CASE
            WHEN csc.Category = 'No Access Tenant Refused' THEN 1
            ELSE 0
        END JobVisitNoAccessTenantRefusedCount,
        CASE
            WHEN csc.Category = 'Operative Declined' THEN 1
            ELSE 0
        END AS JobVisitOperativeDeclined,
        CASE
            WHEN csc.Category = 'Follow up' THEN 1
            ELSE 0
        END AS JobVisitFollowup,
        CASE
            WHEN csc.Category = 'Not Required' THEN 1
            ELSE 0
        END AS JobVisitNotRequired,
        CASE
            WHEN csc.Category = 'Team Work' THEN 1
            ELSE 0
        END AS JobVisitTeamWork,
        CASE
            WHEN csc.Category = 'Inspection' THEN 1
            ELSE 0
        END AS JobVisitInspectionRequired,
        --DrsJob.BD_TASK_COMPLETION_STAT as JobVisitCompletionStatus,
        --csc.Category as JobVisitCompletionStatusDescription,
        CASE
            WHEN DrsJob.GLOBALCURRENTTIMEWINDOW_START <= getdate() and DrsJob.[STATUS] <> 'completed' THEN 1 
            ELSE 0
        END AS JobVisitOpenVisitPreToday,
        CASE 
            WHEN DrsJob.[STATUS] = 'new' then 1 
            else 0
        END AS JobVisitNewStatus, 
        --ar.AssetId,
        jvt.JobVisitTeam,
        DrsJob.PARENTID as [JobVisitOrderReference],
        #SMV.[SMVTOTAL] as [JobVisitTotalSMV]
        --Link to SOR
        --[ABANDON-REASON] AbandonReason,
        --pri.[DESCRIPTION] AS Priority,
        --DrsJob.STATUS as VisitStatus, 
        --jacg.Agreement,
        --jacg.ContactGroup

    FROM 
        staging.drs_c_job DrsJob

        --JOIN to OC to only include appointments with jobs
        JOIN staging.[opencontractor_rm-job] OcJob
        ON DrsJob.NAME = ocjob.[JOB-NO]

        --LEFT JOIN staging.cx_AssetReference ar
        --ON OcJob.[PLACE-REF] = ar.Reference
        --AND ar.AssetReferenceTypeId = 1

        LEFT JOIN #JobVisitTeams jvt
        ON DrsJob.USERID = jvt.JobVisitId

        LEFT JOIN #JobOnTime jot
        ON DrsJob.NAME = jot.NAME

        LEFT JOIN staging.mapping_CompletionStatusCategory csc
        ON DrsJob.BD_TASK_COMPLETION_STAT = csc.VisitCompletionStatus

        LEFT JOIN #SMV 
        On DrsJob.USERID = #SMV.PARENT_ID
        --LEFT JOIN #JobAgreementContactGroup jacg
        --on OcJob.[JOB-NO] = jacg.JobNo
dwh	BuildFactRepairJob	
CREATE PROCEDURE [dwh].[BuildFactRepairJob]
AS

    SET NOCOUNT ON

    TRUNCATE TABLE [dwh].[Fact_RepairJob]

    ;with NumberOfAppointments as
    (
        select dr.[JOB-NO], dra.PARENTID, count(dra.USERID) as CountJobs
        from staging.[opencontractor_rm-job] dr join staging.drs_c_job dra on dr.[JOB-NO] = dra.[NAME] --left join dwh.Fact_RepairAppointment fra on dra.Jobvisitid = fra.Jobvisitid 
        --where dr.JobStatusSimplified = 'Open'
        group by dr.[JOB-NO], dra.PARENTID
    )

    --select * from NumberOfAppointments order by 3 desc

    INSERT INTO dwh.Fact_RepairJob
    (
        [JobNumber],
        [JobCompletedDate],
        [JobLoggedDate],
        [JobInTargetCount],
        [JobCompletedCount],
        [JobDurationInDays],
        [JobDurationInHours],
        [JobRightFirstTimeCount],
        [JobCostAmount],
        [JobCancelledCount],
        [JobOutstandingCount],
        [JobNoAccessCount],
        [JobCostRaisedAmount],
        [JobCostVariationAmount],
        JobMostRecentSurveyId,
        JobSurveyCSATScore,
        JobOverDueCount,
        JobOverDueInHours,
        JobOverDueInDays,
        JobCountOfAppointments
    )
    SELECT
        r.JobNumber as JobNumber,
        JobDateCompleted AS JobCompletedDate,
        JobDateLogged AS JobLoggedDate,
        case 
            when JobDateCompleted <= JobTargetDate AND JobStatusSimplified = 'Completed' 
            Then 1 
            else 0 
        end as [JobInTargetCount],
        case 
            when JobStatusSimplified = 'Completed' 
            Then 1 
            else 0 
        end  as [JobCompletedCount],
        case when JobStatusSimplified = 'Completed' 
            Then datediff(HOUR, JobDateLogged,JobDateCompleted) / 24.0 
            else 0 
        end as [JobDurationInDays],
        case when JobStatusSimplified = 'Completed' 
            Then datediff(HOUR, JobDateLogged,JobDateCompleted)
            else 0 
        end  as [JobDurationInHours],

        JobRightFirstTime as [JobRightFirstTimeCount],
        j.[TOTAL-VALUE] as [JobCostAmount],
        case 
            when JobStatusSimplified = 'Abandoned' 
            Then 1 
            else 0 
        end as [JobCancelledCount],
        case 
            when JobStatus = '06' 
            Then 1 
            else 0 
        end  as [JobOutstandingCount],
        0 as [JobNoAccessCount],
        j.[ORIG-LOGGED-VALUE] as [JobCostRaisedAmount],
        j.[TOTAL-VALUE] - j.[ORIG-LOGGED-VALUE] as [JobCostVariationAmount],
        s.SurveyID JobMostRecentSurveyId,
        CASE WHEN s.SurveyType = 'csat' 
            then s.[SurveyScore] 
        else null 
        end as JobSurveyCSATScore,
        CASE 
            WHEN JobOverdue = 1 THEN 1 
            Else 0 
        end as JobOverDueCount,
        CASE 
            WHEN JobOverdue = 1 THEN datediff(HOUR, JobTargetDateTime,GETDATE())
            ELSE 0
        end as JobOverDueInHours,
        CASE 
            WHEN JobOverdue = 1 THEN datediff(HOUR, JobTargetDateTime,GETDATE()) / 24.0
            ELSE 0
        end as JobOverDueInDays,
        a.CountJobs as JobCountOfAppointments
    FROM 
        dwh.Dim_Repair r

    LEFT JOIN staging.[opencontractor_rm-job] j
        ON r.JobNumber = j.[JOB-NO]

    LEFT JOIN dwh.Dim_SurveyResponse s 
        on r.JobNumber = s.JobNumber

    LEFT JOIN NumberOfAppointments a 
        ON r.JobNumber = a.[JOB-NO]
dwh	BuildFactSAPRating	-- =============================================
-- Author:      Ben Reeve
-- Create Date: 10/03/2025
-- Description: Creates data for table Fact_SAPRating
--				20/03/2025 - Ben Reeve - Changed code to get data from miviewauditenergyjobresult instead of tblEnergyResults.
--				07/04/2025 - Ben Reeve - Added EPC rating.
-- =============================================
CREATE PROCEDURE [dwh].[BuildFactSAPRating]
AS
BEGIN
    -- SET NOCOUNT ON added to prevent extra result sets from
    -- interfering with SELECT statements.
    SET NOCOUNT ON

    -- Insert statements for procedure here
	TRUNCATE TABLE dwh.Fact_SAPRating;
	
	--Get EnergyJobId's where there are more than 11,500 records per EnergyJobId. This means all assets have been processed.
	WITH JobCount
	AS
	(
		SELECT
			intEnergyJobId, 
			COUNT(*) AS JobCount

		FROM 
			staging.keystone_miviewauditenergyjobresult

		GROUP BY 
			intEnergyJobId

		HAVING 
			COUNT(*) > 11500
	),
	--Find the MAX intEnergyJobId per asset. This would be the latest record.
	LatestAssetJob
	AS
	(
		SELECT
			ejr.intAssetId,
			MAX(ejr.intEnergyJobId) AS LatestJob 

		FROM 
			staging.keystone_miviewauditenergyjobresult ejr

			JOIN JobCount jc
			ON ejr.intEnergyJobId = jc.intEnergyJobId

		GROUP BY
			ejr.intAssetId
	)
	
	--Start final insert into Fact Table
	INSERT INTO dwh.Fact_SAPRating
	(
		DimAssetId,
		DateCompleted,
		Score,
		EPCRating,
		IsLatest,
		CxAssetId
	)

	SELECT 
		dass.DimAssetId,
		CAST(ejr.dteTimestamp AS DATE) AS DateCompleted,
		ejr.numSAP AS Score,
		ejr.vchSAPBand,
		CASE
			WHEN lab.LatestJob = jc.intEnergyJobId THEN 1
			ELSE 0
		END AS IsLatest,
		dass.AssetId


	FROM 
		staging.keystone_miviewauditenergyjobresult ejr 
		
		--Join to job count eliminates jobs with less then 11,500 assest
		JOIN JobCount jc
		ON ejr.intEnergyJobId = jc.intEnergyJobId

		--Gets the latest job id for each asset
		JOIN LatestAssetJob lab
		ON ejr.intAssetId = lab.intAssetId

		LEFT JOIN staging.keystone_tblasset kass
		ON ejr.intAssetId = kass.intAssetID

		JOIN staging.cx_asset cass
		ON kass.vchUPRN = cass.AssetReference

		JOIN dwh.Dim_Asset dass
		ON cass.AssetId = dass.CxAssetId
END
dwh	BuildFactStockConditionSurvey	-- =============================================
-- Author:      Ben Reeve
-- Create Date: 04/04/2025
-- Description: Build script for Fact StockConditionSurvey
-- =============================================
CREATE PROCEDURE [dwh].[BuildFactStockConditionSurvey]
AS
BEGIN
    -- SET NOCOUNT ON added to prevent extra result sets from
    -- interfering with SELECT statements.
    SET NOCOUNT ON

    TRUNCATE TABLE dwh.Fact_StockConditionSurvey;

	--Get survey dates from survey attributes
	WITH Surveys
	AS
	(
		SELECT DISTINCT 
			dass.CxAssetId, 
			CAST(SurveyDate AS DATE) AS DateCompleted

		FROM 
			staging.keystone_miview_asset_surveyattributes asa

			JOIN staging.keystone_tblasset ass
			ON asa.AssetID = ass.intAssetID

			JOIN dwh.Dim_Asset dass
			ON ass.vchUPRN = dass.AssetReference

		WHERE 
			asa.SurveyDate IS NOT NULL
	),
	--Get the lastest survey date
	LatestSurvey
	AS
	(
		SELECT 
			s.CxAssetId,
			MAX(s.DateCompleted) AS MaxDate

		FROM
			Surveys s

		GROUP BY
			s.CxAssetId
	)

	--Final query to join survey data with latest survey date and insert into table
	INSERT INTO dwh.Fact_StockConditionSurvey
	(
		DimAssetId,
		DateCompleted,
		IsLatest,
		CxAssetId
	)


	SELECT
		s.CxAssetId,
		s.DateCompleted,
		CASE
			WHEN ls.MaxDate IS NOT NULL THEN 1
			ELSE 0
		END AS IsLatest,
		s.CxAssetId

	FROM
		Surveys s

		LEFT JOIN LatestSurvey ls
		ON s.CxAssetId = ls.CxAssetId
		AND s.DateCompleted = ls.MaxDate
	
END
dwh	BuildFactVacancyDaily	





-- =============================================
-- Author:      Amit Kakkad
-- Create Date: 20th May 2024
-- Description: Transforms FactVacancyDaily Data
-- =============================================

CREATE PROCEDURE [dwh].[BuildFactVacancyDaily] 
AS
BEGIN
    -- SET NOCOUNT ON added to prevent extra result sets from
    -- interfering with SELECT statements.
    SET NOCOUNT ON

-- Check if the FactVacancyDaily table exists
IF OBJECT_ID('dwh.Fact_VacancyDaily') IS NOT NULL
BEGIN
    DROP TABLE dwh.Fact_VacancyDaily;
END;

SELECT 
	1 as FactVacancyDaily_Flag,
	--MakeDate(Left(DateKey,4), Mid(DateKey,5,2) , Right(DateKey,2)) as IndexDate,
    DATEFROMPARTS(
        CAST(LEFT(CAST(DateKey AS VARCHAR(8)), 4) AS INT), 
        CAST(SUBSTRING(CAST(DateKey AS VARCHAR(8)), 5, 2) AS INT), 
        CAST(RIGHT(CAST(DateKey AS VARCHAR(8)), 2) AS INT)
    ) AS IndexDate,
	DateKey, 
	PositionKey, 
	PersonKey, 
	UnitStructureKey, 
	Vacancy, 
	InPeriodStatus,
	StartDateOccupancy, 
	EndDateOccupancy 
INTO dwh.Fact_VacancyDaily
FROM [staging].[mhr_factworkforcedaily]
Where Vacancy =1;

END;
dwh	BuildFactVoid	-- =============================================
-- Author:      Ben Reeve
-- Create Date: 07/03/2025
-- Description: Builds Fact Void
--				02/04/2025 - Ben Reeve - Added logic for IsAdapted
-- =============================================
CREATE PROCEDURE [dwh].[BuildFactVoid]
AS
BEGIN
    -- SET NOCOUNT ON added to prevent extra result sets from
    -- interfering with SELECT statements.
    SET NOCOUNT ON

	TRUNCATE TABLE dwh.Fact_Void;

	/*********************************************************
	**********************************************************
	*******************CTE CODE START*************************
	**********************************************************
	*********************************************************/

	--Use LAG and LEAD to get previous and next RentAgreementAssetId from AssetStatus
	WITH PreviousNextAgreements
	AS
	(
		SELECT 
			RentVoidEpisodeId, 
			LAG(RentAgreementAssetId) IGNORE NULLS OVER (ORDER BY AssetId, EffectiveFromDate) AS PreviousRaaId, 
			LEAD(RentAgreementAssetId) IGNORE NULLS OVER (ORDER BY AssetId, EffectiveFromDate) AS NextRaaId
		FROM 
			staging.cx_assetstatus

		WHERE
			NOT(EffectiveToDate < EffectiveFromDate) OR EffectiveToDate IS NULL
	),
	--Get Agreement ID's from RentAgreementAsset. Filter out rows without a VoidEpisodeId. DISTINCT data to remove duplicates
	VoidAgreements
	AS
	(
		SELECT DISTINCT
			RentVoidEpisodeId,
			PreviousRaaId,
			NextRaaId,
			raaPrev.AgreementId AS PreviousCxAgreementId,
			raaNext.AgreementId AS FollowingCxAgreementId


		FROM
			PreviousNextAgreements pna 
		
			LEFT JOIN staging.cx_RentAgreementAsset raaPrev
			ON pna.PreviousRaaId = raaPrev.AgreementAssetId

			LEFT JOIN staging.cx_RentAgreementAsset raaNext
			ON pna.NextRaaId = raaNext.AgreementAssetId

		WHERE 
			RentVoidEpisodeId IS NOT NULL

	),
	--Get max void episode start date. This will be used later to see if a void episode is the lastest episode by comparing start date to max start date
	LatestRVE
	AS
	(
		SELECT 
			AssetId,
			MAX(StartDate) AS MaxStartDate

		FROM
			staging.cx_rentvoidepisode rve

		GROUP BY AssetId
	),
	--Total void loss for a void episode
	VoidLoss
	AS
	(
		SELECT 
			VoidEpisodeId, 
			SUM(value) AS Amount

		FROM 
			staging.cx_RentVoidTransaction

		GROUP BY 
			VoidEpisodeId
	),
	Adapated
	AS
	(
		SELECT
		UPRN, 
		COUNT(ComponentID) as CountOfComponenets, 
		COALESCE(min(InstallationDate),Min(SurveyDate)) as ComponentDate --get either the earliest installation date or the earliest survey

	FROM 
		staging.keystone_miview_asset_surveyattributes
		
	WHERE 
		ComponentID in (4106866,4106929) -- 4106866 = Adaptations --4106929 = Disabled Adaptations

	GROUP BY 
		UPRN
	)

	/*********************************************************
	**********************************************************
	********************CTE CODE END**************************
	**********************************************************
	*********************************************************/

	INSERT INTO dwh.Fact_Void
	(
		DimAssetId,
		CxVoidEpisodeId,
		PreviousCxAgreementId,
		FollowingCxAgreementId,
		StartDate,
		EndDate,
		EstimatedCompletionDate,
		TotalVoidLoss,
		TotalDaysVoid,
		OverTarget,
		IsAdapted,
		CouncilTaxApplicable,
		SatisfactionWithLettingsService,
		SatisfactionWithConditionOfNewHome,
		IsCurrent,
		IsLatest,
		IsFuture,
		IsPast,
		CxAssetId

	)

	SELECT
		ass.DimAssetId,
		rve.VoidEpisodeId AS CxVoidEpisodeId,
		va.PreviousCxAgreementId,
		va.FollowingCxAgreementId,
		rve.StartDate,
		rve.EndDate,
		rve.ProposedEndDate,
		vl.Amount AS TotalVoidLoss,
		GREATEST(DATEDIFF(day, StartDate, ISNULL(EndDate, GETDATE())), 0) AS TotalDaysVoid, --GREATEST sets value to 0 for void periods starting in the future
		CASE
			WHEN ass.AssetStatus like 'C3%' AND DATEDIFF(day, StartDate, GETDATE()) > 25 THEN 1
			ELSE 0
		END AS OverTarget,
		CASE 
			WHEN ad.ComponentDate < rve.StartDate THEN 1
			ELSE 0
		END AS IsAdapted,
		CASE
			WHEN CAST(DATEADD(month, 6, StartDate) AS DATE) > CAST(GETDATE() AS DATE) THEN 1
			ELSE 0
		END AS CouncilTaxApplicable,
		NULL AS SatisfactionWithLettingsService, --Need more info on where to get this
		NULL AS SatisfactionWithConditionOfNewHome, --Need more info on where to get this
		CASE
			WHEN StartDate <= GETDATE() AND (EndDate IS NULL OR EndDate > GETDATE()) THEN 1
			ELSE 0
		END AS IsCurrent,
		CASE
			WHEN rve.StartDate = lr.MaxStartDate THEN 1
			ELSE 0
		END AS IsLatest,
		CASE
			WHEN StartDate > GETDATE() THEN 1
			ELSE 0
		END AS IsFuture,
		CASE
			WHEN EndDate < GETDATE() THEN 1
			ELSE 0
		END AS IsPast,
		ass.AssetId


	FROM 
		staging.cx_rentvoidepisode rve

		LEFT JOIN VoidAgreements va
		ON rve.VoidEpisodeId = va.RentVoidEpisodeId

		LEFT JOIN LatestRVE lr
		ON rve.AssetId = lr.AssetId

		LEFT JOIN dwh.Dim_Asset ass
		ON rve.AssetId = ass.CxAssetId

		LEFT JOIN VoidLoss vl
		ON rve.VoidEpisodeId = vl.VoidEpisodeId

		LEFT JOIN Adapated ad
		ON ass.AssetReference = ad.UPRN

	WHERE
		--Exclude records that were created in error
		NOT(EndDate < StartDate) 
			OR EndDate IS NULL

	ORDER BY 
		ass.DimAssetId,
		rve.StartDate

END
dwh	BuildFactVoidByPeriod	-- =============================================
-- Author:      Ben Reeve
-- Create Date: 12/03/2025
-- Description: Builds FactVoidByPeriod. Every void episode is attached to all the calendar periods that are covered by the void period. Void loss is then allocated to periods where
--				the transaction date falls into the period and the transaction date falls within the void period. 
--
--				NOTE - transactions that occur outside of the void period are not included. Some void periods are excluded because they predate the calendar records in CX.
-- =============================================
CREATE PROCEDURE [dwh].[BuildFactVoidByPeriod]
AS
BEGIN
    -- SET NOCOUNT ON added to prevent extra result sets from
    -- interfering with SELECT statements.
    SET NOCOUNT ON

	TRUNCATE TABLE dwh.Fact_VoidByPeriod;

	--CTE to get calendar periods and link to DimCalendarPeriod
	With CalendarPeriods
	AS
	(
		SELECT 
			rcy.CalendarId, 
			c.Description,
			rcy.Year, 
			rcp.PeriodNumber, 
			rcp.PeriodStartDate,
			rcp.PeriodEndDate,
			cp.DimCalendarPeriodId

		FROM 
			staging.cx_rentcalendar c
		
			JOIN staging.cx_rentcalendaryear rcy
			ON c.CalendarId = rcy.CalendarId

			JOIN staging.cx_rentcalendarperiod rcp
			ON rcy.CalenderYearId = rcp.CalendarYearId

			JOIN dwh.Dim_CalendarPeriod cp
			ON rcp.CalendarPeriodId = cp.CalendarPeriodId

	)

	INSERT INTO dwh.Fact_VoidByPeriod
	(
		FactVoidId,
		DimCalendarPeriodId,
		DimAssetId,
		CxRentVoidEpisodeId,
		SumCharges,
		SumAdjustments,
		TotalVoidLoss,
		IsCurrent,
		CxAssetId
	)

	SELECT 
		v.FactVoidId,
		cp.DimCalendarPeriodId,
		v.DimAssetId,
		v.CxVoidEpisodeId,
		SUM(CASE WHEN rvt.TransactionTypeId = 1 THEN rvt.Value END) AS SumCharges,
		SUM(CASE WHEN rvt.TransactionTypeId = 2 THEN rvt.Value END) AS SumAdjustments,
		SUM(rvt.Value) AS TotalVoidLoss,
		v.IsCurrent,
		v.CxAssetId
	FROM 
		dwh.Fact_Void v 

		/*Join void periods to every possible calendar period that they could fall into. Need to account for:
			-calendar periods that start before the void and the the void falls into
			-calendar periods that end after the void and the void falls into
			-calendar periods that start and end between the void start and end dates
		*/
		JOIN CalendarPeriods cp
		ON v.StartDate BETWEEN cp.PeriodStartDate AND cp.PeriodEndDate --void start date falls inbetween calendar period start and end (calendar periods the void starts)
			OR ISNULL(v.EndDate, CAST(GETDATE() AS DATE)) BETWEEN cp.PeriodStartDate AND cp.PeriodEndDate --void end date falls inbetween calendar period start and end (calendar periods the void ends)
			OR cp.PeriodStartDate BETWEEN v.StartDate AND ISNULL(v.EndDate, CAST(GETDATE() AS DATE)) --Calendar period start date falls inbetween void start and end date (calendar periods starting during void period)
			--Last OR commented out as believed to be unnecessary.
			--OR cp.PeriodEndDate BETWEEN v.StartDate AND ISNULL(v.EndDate, CAST(GETDATE() AS DATE)) --Calendar period end date falls inbetween void start and end date (calendar periods ends during void period)

		LEFT JOIN staging.cx_RentVoidTransaction rvt
		ON v.CxVoidEpisodeId = rvt.VoidEpisodeId
		AND rvt.TransactionDate BETWEEN cp.PeriodStartDate AND cp.PeriodEndDate
		AND rvt.TransactionDate BETWEEN v.StartDate AND ISNULL(v.EndDate, CAST(GETDATE() AS DATE))

	GROUP BY
		v.FactVoidId,
		cp.DimCalendarPeriodId,
		v.DimAssetId,
		v.CxAssetId,
		v.CxVoidEpisodeId,
		v.IsCurrent

END
dwh	BuildFactVoidStage	-- =============================================
-- Author:      Ben Reeve
-- Create Date: 10/03/2025
-- Description: Creates table Fact_VoidStage. Note that query will not match the number of records in AssetStatus with a RentVoidEpisodeId. 
--				Some status records link to a void episode that shouldn't exist (episode end date is before episode start date). 
--				The join to Fact_Void excludes these records as the logic to exclude those records is build into the Fact_Void build process.
--				Proc needs to be run after Dim_Asset and Fact_Void table builds.
-- =============================================
CREATE PROCEDURE [dwh].[BuildFactVoidStage]
AS
BEGIN
    -- SET NOCOUNT ON added to prevent extra result sets from
    -- interfering with SELECT statements.
    SET NOCOUNT ON

    -- Insert statements for procedure here
    TRUNCATE TABLE dwh.Fact_VoidStage;

	WITH LatestStatus
	AS
	(
		SELECT 
			AssetId,
			MAX(EffectiveFromDate) AS MaxEffFromDate

		FROM
			staging.cx_assetstatus ast

		WHERE
			NOT(ast.EffectiveToDate < ast.EffectiveFromDate) 
			OR ast.EffectiveToDate IS NULL

		GROUP BY
			AssetId
	)

	INSERT INTO dwh.Fact_VoidStage
	(
		DimAssetId,
		CxAssetStatusId,
		FactVoidId,
		StartDate,
		EndDate,
		VoidLoss,
		StageDaysVoid,
		IsCurrent,
		IsLatest,
		CxAssetId
	)

	SELECT
		ass.DimAssetId,
		ast.StatusCodeId AS CxAssetStatusId,
		vd.FactVoidId,
		ast.EffectiveFromDate AS StartDate,
		ast.EffectiveToDate AS EndDate,
		SUM(rvt.Value) AS VoidLoss,
		DATEDIFF(day, ast.EffectiveFromDate, ISNULL(ast.EffectiveToDate, GETDATE())) AS StageDaysVoid,
		CASE
			WHEN ast.EffectiveFromDate <= GETDATE() AND (ast.EffectiveToDate IS NULL OR ast.EffectiveToDate > GETDATE()) THEN 1
			ELSE 0
		END AS IsCurrent,
		CASE
			WHEN ast.EffectiveFromDate =  ls.MaxEffFromDate THEN 1
			ELSE 0
		END AS IsLatest,
		ass.AssetId
	FROM 
		staging.cx_assetstatus ast 

		JOIN dwh.Fact_Void vd
		ON ast.RentVoidEpisodeId = vd.CxVoidEpisodeId

		JOIN dwh.Dim_Asset ass
		ON ast.AssetId = ass.CxAssetId

		LEFT JOIN LatestStatus ls
		ON ast.AssetId = ls.AssetId
		AND ast.EffectiveFromDate = ls.MaxEffFromDate

		LEFT JOIN staging.cx_rentvoidtransaction rvt
		ON ast.RentVoidEpisodeId = rvt.VoidEpisodeId
		--all dates cast to DATE to drop time element. Transaction datetime values tend to be set at midnight and can cause issues if a time has been set on the
		--asset status. As asset changes don't change multiple times on a given date, this logic shouldn't cause an issue
		AND CAST(rvt.TransactionDate AS DATE) BETWEEN CAST(ast.EffectiveFromDate AS DATE) AND CAST(ISNULL(ast.EffectiveToDate, GETDATE()) AS DATE)

	WHERE
		(NOT(ast.EffectiveToDate < ast.EffectiveFromDate) 
		OR ast.EffectiveToDate IS NULL)

	GROUP BY
		ass.DimAssetId,
		ass.AssetId,
		ast.StatusCodeId,
		vd.FactVoidId,
		ast.EffectiveFromDate,
		ast.EffectiveToDate,
		DATEDIFF(day, ast.EffectiveFromDate, ISNULL(ast.EffectiveToDate, GETDATE())),
		CASE
			WHEN ast.EffectiveFromDate <= GETDATE() AND (ast.EffectiveToDate IS NULL OR ast.EffectiveToDate > GETDATE()) THEN 1
			ELSE 0
		END,
		CASE
			WHEN ast.EffectiveFromDate =  ls.MaxEffFromDate THEN 1
			ELSE 0
		END,
		ast.RentVoidEpisodeId

	ORDER BY DimAssetId, FactVoidId, StartDate
END
dwh	BuildFactWelfare	-- =============================================
-- Author:      Ben Reeve
-- Create Date: 14/04/2025
-- Description: Creates data for table Fact_Welfare. The first CTE to identify the case is Jim's logic based on the case tables that he
--				provided scripts for.
-- =============================================
CREATE PROCEDURE [dwh].[BuildFactWelfare]
AS
BEGIN
    -- SET NOCOUNT ON added to prevent extra result sets from
    -- interfering with SELECT statements.
    SET NOCOUNT ON

    TRUNCATE TABLE dwh.Fact_Welfare;

	WITH WelfareSupportCases AS 
	(   --Logic from Jim to identify cases
		SELECT 
			c.CxCaseId,
			c.StartDate AS CaseCreatedDate,
			cc.ContactId AS ContactId,
			c.EndDate AS CaseEndDate

		FROM 
			dwh.Fact_Case c

			JOIN dwh.Fact_CaseTask fct 
			on c.FactCaseId = fct.FactCaseId

			JOIN dwh.Fact_Form ff 
			ON fct.CxTaskId = ff.ParentEntityId
			AND ff.ParentEntityType = 'CRM Task'

			JOIN dwh.Fact_FormAnswers f 
			ON ff.FactFormId = f.FactFormId

			LEFT JOIN staging.cx_systemcasecontact cc
			ON c.CxCaseId = cc.caseid 
			and cc.primecontact = 1

		WHERE 
			f.answer = 'welfare'
			AND f.IsLatest = 1
			AND c.CRMSubjectId = 190
	),
	--Get the earliest assigned date. Not sure if this is right
	AssignedDate
	AS
	(
		SELECT
			sco.CaseId,
			MIN(sco.EffectiveFromDate) AS AssignedDate


		FROM
			staging.cx_systemcaseownership sco

		GROUP BY
			sco.CaseId
	),
	--Find the first agreement start date for a contact group
	FirstRentAgreementDate
	AS
	(
		SELECT 
			cg.ContactGroupId, 
			MIN(rae.EffectiveFromDate) AS StartDate

		FROM 
			staging.cx_rentagreementepisode rae 
			
			LEFT JOIN staging.cx_contactgroup cg
			ON rae.ContactGroupId = cg.ContactGroupId

		WHERE 
			(rae.EffectiveFromDate < rae.EffectiveToDate OR rae.EffectiveToDate IS NULL)
			AND (cg.EffectiveFromDate < cg.EffectiveToDate OR cg.EffectiveToDate IS NULL)

		GROUP BY 
			cg.ContactGroupId
	),
	--Based on the earliest start date above, get the agreement episode id
	FirstAgreementEp
	AS
	(
		SELECT
			fra.ContactGroupId,
			rae.AgreementEpisodeId,
			1 AS FirstLet

		FROM
			FirstRentAgreementDate fra JOIN staging.cx_rentagreementepisode rae
			ON fra.ContactGroupId = rae.ContactGroupId
			AND fra.StartDate = rae.EffectiveFromDate

			JOIN staging.cx_rentagreementasset raa
			ON rae.AgreementId = raa.AgreementId

		WHERE 
			(rae.EffectiveFromDate < rae.EffectiveToDate OR rae.EffectiveToDate IS NULL)
			AND (raa.EffectiveFromDate < raa.EffectiveToDate OR raa.EffectiveToDate IS NULL)
	),
	--Get data for FactWelfare with row number. A couple of cases cause multiple rows in the data because of rare instances where a case was raised
	--during a period when the contact had multiple overlapping rent agreement episodes. For the final insert only rn=1 will be included in the fact table. 
	FactWelfareTemp
	AS
	(
		SELECT
			ROW_NUMBER() OVER (PARTITION BY CxCaseId ORDER BY CxCaseId, FirstLet) as rn,
			c.CxCaseId,
			cg.DimContactGroupId,
			c.CaseCreatedDate,
			c.CaseEndDate,
			ad.AssignedDate,
			DATEDIFF(dd, c.CaseCreatedDate, c.CaseEndDate) AS DaysToComplete,
			ISNULL(fle.FirstLet, 0) AS FirstLet
		FROM  
			WelfareSupportCases c 

			JOIN staging.cx_contactgroupmember cgm 
			ON c.ContactId = cgm.ContactId
			
			JOIN staging.cx_rentagreementepisode a 
			ON cgm.ContactGroupId = a.ContactGroupId

			JOIN dwh.Dim_ContactGroup cg
			ON a.ContactGroupId = cg.CxContactGroupId

			LEFT JOIN AssignedDate ad
			ON c.CxCaseId = ad.CaseId

			LEFT JOIN FirstAgreementEp fle
			ON cgm.ContactGroupId = fle.ContactGroupId
			AND a.AgreementEpisodeId = fle.AgreementEpisodeId

			

		WHERE --CxCaseId = 68501 AND
			/*c.CaseCreatedDate >= cgm.EffectiveFromDate
			AND (c.CaseCreatedDate < cgm.EffectiveToDate OR cgm.EffectiveToDate IS NULL)*/
			--AND 
			c.CaseCreatedDate >= a.EffectiveFromDate
			AND (c.CaseCreatedDate < a.EffectiveToDate OR a.EffectiveToDate IS NULL)

	),
	FinancialGains
	AS
	(
		SELECT
			r.TaskId, 
			r.TextResponse, 
			f.Description,
			sct.CaseId

	FROM 
		staging.cx_systemcasetaskinformationfieldresponse r 
		
		JOIN staging.cx_systemcasetaskdefinitioninformationfield f
		ON r.TaskDefinitionInformationFieldId = f.TaskDefinitionInformationFieldId

		JOIN staging.cx_systemcasetask sct
		ON r.TaskId = sct.TaskId

	WHERE 
		f.description = 'Monetary Amount £' --This could be wrong?
	)


	INSERT INTO dwh.Fact_Welfare
	(
		CxCaseId,
		DimContactGroupId,
		DateCreated,
		DateCompleted,
		AssignedTo,
		FinancialGains,
		DaysToComplete,
		FirstLet
	)

	SELECT
		CxCaseId,
		DimContactGroupId,
		CaseCreatedDate,
		CaseEndDate,
		NULL, --AssignedDate, Not sure if correct at the moment so leave out
		STRING_AGG(fg.TextResponse, '; ') AS FinancialGains, --Not safe to convert to number and SUM
		DaysToComplete,
		FirstLet
	FROM
		FactWelfareTemp fwt LEFT JOIN FinancialGains fg
		ON fwt.CxCaseId = fg.CaseId

	WHERE
		fwt.rn = 1

	GROUP BY
		CxCaseId,
		DimContactGroupId,
		CaseCreatedDate,
		CaseEndDate, 
		--AssignedDate, Not sure if correct at the moment so leave out
		DaysToComplete,
		FirstLet
	
END
dwh	BuildFactWelfareCase	CREATE PROCEDURE dwh.BuildFactWelfareCase
AS
BEGIN

	TRUNCATE TABLE dwh.Fact_WelfareCase;

	DROP TABLE IF EXISTS #WelfareTemp;

	;with FloatingSupportCases as 
	(
		select 
		c.CaseId as CaseId,
		c.CaseCreatedDate as CaseCreatedDate,
		c.CaseEndDate as CaseCompletedDate,
		c.ContactId as ContactId,
		fct.Status
	from dwh.Fact_CaseTask fct 
	join dwh.Fact_Form ff on fct.CxTaskId = ff.ParentEntityId
		and ff.ParentEntityType = 'CRM Task'
	join dwh.Fact_FormAnswers f on ff.FactFormId = f.FactFormId
	join dwh.Dim_Case c on fct.CxCaseId = c.CaseId and CaseGenericType = 'Referral Case'
	where 
		f.answer = 'welfare'
		and f.IsLatest = 1
	),
	FloatingSupportAgreement as
	(
	SELECT
		a.AgreementId,
		c.CaseId,
		cgm.ContactGroupId,
		c.CaseCreatedDate,
		c.CaseCompletedDate,
		c.Status,
		ROW_NUMBER() OVER (PARTITION BY a.AgreementId ORDER BY c.CaseCreatedDate) AS rn
	FROM staging.cx_rentagreementepisode a 
	LEFT JOIN staging.cx_contactgroupmember cgm 
	ON a.ContactGroupId = cgm.ContactGroupId
	LEFT JOIN FloatingSupportCases c 
	ON cgm.ContactId = c.ContactId
	WHERE
	c.CaseCreatedDate >= cgm.EffectiveFromDate
	AND (c.CaseCreatedDate < cgm.EffectiveToDate OR cgm.EffectiveToDate IS NULL)
	AND c.CaseCreatedDate >= a.EffectiveFromDate
	AND (c.CaseCreatedDate < a.EffectiveToDate OR a.EffectiveToDate IS NULL)
	)
	SELECT AgreementId, ContactGroupId, CaseId, CaseCreatedDate, CaseCompletedDate, Status, 		
	DATEDIFF(DD,CaseCreatedDate,CaseCompletedDate) as DaysToComplete

	INTO #WelfareTemp
	FROM FloatingSupportAgreement
	WHERE rn = 1;


    INSERT INTO dwh.Fact_WelfareCase (
        FactWelfareCaseId,
        CxCaseId,
        DimContactGroupId,
        DateCreated,
        DateCompleted,
        AssignedTo,
        FinancialGains,
        DaysToComplete,
        FirstLet
    )
    SELECT
        CaseId,
        CaseId,
        ContactGroupId,
        CaseCreatedDate,
        CaseCompletedDate,
        null as AssignedTo,
        null as FinancialGains,
        DaysToComplete,
        null as FirstLet
    FROM #WelfareTemp;


END;
dwh	BuildJobRightFirstTime	
CREATE PROCEDURE [dwh].[BuildJobRightFirstTime]
AS

    SET NOCOUNT ON
    DROP TABLE IF EXISTS staging.JobRightFirstTimeLookup;

    /*
    FTF is defined as:
    First Visit Definition- Jobs Completed within one visit and where the job requires multiple trades who may follow on from each other, then the work would still be considered Completed at first visit so long as each of the trades / types of work were Completed in one visit as planned.
    */

    WITH TradeVisits
    AS
    (
        --Get the Min and Max start date for each trade against a job. If the trade only visited once then the min and max will be the same
        SELECT
            j.NAME, 
            ut.Trade, 
            MIN(j.CURRENTASSIGNMENT_START) AS MinStartDate,
            MAX(j.CURRENTASSIGNMENT_START) AS MaxStartDate

        FROM 
            staging.drs_c_job j 
            
            JOIN staging.drs_c_scheduleitem si
            ON j.USERID = si.PARENT_ID

            LEFT JOIN staging.drs_UserTrade ut
            ON si.ASSIGNEDWORKERID = ut.DRSUserId

            LEFT JOIN staging.mapping_CompletionStatusCategory csc
            ON j.BD_TASK_COMPLETION_STAT = csc.VisitCompletionStatus

        WHERE 
            csc.Category = 'Completed'

        GROUP BY 
            j.NAME, 
            ut.Trade 
    )

    SELECT 
        Name,
        --If the number of records RFT (Min Start date = max start date) is the same as the total number of record then Job is RFT
        CASE
            WHEN SUM(CASE WHEN MinStartDate = MaxStartDate THEN 1 ELSE 0 END) = COUNT(*) THEN 1
            --ELSE 0
        END AS JobRft,
        'RFT1' as RFTType

    INTO 
       staging.JobRightFirstTimeLookup
    FROM
        TradeVisits

    GROUP BY
        Name

    --remove null records as these jobs were not compelted first time. This table is a list of jobs which have been completed first time
    delete from staging.JobRightFirstTimeLookup where [JobRft] is null and [RFTType] = 'RFT1'

/*
And If the first visit outcome is no access or tenant refused, but second visit is completed this should be classed as FTF 
*/

;with Visits
    AS
    (
        SELECT 
            j.NAME, 
            j.USERID,
            j.PARENTID,
            j.STATUS,
            j.BD_TASK_COMPLETION_STAT,
            Row_Number() OVER (PARTITION BY PARENTID ORDER BY USERID) as RowNo

        FROM 
            staging.drs_c_job j               
    ),
FirstVisitNoAccess AS
(
    select * from Visits where (RowNo = 1 and BD_TASK_COMPLETION_STAT in ('NO ACCESS','TENANT REFUSED')) 
),
SecondVisitComplete AS
(
    select *
    from Visits v
    where (v.RowNo = 2 and v.BD_TASK_COMPLETION_STAT = 'COMPLETED') 
),
RFT AS
(
    select v.NAME, v.USERID, v.PARENTID, v.BD_TASK_COMPLETION_STAT, v.RowNo, na.USERID as USERID2, na.PARENTID as PARENTID2, na.RowNo as RowNo2, na.BD_TASK_COMPLETION_STAT as BD_TASK_COMPLETION_STAT2
    from FirstVisitNoAccess v
    inner join SecondVisitComplete na on v.PARENTID = na.PARENTID
)

INSERT INTO staging.JobRightFirstTimeLookup select DISTINCT NAME as Name, 1 as 'JobRft','RFT2' as RFTType from RFT;
dwh	FlattenAk8Test	

CREATE PROCEDURE [dwh].[FlattenAk8Test]
AS
BEGIN
    SET NOCOUNT ON;

    -- Declare variables
    DECLARE @columnList NVARCHAR(MAX);
    DECLARE @sql NVARCHAR(MAX);
    DECLARE @blockStart INT = 1;
    DECLARE @blockEnd INT;
    DECLARE @rowCount INT;

    -- Get the total number of rows in the table
    SELECT @rowCount = COUNT(*) FROM [staging].[ak8test];

    -- Step 1: Generate a list of distinct labels to use as columns
    SELECT @columnList = STRING_AGG(QUOTENAME(label), ', ')
    FROM (SELECT DISTINCT label FROM [staging].[ak8test]) AS labels;

    ---- Step 2: Create the flattened table
    --SET @sql = '
    --    IF OBJECT_ID(''staging.FlattenedAk8Test'', ''U'') IS NOT NULL
    --        DROP TABLE staging.FlattenedAk8Test;

    --    CREATE TABLE staging.FlattenedAk8Test (
    --        InteractionID NVARCHAR(MAX), -- Key column
    --        ' + (SELECT STRING_AGG(QUOTENAME(label) + ' NVARCHAR(MAX)', ', ')
    --             FROM (SELECT DISTINCT label FROM [staging].[ak8test]) AS labels) + '
    --    );
    --';
    --EXEC sp_executesql @sql;

    -- Step 3: Loop through each block of 80 rows
    WHILE @blockStart <= @rowCount
    BEGIN
        SET @blockEnd = @blockStart + 79;

        -- Construct the dynamic SQL to insert data into the flattened table
        SET @sql = '
            INSERT INTO staging.FlattenedAk8Test (InteractionID, ' + @columnList + ')
            SELECT 
                MAX(CASE WHEN label = ''Interaction ID'' THEN value END) AS InteractionID, ';

        -- Add dynamic column mappings for all labels
        SELECT @sql = @sql + STRING_AGG(
            'MAX(CASE WHEN label = ''' + label + ''' THEN value END) AS ' + QUOTENAME(label),
            ', '
        )
        FROM (SELECT DISTINCT label FROM [staging].[ak8test]) AS labels;

        -- Complete the query
        SET @sql = @sql + '
            FROM (
                SELECT *, ROW_NUMBER() OVER (ORDER BY (SELECT NULL)) AS rn
                FROM [staging].[ak8test]
            ) AS sub
            WHERE rn BETWEEN ' + CAST(@blockStart AS NVARCHAR) + ' AND ' + CAST(@blockEnd AS NVARCHAR) + '
        ';

        -- Execute the dynamic SQL
        EXEC sp_executesql @sql;

        -- Move to the next block
        SET @blockStart = @blockStart + 80;
    END;
END;
dwh	GetComplianceSnapshot	CREATE PROCEDURE dwh.GetComplianceSnapshot
    --@param1 /*parameter name*/ int /*datatype_for_param1*/ = 0, /*default_value_for_param1*/
    --@param2 /*parameter name*/ int /*datatype_for_param1*/ = 0 /*default_value_for_param2*/
-- add more stored procedure parameters here
AS
BEGIN
    -- body of the stored procedure
    --SELECT @param1, @param2
    SELECT * FROM dwh.SnapshotComplianceFact
END
dwh	GetLatestScrollId	CREATE PROCEDURE dwh.GetLatestScrollId
    @ScrollId NVARCHAR(MAX) OUTPUT
AS
BEGIN
    SET NOCOUNT ON;

    SELECT @ScrollId = s.[scrollId]
    FROM [eightbyeight] s
    WHERE s.ID = (SELECT MAX(ID) FROM s.[eightbyeight]);
END
dwh	GetWorkingDay	
CREATE PROCEDURE [dwh].[GetWorkingDay]
    @InputDate datetime = null

AS
BEGIN

    SELECT  [dwh].[fn_GetWorkingDayOfTheMonth](@InputDate) as WorkingDayOfMonth 
    --select '6' as WorkingDayOfMonth -- always return 6 while in testing
END
dwh	ZZ_DEL_BuildFactEightByEight	

CREATE PROCEDURE [dwh].[ZZ_DEL_BuildFactEightByEight]
AS
BEGIN
    SET NOCOUNT ON;

	-- Drop the target Fact Table
	DROP TABLE [dwh].[Fact_EightByEight];

    -- Insert into the transform table from the staging table
    SELECT 
        [ID],
        [dnis] AS [DNIS],
        [aaDestination] AS [AA Destination],
        [callId] AS [Call Id],
        [startTimeUTC] AS [Start Time UTC],
        [startTime] AS [Start Time],
		CAST([startTime] AS DATE) AS [Start Date],
        [connectTimeUTC] AS [Connect Time UTC],
        [connectTime] AS [Connect Time],
        [disconnectedTimeUTC] AS [Disconnected Time UTC],
        [disconnectedTime] AS [Disconnected Time],
		CAST([disconnectedTime] AS DATE) AS [Disconnected Date],
        [talkTimeMS] AS [Talk Time MS],
        [talkTime] AS [Talk Time],
        [caller] AS [Caller],
        [callerName] AS [Caller Name],
        [callee] AS [Callee],
        [calleeName] AS [Callee Name],
        [direction] AS [Direction],
        [callerId] AS [Caller Id],
        [missed] AS [Missed],
        [abandoned] AS [Abandoned],
        [answered] AS [Answered],
        [answeredTime] AS [Answered Time],
        [calleeDisconnectOnHold] AS [Callee Disconnect On Hold],
        [callerDisconnectOnHold] AS [Caller Disconnect On Hold],
        [pbxId] AS [Pbx Id],
        [sipCallId] AS [Sip Call Id],
        [lastLegDisposition] AS [Last Leg Disposition],
        [callLegCount] AS [Call Leg Count],
        [callTime] AS [Call Time],
        [ringDuration] AS [Ring Duration],
        [abandonedTime] AS [Abandoned Time],
        [calleeHoldDurationMS] AS [Callee Hold Duration MS],
        [calleeHoldDuration] AS [Callee Hold Duration],
        [waitTimeMS] AS [Wait Time MS],
        [waitTime] AS [Wait Time],
        [departments] AS [Departments],
        [branches] AS [Branches],
        [ControlID] AS [Control ID]
    INTO [dwh].[Fact_EightByEight]
    FROM [staging].[eightbyeight]
	WHERE 1=1
	--AND [ControlID] = (SELECT MAX([ControlID]) FROM [staging].[eightbyeight])
	;

END
